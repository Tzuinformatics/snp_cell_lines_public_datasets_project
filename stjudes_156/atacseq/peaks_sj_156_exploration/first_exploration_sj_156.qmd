# 1 Setup and global options
## 1.1 Load libraries
```{r}
## 1.1 Load libraries and global parameters -------------------------------
suppressPackageStartupMessages({
  library(dplyr)
  library(ggplot2)
  library(tidyr)
  library(DESeq2)
  library(matrixStats)
  library(GenomicRanges)
  library(GenomeInfoDb)
  library(ChIPseeker)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(org.Hs.eg.db)
})

half_batches <- read.csv("../../half_batches_3_156sj.csv")
second_batches <- read.csv("snp_summary_with_flags_all_batches.csv")

# Remove the 'X' column from half_batches
half_batches_clean <- half_batches[, !(colnames(half_batches) %in% "X")]

# Row-bind the cleaned half_batches with second_batches
combined_batches <- rbind(half_batches_clean, second_batches)

# Check the result
head(combined_batches)

## Global parameters for PCA filters
MIN_READS_PCA   <- 10L     # min counts per peak
MIN_SAMPLES_PCA <- 5L      # min samples with counts >= MIN_READS_PCA
N_TOP_VAR_PCA   <- 50000L  # max number of most-variable peaks

## Color palettes used throughout
allele_cols <- c(T = "#E4007C", C = "#D3AF37")             # T (pink), C (gold)
geno_cols   <- c(TT = "#E4007C", TC = "#4F6D7A", CC = "#D3AF37")  # genotype colors


```

# 2. SNP C/T profiles and genotype metadata
## 2.1 Load SNP summary tables and merge

```{r}
## 2.1 Load SNP summary tables and merge ---------------------------------

half_batches <- read.csv("../../half_batches_3_156sj.csv")
second_batches <- read.csv("snp_summary_with_flags_all_batches.csv")

## Remove the generic 'X' column (row index) if present
half_batches_clean <- half_batches %>%
  dplyr::select(-any_of("X"))

## Sanity check: column sets should match before binding
stopifnot(
  identical(
    sort(colnames(half_batches_clean)),
    sort(colnames(second_batches))
  )
)

## Safer row-bind (respects column names)
combined_batches <- dplyr::bind_rows(half_batches_clean, second_batches)

## Rename ALT.% column once to a safer name
combined_batches <- combined_batches %>%
  dplyr::rename(ALT_pct = `ALT.`)

## Quick look
head(combined_batches)

```


## 2.2 Derive C/T-based coverage state and T fraction

```{r}
## 2.2 Derive C/T-based coverage state and T fraction --------------------

ct_only <- combined_batches %>%
  transmute(
    Sample,
    C,
    T,
    ct_state = case_when(
      T > 0 & C == 0 ~ "TT",
      T > 0 & C > 0  ~ "TC",
      C > 0 & T == 0 ~ "CC",
      TRUE           ~ "NoCov"     # no coverage / weird combinations
    ),
    Tfrac = if_else(C + T > 0, T / (C + T), NA_real_)
  )

## Order: TT -> TC -> CC -> NoCov, and within each by decreasing Tfrac
sample_levels <- ct_only %>%
  arrange(
    factor(ct_state, levels = c("TT", "TC", "CC", "NoCov")),
    desc(Tfrac)
  ) %>%
  pull(Sample)

```

## 2.3 Define genotype from ALT percentage and QC vs C/T-based state

```{r}
## 2.3 Define genotype from ALT% and QC vs C/T-based state ---------------

combined_batches <- combined_batches %>%
  mutate(
    genotype = case_when(
      ALT_pct == 100 ~ "TT",
      ALT_pct == 0   ~ "CC",
      between(ALT_pct, 1, 99) ~ "TC",
      TRUE ~ NA_character_
    )
  )

## Join C/T state and genotype to check consistency
geno_qc <- ct_only %>%
  left_join(combined_batches %>% dplyr::select(Sample, genotype),
            by = "Sample")

## Cross-tabulation for QC (optional: inspect in console)
geno_qc_table <- table(geno_qc$ct_state, geno_qc$genotype, useNA = "ifany")
geno_qc_table

```

## 2.4 Barplot of C vs T counts per sample (ordered by genotype & Tfrac)
```{r}
## 2.4 Barplot of C vs T counts per sample -------------------------------

snp_long <- ct_only %>%
  dplyr::select(Sample, C, T) %>%
  pivot_longer(cols = c(C, T),
               names_to = "Base",
               values_to = "Count") %>%
  mutate(
    Sample = factor(Sample, levels = sample_levels),
    Base   = factor(Base, levels = c("T", "C"))  # T on top of C in stacks
  )

ggplot(snp_long, aes(x = Sample, y = Count, fill = Base)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = allele_cols) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(
      angle = 90, hjust = 1, vjust = 0.5, size = 12
    ),
    axis.text.y   = element_text(size = 12),
    axis.title.x  = element_text(size = 16),
    axis.title.y  = element_text(size = 16),
    legend.title  = element_text(size = 14),
    legend.text   = element_text(size = 12),
    plot.title    = element_text(size = 18, face = "bold"),
    panel.grid.major.x = element_blank()
  ) +
  labs(
    title = "C vs T counts per sample (ordered by C/T state and T fraction)",
    x = "Sample",
    y = "Read count",
    fill = "Allele"
  )

```


# 3. ATAC consensus peak matrix and genomic annotation
## 3.1 Load featureCounts output and build counts matrix

```{r}
## 3.1 Load featureCounts matrix -----------------------------------------

fc <- read.delim(
  "after_adding_missing/consensus_peaks.mLb.clN.featureCounts.txt",
  header       = TRUE,
  comment.char = "#",
  check.names  = FALSE   # keep original sample names
)

## Split annotation vs counts
anno   <- fc[, 1:6]
counts <- as.matrix(fc[, -(1:6)])

rownames(counts) <- anno$Geneid
storage.mode(counts) <- "integer"

## Clean column names: strip full paths and reduce to "ATAC_XX_REP1"
colnames(counts) <- basename(colnames(counts))
colnames(counts) <- sub("^(ATAC_\\d+_REP1).*", "\\1", colnames(counts))

## Sanity: Length should equal (End - Start + 1); hard stop if not
stopifnot(all(anno$Length == (anno$End - anno$Start + 1)))

```


## 3.2 Build GRanges object and keep standard chromosomes

```{r}
## 3.2 Build GRanges and keep standard chromosomes -----------------------

gr <- GRanges(
  seqnames = anno$Chr,
  ranges   = IRanges(start = anno$Start, end = anno$End),
  strand   = ifelse(anno$Strand %in% c("+", "-"), anno$Strand, "*")
)
names(gr) <- anno$Geneid

## Harmonize chromosome naming style with TxDb (UCSC style: chr1, chr2, ...)
seqlevelsStyle(gr) <- "UCSC"

## Restrict to canonical chromosomes; drop chrM and unused levels
gr <- keepStandardChromosomes(gr, pruning.mode = "coarse")   # chr1–22, chrX, chrY, chrM
gr <- keepSeqlevels(gr, setdiff(seqlevels(gr), "chrM"), pruning.mode = "coarse")
gr <- keepSeqlevels(gr, seqlevelsInUse(gr), pruning.mode = "coarse")

## Align counts rows to GRanges after chromosome filtering
common_ids <- intersect(rownames(counts), names(gr))
stopifnot(length(common_ids) > 0)

counts <- counts[common_ids, , drop = FALSE]
gr     <- gr[common_ids]

```


## 3.3 Annotate peaks with ChIPseeker (±1 kb around TSS)

```{r}
## 3.3 Annotate peaks with ChIPseeker (±1 kb TSS) ------------------------

txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

peakAnno <- annotatePeak(
  gr,
  TxDb      = txdb,
  tssRegion = c(-1000, 1000),   # promoter window; report this in Methods
  annoDb    = "org.Hs.eg.db",
  level     = "gene"
)

anno_df <- as.data.frame(peakAnno)

## Attach peak IDs as a stable key
stopifnot(nrow(anno_df) == length(gr))
anno_df$peak_id <- names(gr)

## Minimal gene-centric annotation you'll reuse downstream
gene_anno_min <- anno_df[, c("peak_id", "SYMBOL", "geneId", "annotation", "distanceToTSS")]

```


# 4. PCA of ATAC peaks by genotype (pre-subtype)
## 4.1 Build ATAC metadata from SNP genotypes

```{r}
## 4.1 Build ATAC metadata from SNP genotypes -----------------------------

## Start from combined_batches (which already has ALT_pct and genotype)
meta <- combined_batches %>%
  dplyr::select(Sample, genotype, ALT_pct) %>%
  dplyr::mutate(
    Sample   = as.character(Sample),
    genotype = factor(genotype, levels = c("TT", "TC", "CC"))
  ) %>%
  dplyr::distinct(Sample, .keep_all = TRUE)

## Align metadata to counts columns
samples_in_counts <- intersect(colnames(counts), meta$Sample)
stopifnot(length(samples_in_counts) > 0)

meta_sub <- meta %>%
  dplyr::filter(Sample %in% samples_in_counts) %>%
  dplyr::arrange(match(Sample, colnames(counts)))

## Optional: report samples present in counts but missing in meta
missing_meta <- setdiff(colnames(counts), meta_sub$Sample)
if (length(missing_meta) > 0) {
  message("Samples in counts without metadata (will be dropped): ",
          paste(missing_meta, collapse = ", "))
}

## Subset counts to samples with metadata and enforce same order
counts_sub <- counts[, meta_sub$Sample, drop = FALSE]

```

## 4.2 PCA of all peaks by genotype

```{r}
## 4.2 PCA of all peaks by genotype --------------------------------------

## Filter peaks for PCA stability
keep <- rowSums(counts_sub >= MIN_READS_PCA) >= MIN_SAMPLES_PCA
counts_filt <- counts_sub[keep, , drop = FALSE]

## Restrict to top-N most variable peaks
if (nrow(counts_filt) > N_TOP_VAR_PCA) {
  v <- matrixStats::rowVars(as.matrix(counts_filt))
  o <- order(v, decreasing = TRUE)[seq_len(N_TOP_VAR_PCA)]
  counts_filt <- counts_filt[o, , drop = FALSE]
}
cat("Peaks retained for PCA (all peaks):", nrow(counts_filt), "\n")

## VST transform with DESeq2 (blind = TRUE for exploratory PCA)
dds <- DESeqDataSetFromMatrix(
  countData = counts_filt,
  colData   = as.data.frame(meta_sub),
  design    = ~ 1
)
dds <- estimateSizeFactors(dds)
vsd <- vst(dds, blind = TRUE)
mat <- assay(vsd)   # peaks x samples

## PCA on samples
pca <- prcomp(t(mat), center = TRUE, scale. = FALSE)
var_expl <- (pca$sdev^2) / sum(pca$sdev^2) * 100

pca_df <- data.frame(
  Sample   = meta_sub$Sample,
  genotype = meta_sub$genotype,
  ALT_pct  = meta_sub$ALT_pct,
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  PC3 = pca$x[, 3],
  stringsAsFactors = FALSE
)

ggplot(pca_df, aes(x = PC1, y = PC2, color = genotype)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = geno_cols, drop = FALSE) +
  labs(
    title = "PCA of VST-transformed ATAC peak counts (all peaks)",
    x     = paste0("PC1 (", round(var_expl[1], 1), "%)"),
    y     = paste0("PC2 (", round(var_expl[2], 1), "%)"),
    color = "Genotype"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title   = element_text(face = "bold"),
    legend.title = element_text(size = 12),
    legend.text  = element_text(size = 11)
  )
# + ggrepel::geom_text_repel(aes(label = Sample), max.overlaps = 50, size = 3)

## (Optional) export PCA scores
# write.table(pca_df, "PCA_scores_ATAC_all_peaks.tsv",
#             sep = "\t", quote = FALSE, row.names = FALSE)

```


## 4.3 PCA of promoter peaks only (pre-subtype)
```{r}
## 4.3 PCA of promoter peaks only (pre-subtype) --------------------------

## Select promoter peaks via ChIPseeker annotation
## ChIPseeker uses labels like "Promoter (<=1kb)"; strip the detail part
base_cat <- sub(" \\(.*\\)$", "", anno_df$annotation)
promoter_ids <- anno_df$peak_id[base_cat == "Promoter"]

## Intersect with available peaks in counts_sub
promoter_ids <- intersect(promoter_ids, rownames(counts_sub))
if (length(promoter_ids) == 0) {
  stop("No promoter peaks found after intersection with counts.")
}

counts_prom <- counts_sub[promoter_ids, , drop = FALSE]

## Filter promoter peaks for PCA stability
keep_prom <- rowSums(counts_prom >= MIN_READS_PCA) >= MIN_SAMPLES_PCA
counts_prom <- counts_prom[keep_prom, , drop = FALSE]
if (nrow(counts_prom) < 500) {
  message("Warning: <500 promoter peaks retained; consider relaxing filters.")
}

## Restrict to top-N most variable promoter peaks
if (nrow(counts_prom) > N_TOP_VAR_PCA) {
  v_prom <- matrixStats::rowVars(as.matrix(counts_prom))
  o_prom <- order(v_prom, decreasing = TRUE)[seq_len(N_TOP_VAR_PCA)]
  counts_prom <- counts_prom[o_prom, , drop = FALSE]
}
cat("Promoter peaks retained for PCA:", nrow(counts_prom), "\n")

## VST transform and PCA
dds_prom <- DESeqDataSetFromMatrix(
  countData = counts_prom,
  colData   = as.data.frame(meta_sub),
  design    = ~ 1
)
dds_prom <- estimateSizeFactors(dds_prom)
vsd_prom <- vst(dds_prom, blind = TRUE)
mat_prom <- assay(vsd_prom)

pca_prom <- prcomp(t(mat_prom), center = TRUE, scale. = FALSE)
var_expl_prom <- (pca_prom$sdev^2) / sum(pca_prom$sdev^2) * 100

pca_prom_df <- data.frame(
  Sample   = meta_sub$Sample,
  genotype = meta_sub$genotype,
  ALT_pct  = meta_sub$ALT_pct,
  PC1 = pca_prom$x[, 1],
  PC2 = pca_prom$x[, 2],
  stringsAsFactors = FALSE
)

ggplot(pca_prom_df, aes(x = PC1, y = PC2, color = genotype)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = geno_cols, drop = FALSE) +
  labs(
    title = "PCA of VST-transformed ATAC counts (promoter peaks only)",
    x     = paste0("PC1 (", round(var_expl_prom[1], 1), "%)"),
    y     = paste0("PC2 (", round(var_expl_prom[2], 1), "%)"),
    color = "Genotype"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title   = element_text(face = "bold"),
    legend.title = element_text(size = 12),
    legend.text  = element_text(size = 11)
  )

## (Optional) export promoter PCA scores
# write.table(pca_prom_df, "PCA_scores_ATAC_promoters.tsv",
#             sep = "\t", quote = FALSE, row.names = FALSE)

```



# 5. Integration of St. Jude molecular subtypes into PCA
## 5.1 Load subtype table and merge with ATAC metadata
```{r}
## 5.1 Load St. Jude subtype table and merge with ATAC meta --------------

suppressPackageStartupMessages(library(readxl))

## This assumes `meta` already exists from Section 4.1
## and contains columns: Sample, genotype, ALT_pct

sj_subtypes <- readxl::read_xlsx("mmc3 (2).xlsx")

## Harmonise sample IDs: ATAC_123_REP1 → ATAC_sample_123
meta_sj <- meta %>%
  dplyr::mutate(
    Sample_ID = gsub("ATAC_(\\d+)_REP1", "ATAC_sample_\\1", Sample)
  ) %>%
  dplyr::left_join(
    sj_subtypes %>% dplyr::select(Sample_ID, Subtype),
    by = "Sample_ID"
  )

## Optional: check how many samples got a subtype
table(is.na(meta_sj$Subtype))

```

## 5.2 Helper: PCA with genotype + subtype labels

```{r}
## 5.2 Helper to run PCA with genotype + subtype labels ------------------

run_atac_pca_with_subtype <- function(counts,
                                      meta_sj,
                                      peak_ids = NULL,
                                      title   = "PCA of VST-transformed ATAC counts") {
  stopifnot(is.matrix(counts))
  stopifnot(all(c("Sample", "genotype", "ALT_pct", "Subtype") %in% names(meta_sj)))

  ## 1) Align metadata to count matrix columns
  meta_sub <- meta_sj %>%
    dplyr::select(Sample, genotype, ALT_pct, Subtype) %>%
    dplyr::mutate(
      Sample   = as.character(Sample),
      genotype = factor(genotype, levels = c("TT", "TC", "CC"))
    ) %>%
    dplyr::distinct(Sample, .keep_all = TRUE)

  samples_in_counts <- intersect(colnames(counts), meta_sub$Sample)
  stopifnot(length(samples_in_counts) > 0)

  meta_sub <- meta_sub %>%
    dplyr::filter(Sample %in% samples_in_counts) %>%
    dplyr::arrange(match(Sample, colnames(counts)))

  counts_sub <- counts[, meta_sub$Sample, drop = FALSE]

  ## 2) Optional: restrict to given peak subset (e.g., promoters)
  if (!is.null(peak_ids)) {
    peak_ids <- intersect(peak_ids, rownames(counts_sub))
    if (length(peak_ids) == 0L) {
      stop("No peaks remain after intersecting `peak_ids` with count matrix rownames.")
    }
    counts_sub <- counts_sub[peak_ids, , drop = FALSE]
  }

  ## 3) Peak filtering for stable PCA
  keep <- rowSums(counts_sub >= MIN_READS_PCA) >= MIN_SAMPLES_PCA
  counts_filt <- counts_sub[keep, , drop = FALSE]

  if (nrow(counts_filt) == 0L) {
    stop("All peaks were filtered out; relax MIN_READS_PCA / MIN_SAMPLES_PCA.")
  }

  ## Restrict to top-N most variable peaks
  if (nrow(counts_filt) > N_TOP_VAR_PCA) {
    v <- matrixStats::rowVars(as.matrix(counts_filt))
    o <- order(v, decreasing = TRUE)[seq_len(N_TOP_VAR_PCA)]
    counts_filt <- counts_filt[o, , drop = FALSE]
  }

  cat("Peaks retained for PCA (",
      if (is.null(peak_ids)) "all" else "subset",
      "): ", nrow(counts_filt), "\n", sep = "")

  ## 4) VST and PCA
  dds <- DESeqDataSetFromMatrix(
    countData = counts_filt,
    colData   = as.data.frame(meta_sub),
    design    = ~ 1
  )
  dds <- estimateSizeFactors(dds)
  vsd <- vst(dds, blind = TRUE)
  mat <- assay(vsd)

  pca <- stats::prcomp(t(mat), center = TRUE, scale. = FALSE)
  var_expl <- (pca$sdev^2) / sum(pca$sdev^2) * 100

  pca_df <- data.frame(
    Sample   = meta_sub$Sample,
    genotype = meta_sub$genotype,
    ALT_pct  = meta_sub$ALT_pct,
    Subtype  = meta_sub$Subtype,
    PC1      = pca$x[, 1],
    PC2      = pca$x[, 2],
    stringsAsFactors = FALSE
  )

  p <- ggplot(pca_df, aes(PC1, PC2, color = genotype)) +
    geom_point(size = 3, alpha = 0.9) +
    ggrepel::geom_text_repel(
      aes(label = Subtype),
      size             = 4,
      max.overlaps     = Inf,
      min.segment.length = 0,
      box.padding      = 0.3,
      point.padding    = 0.2
    ) +
    scale_color_manual(values = geno_cols, drop = FALSE) +
    labs(
      title = title,
      x     = paste0("PC1 (", round(var_expl[1], 1), "%)"),
      y     = paste0("PC2 (", round(var_expl[2], 1), "%)"),
      color = "Genotype"
    ) +
    theme_bw(base_size = 14) +
    theme(
      plot.title   = element_text(face = "bold"),
      legend.title = element_text(size = 12),
      legend.text  = element_text(size = 11)
    )

  invisible(list(
    pca_df   = pca_df,
    var_expl = var_expl,
    plot     = p
  ))
}
```

## 5.3 PCA – all peaks with genotype + subtype labels
```{r}
## 5.3 PCA of all peaks with genotype + subtype --------------------------

res_pca_all_subtype <- run_atac_pca_with_subtype(
  counts  = counts,
  meta_sj = meta_sj,
  peak_ids = NULL,
  title   = "PCA of VST-transformed ATAC peak counts (ALL peaks, genotype + subtype)"
)

## To display the plot in an interactive session:
res_pca_all_subtype$plot

## Optional: export PCA scores
# write.table(res_pca_all_subtype$pca_df,
#             "PCA_scores_all_peaks_with_subtype.tsv",
#             sep = "\t", quote = FALSE, row.names = FALSE)

```

## 5.4 PCA – promoter peaks only with genotype + subtype labels

```{r}
## 5.4 PCA of promoter peaks only with genotype + subtype ----------------

## Select promoter peaks from ChIPseeker annotation
base_cat <- sub(" \\(.*\\)$", "", anno_df$annotation)   # strip "(<=1kb)" etc.
promoter_ids <- anno_df$peak_id[base_cat == "Promoter"]

if (length(promoter_ids) == 0L) {
  stop("No peaks are annotated as 'Promoter' in anno_df.")
}

res_pca_prom_subtype <- run_atac_pca_with_subtype(
  counts   = counts,
  meta_sj  = meta_sj,
  peak_ids = promoter_ids,
  title    = "PCA of VST-transformed ATAC counts (Promoter peaks only, genotype + subtype)"
)

## To display the plot:
# res_pca_prom_subtype$plot

## Optional: export promoter PCA scores
# write.table(res_pca_prom_subtype$pca_df,
#             "PCA_scores_promoters_with_subtype.tsv",
#             sep = "\t", quote = FALSE, row.names = FALSE)

```


# 6. Lineage module scores using Iacobucci panel (“Ilaria’s 700 genes”)
## 6.1 Load Iacobucci panel and reshape wide → long

* This chunk defines the lineage gene sets: for each B-cell stage, which genes belong to that “module”. Everything later (SJ/Spain modules, integration, etc.) is built on panel_long.

```{r}
## 6.1 Load Iacobucci panel and reshape wide → long ----------------------

suppressPackageStartupMessages({
  library(edgeR)
  library(pheatmap)
  library(stringr)
})

## Lineage order and colors (Iacobucci-like B-cell trajectory)
ct_levels <- c("HSCMPP", "GMP", "pDC", "EarlyLymphoid", "ProB", "PreB", "B")

cell_type_colors <- c(
  HSCMPP        = "#fb8072",
  GMP           = "#bebada",
  pDC           = "#ffd92f",
  EarlyLymphoid = "#f781bf",
  ProB          = "#ff33ff",
  PreB          = "#00e5c0",
  B             = "#00bfff"
)

margin_colors <- c(
  "Q1 (lowest)"  = "#c7e9c0",
  "Q2"           = "#a1d99b",
  "Q3"           = "#74c476",
  "Q4 (highest)" = "#238b45"
)

## Read pre-cleaned Iacobucci “700 genes” panel
panel_path <- "~/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/clean_ilarias_700_genes.csv"

panel_wide <- read.csv(panel_path, check.names = FALSE)

## Trim whitespace from all entries
panel_wide <- panel_wide %>%
  dplyr::mutate(dplyr::across(dplyr::everything(), ~ trimws(as.character(.)))) %>%
  { 
    ## If column names match ct_levels, reorder to that canonical order
    if (all(sort(names(.)) == sort(ct_levels))) {
      .[, ct_levels, drop = FALSE]
    } else {
      .
    }
  }

## Wide (columns = lineages) → long: (cell_type, gene)
panel_long <- panel_wide %>%
  tidyr::pivot_longer(
    cols      = dplyr::everything(),
    names_to  = "cell_type",
    values_to = "gene"
  ) %>%
  dplyr::filter(!is.na(gene), gene != "") %>%
  dplyr::mutate(cell_type = factor(cell_type, levels = ct_levels))

```


## 6.2 Align counts + annotation; helper to build module matrix



```{r}
## 6.2 Align counts rows to anno_df and define module helper --------------

## REQUIRE: `counts` (peaks x samples), `anno_df` with peak_id, SYMBOL, annotation
stopifnot(all(c("peak_id", "SYMBOL", "annotation") %in% names(anno_df)))

peaks_in_counts <- nrow(counts)
peaks_in_anno   <- length(unique(anno_df$peak_id))
common_peaks    <- intersect(rownames(counts), anno_df$peak_id)

cat("Peaks in counts: ",  peaks_in_counts, "\n",
    "Peaks in anno_df:", peaks_in_anno,   "\n",
    "Intersection:    ", length(common_peaks), "\n",
    "Dropped (counts - anno): ",
    peaks_in_counts - length(common_peaks), "\n", sep = "")

stopifnot(length(common_peaks) > 0L)

## Keep only peaks that have an annotation
counts_annot <- counts[common_peaks, , drop = FALSE]

## Helper to compute lineage module scores and heatmap --------------------
build_modules_from_atac <- function(count_mat,
                                    anno_tbl,
                                    panel_long,
                                    use_subset = c("all_gene_assigned", "promoter_only"),
                                    min_reads = 10,
                                    min_samples = 5,
                                    aggregator = c("max", "mean"),
                                    clip_z = 2) {
  use_subset <- match.arg(use_subset)
  aggregator <- match.arg(aggregator)

  ## 1) Restrict to annotated peaks (SYMBOL) and optionally to promoters
  anno_use <- anno_tbl %>%
    dplyr::filter(!is.na(SYMBOL), SYMBOL != "")

  if (use_subset == "promoter_only") {
    base_cat <- sub(" \\(.*\\)$", "", anno_use$annotation)
    anno_use <- anno_use[base_cat == "Promoter", , drop = FALSE]
  }

  peak_ids <- intersect(anno_use$peak_id, rownames(count_mat))
  if (length(peak_ids) == 0L) {
    stop("No peaks found for the chosen subset (", use_subset, ").")
  }

  ## 2) Basic peak filtering
  x <- count_mat[peak_ids, , drop = FALSE]
  keep <- rowSums(x >= min_reads) >= min_samples
  x <- x[keep, , drop = FALSE]
  if (nrow(x) == 0L) {
    stop("All peaks filtered out; relax min_reads / min_samples.")
  }

  ## 3) Library-size normalization → logCPM
  logcpm <- edgeR::cpm(x, log = TRUE, prior.count = 1)

  ## 4) Collapse peaks → genes using SYMBOL and chosen aggregator
  symb  <- anno_use$SYMBOL[match(rownames(logcpm), anno_use$peak_id)]
  logdf <- data.frame(SYMBOL = symb, as.data.frame(logcpm), check.names = FALSE)

  if (aggregator == "max") {
    gene_mat <- logdf %>%
      dplyr::group_by(SYMBOL) %>%
      dplyr::summarise(
        dplyr::across(where(is.numeric), ~ max(., na.rm = TRUE)),
        .groups = "drop"
      )
  } else {
    gene_mat <- logdf %>%
      dplyr::group_by(SYMBOL) %>%
      dplyr::summarise(
        dplyr::across(where(is.numeric), ~ mean(., na.rm = TRUE)),
        .groups = "drop"
      )
  }

  gene_mat <- as.data.frame(gene_mat)
  rownames(gene_mat) <- gene_mat$SYMBOL
  gene_mat$SYMBOL <- NULL
  gene_mat <- as.matrix(gene_mat)

  ## 5) Row z-score (genes) across samples; remove zero-variance; clip
  zero_var <- matrixStats::rowVars(gene_mat) == 0
  if (any(zero_var)) gene_mat <- gene_mat[!zero_var, , drop = FALSE]
  if (nrow(gene_mat) == 0L) {
    stop("No genes left after zero-variance filter.")
  }

  z_gene <- t(scale(t(gene_mat)))
  z_gene[is.na(z_gene)] <- 0
  if (!is.null(clip_z)) {
    z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
  }

  ## 6) Average z-score per lineage (panel gene sets)
  z_genes <- rownames(z_gene)
  avg_list <- lapply(levels(panel_long$cell_type), function(ct) {
    g_ct <- panel_long$gene[panel_long$cell_type == ct]
    g_ct <- intersect(unique(g_ct), z_genes)
    if (length(g_ct) == 0L) {
      rep(NA_real_, ncol(z_gene))
    } else {
      colMeans(z_gene[g_ct, , drop = FALSE])
    }
  })

  avg_z_by_ct <- do.call(rbind, avg_list)
  rownames(avg_z_by_ct) <- levels(panel_long$cell_type)
  colnames(avg_z_by_ct) <- colnames(z_gene)

  ## Drop lineages with no genes present
  all_na <- apply(avg_z_by_ct, 1, function(r) all(is.na(r)))
  if (any(all_na)) {
    message("Dropping lineages with no genes present in ATAC data: ",
            paste(rownames(avg_z_by_ct)[all_na], collapse = ", "))
    avg_z_by_ct <- avg_z_by_ct[!all_na, , drop = FALSE]
  }

  ## 7) Determine "winner" lineage per sample and ordering
  top_idx    <- apply(avg_z_by_ct, 2, which.max)
  second_idx <- apply(avg_z_by_ct, 2, function(v) order(v, decreasing = TRUE)[2])

  top_ct       <- rownames(avg_z_by_ct)[top_idx]
  second_ct    <- rownames(avg_z_by_ct)[second_idx]
  top_score    <- mapply(function(j, i)  avg_z_by_ct[i,  j], seq_along(top_idx),    top_idx)
  second_score <- mapply(function(j, i2) avg_z_by_ct[i2, j], seq_along(second_idx), second_idx)
  margin       <- top_score - second_score

  winner_order <- factor(
    top_ct,
    levels = c(
      intersect(ct_levels, rownames(avg_z_by_ct)),
      setdiff(rownames(avg_z_by_ct), ct_levels)
    )
  )

  col_order <- order(winner_order, -margin, -top_score)
  avg_z_by_ct_ord <- avg_z_by_ct[, col_order, drop = FALSE]

  ## 8) Margin quantiles for annotation
  margin_bins <- cut(
    margin[col_order],
    breaks = stats::quantile(margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
  )

  ann_col <- data.frame(
    top_ct = factor(top_ct[col_order], levels = rownames(avg_z_by_ct)),
    margin = margin_bins,
    row.names = colnames(avg_z_by_ct_ord)
  )

  r <- rle(as.character(ann_col$top_ct))
  gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL

  ## 9) Plot heatmap
  pheatmap::pheatmap(
    avg_z_by_ct_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    show_rownames  = TRUE,
    show_colnames  = FALSE,
    annotation_col = ann_col,
    annotation_colors = list(
      top_ct = cell_type_colors[names(cell_type_colors) %in% rownames(avg_z_by_ct_ord)],
      margin = margin_colors
    ),
    gaps_col    = gaps_col,
    gaps_row    = if (nrow(avg_z_by_ct_ord) > 1L) seq_len(nrow(avg_z_by_ct_ord) - 1L) else NULL,
    border_color = NA,
    main = paste0(
      "ATAC module scores — ",
      if (use_subset == "promoter_only") "Promoters only" else "All gene-assigned peaks",
      " (aggregator = ", aggregator, ")"
    )
  )

  invisible(list(
    avg_z_by_ct     = avg_z_by_ct,
    avg_z_by_ct_ord = avg_z_by_ct_ord,
    ann_col         = ann_col,
    z_gene          = z_gene
  ))
}

```

## 6.3 Run module analysis: ALL peaks vs PROMOTER-only

```{r}
## 6.3 Run module analysis: ALL peaks vs PROMOTER-only --------------------

mods_all <- build_modules_from_atac(
  count_mat  = counts_annot,
  anno_tbl   = anno_df,
  panel_long = panel_long,
  use_subset = "all_gene_assigned",
  min_reads  = 10,
  min_samples = 5,
  aggregator = "max",
  clip_z     = 2
)
avg_z_by_ct_ord_all <- mods_all$avg_z_by_ct_ord
ann_col_all         <- mods_all$ann_col

cat("\nHead of avg_z_by_ct_ord_all:\n")
print(utils::head(avg_z_by_ct_ord_all, 2))

mods_prom <- build_modules_from_atac(
  count_mat  = counts_annot,
  anno_tbl   = anno_df,
  panel_long = panel_long,
  use_subset = "promoter_only",
  min_reads  = 10,
  min_samples = 5,
  aggregator = "max",
  clip_z     = 2
)
avg_z_by_ct_ord_prom <- mods_prom$avg_z_by_ct_ord
ann_col_prom         <- mods_prom$ann_col

cat("\nHead of avg_z_by_ct_ord_prom:\n")
print(utils::head(avg_z_by_ct_ord_prom, 2))

## Optional: export module matrices
# write.table(avg_z_by_ct_ord_all,  "ATAC_avgZ_byCT_ALL_ord.tsv",
#             sep = "\t", quote = FALSE)
# write.table(avg_z_by_ct_ord_prom, "ATAC_avgZ_byCT_PROM_ord.tsv",
#             sep = "\t", quote = FALSE)

```

## 6.4 Replot module heatmaps adding genotype annotation

```{r}
## 6.4 Replot module heatmaps with genotype annotation -------------------

geno_cols <- c(TT = "#E4007C", TC = "#4F6D7A", CC = "#D3AF37")

plot_modules_with_genotype <- function(mat_ord, ann_col, title) {
  stopifnot(is.matrix(mat_ord), is.data.frame(ann_col))
  stopifnot(exists("meta_sj"))

  geno_tbl <- meta_sj %>%
    dplyr::select(Sample, genotype) %>%
    dplyr::mutate(genotype = factor(genotype, levels = c("TT", "TC", "CC"))) %>%
    dplyr::distinct(Sample, .keep_all = TRUE)

  ann2 <- ann_col[colnames(mat_ord), , drop = FALSE]
  ann2$genotype <- geno_tbl$genotype[match(rownames(ann2), geno_tbl$Sample)]

  if (any(is.na(ann2$genotype))) {
    msg <- paste(rownames(ann2)[is.na(ann2$genotype)], collapse = ", ")
    message("Samples missing genotype (annotation shown as NA): ", msg)
  }

  r <- rle(as.character(ann2$top_ct))
  gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL

  pheatmap::pheatmap(
    mat_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    show_rownames  = TRUE,
    show_colnames  = FALSE,
    annotation_col = ann2,
    annotation_colors = list(
      top_ct   = cell_type_colors[names(cell_type_colors) %in% rownames(mat_ord)],
      margin   = margin_colors,
      genotype = geno_cols
    ),
    gaps_col    = gaps_col,
    gaps_row    = if (nrow(mat_ord) > 1L) seq_len(nrow(mat_ord) - 1L) else NULL,
    border_color = NA,
    main = title
  )
}

## ALL gene-assigned peaks + genotype
plot_modules_with_genotype(
  mat_ord = avg_z_by_ct_ord_all,
  ann_col = ann_col_all,
  title   = "ATAC module scores — ALL peaks (with genotype)"
)

## PROMOTER-only peaks + genotype
plot_modules_with_genotype(
  mat_ord = avg_z_by_ct_ord_prom,
  ann_col = ann_col_prom,
  title   = "ATAC module scores — Promoters only (with genotype)"
)

```

## 6.5 Replot module heatmaps adding genotype + subtype annotations

```{r}
## 6.5 Replot module heatmaps with genotype + subtype --------------------

suppressPackageStartupMessages(library(RColorBrewer))

## Automatic subtype color palette
make_subtype_colors <- function(subtypes) {
  subs <- sort(unique(stats::na.omit(subtypes)))
  n    <- length(subs)
  base <- RColorBrewer::brewer.pal(12, "Set3")
  pal  <- if (n <= 12L) base[seq_len(n)] else grDevices::colorRampPalette(base)(n)
  stats::setNames(pal, subs)
}

plot_modules_with_genotype_subtype <- function(mat_ord, ann_col, title) {
  stopifnot(is.matrix(mat_ord), is.data.frame(ann_col))
  stopifnot(exists("meta_sj"))

  meta_min <- meta_sj %>%
    dplyr::select(Sample, genotype, Subtype) %>%
    dplyr::mutate(genotype = factor(genotype, levels = c("TT", "TC", "CC"))) %>%
    dplyr::distinct(Sample, .keep_all = TRUE)

  ann2 <- ann_col[colnames(mat_ord), , drop = FALSE]
  ann2$genotype <- meta_min$genotype[match(rownames(ann2), meta_min$Sample)]
  ann2$Subtype  <- meta_min$Subtype[match(rownames(ann2), meta_min$Sample)]

  if (any(is.na(ann2$genotype))) {
    message("Samples missing genotype: ",
            paste(rownames(ann2)[is.na(ann2$genotype)], collapse = ", "))
  }
  if (any(is.na(ann2$Subtype))) {
    message("Samples missing Subtype: ",
            paste(rownames(ann2)[is.na(ann2$Subtype)], collapse = ", "))
  }

  sub_cols <- make_subtype_colors(ann2$Subtype)

  r <- rle(as.character(ann2$top_ct))
  gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL

  pheatmap::pheatmap(
    mat_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    show_rownames  = TRUE,
    show_colnames  = FALSE,
    annotation_col = ann2,
    annotation_colors = list(
      top_ct   = cell_type_colors[names(cell_type_colors) %in% rownames(mat_ord)],
      margin   = margin_colors,
      genotype = geno_cols,
      Subtype  = sub_cols
    ),
    gaps_col    = gaps_col,
    gaps_row    = if (nrow(mat_ord) > 1L) seq_len(nrow(mat_ord) - 1L) else NULL,
    border_color = NA,
    main = title
  )
}

## ALL peaks: genotype + subtype
plot_modules_with_genotype_subtype(
  mat_ord = avg_z_by_ct_ord_all,
  ann_col = ann_col_all,
  title   = "ATAC module scores — ALL peaks (with genotype + subtype)"
)

## PROMOTER-only: genotype + subtype
plot_modules_with_genotype_subtype(
  mat_ord = avg_z_by_ct_ord_prom,
  ann_col = ann_col_prom,
  title   = "ATAC module scores — Promoters only (with genotype + subtype)"
)

```
# 7 Spain lineage modules

```{r}
# =====================================================================
# 7. Spain-specific lineage modules (PROMOTER vs ENHANCER markers)
#    Same ATAC "openness" scoring pipeline as Section 6,
#    but with Spain marker genes and explicit HSC → CLP → ProB → PreB → Immature-B ordering
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(readr)
})


spain_prom_path <- "~/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/spain_group/atacseq/100_M_reads/promoter_markers_by_celltype_marker_genes_wide.csv"
spain_enh_path  <- "~/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/spain_group/atacseq/100_M_reads/enhancer_markers_by_celltype_marker_genes_wide.csv"

## Canonical Spain lineage order for the heatmaps
ct_spain_order <- c("HSC", "CLP", "ProB", "PreB", "Immature-B")

load_spain_panel_long <- function(path, ct_order) {
    wide <- read.csv(path, check.names = FALSE)
    
    wide <- wide %>%
        mutate(across(everything(), ~ trimws(as.character(.))))
    
    ## If columns are exactly the cell types, reorder to canonical order
    if (all(sort(colnames(wide)) == sort(ct_order))) {
        wide <- wide[, ct_order, drop = FALSE]
    }
    
    wide %>%
        pivot_longer(
            cols      = everything(),
            names_to  = "cell_type",
            values_to = "gene"
        ) %>%
        filter(!is.na(gene), gene != "") %>%
        mutate(cell_type = factor(cell_type, levels = ct_order))
}

panel_spain_prom_long <- load_spain_panel_long(spain_prom_path, ct_spain_order)
panel_spain_enh_long  <- load_spain_panel_long(spain_enh_path,  ct_spain_order)


# =====================================================================
# New, plotting-free build_modules_from_atac()
# Works for BOTH Ilaria and Spain marker panels
# =====================================================================
build_modules_from_atac <- function(count_mat,
                                    anno_tbl,
                                    panel_long,
                                    use_subset  = c("all_gene_assigned", "promoter_only"),
                                    min_reads   = 10,
                                    min_samples = 5,
                                    aggregator = c("max", "sum", "mean"),
                                    clip_z      = 2) {
  stopifnot(is.matrix(count_mat),
            is.data.frame(anno_tbl),
            is.data.frame(panel_long))
  stopifnot("peak_id" %in% colnames(anno_tbl),
            "SYMBOL"  %in% colnames(anno_tbl),
            "annotation" %in% colnames(anno_tbl))

  use_subset <- match.arg(use_subset)
  aggregator <- match.arg(aggregator)

  # Align annotation to count_mat rows
  anno_sub <- anno_tbl[match(rownames(count_mat), anno_tbl$peak_id), ]
  stopifnot(identical(anno_sub$peak_id, rownames(count_mat)))

  # Strip " (1-2kb)" etc from annotation
  base_cat <- sub(" \\(.*\\)$", "", anno_sub$annotation)

  has_gene <- !is.na(anno_sub$SYMBOL) & anno_sub$SYMBOL != ""

  if (use_subset == "promoter_only") {
    keep_peaks <- (base_cat == "Promoter") & has_gene
  } else {
    # all_gene_assigned = any peak with a SYMBOL
    keep_peaks <- has_gene
  }

  count_sub <- count_mat[keep_peaks, , drop = FALSE]
  anno_sub  <- anno_sub[keep_peaks, , drop = FALSE]

  if (nrow(count_sub) == 0L) {
    stop("No peaks left after filtering for subset = ", use_subset,
         " and having a valid gene symbol.")
  }

  # Peak-level filtering by read support
  keep_peaks2 <- rowSums(count_sub >= min_reads) >= min_samples
  count_sub   <- count_sub[keep_peaks2, , drop = FALSE]
  anno_sub    <- anno_sub[keep_peaks2, , drop = FALSE]

  if (nrow(count_sub) == 0L) {
    stop("No peaks left after min_reads/min_samples filters.")
  }

  # ------------------------------------------------------------
  # Gene-level counts: aggregate peaks per gene
  # ------------------------------------------------------------
  gene2peak <- split(rownames(count_sub), anno_sub$SYMBOL)

  agg_fun <- switch(
    aggregator,
    max  = function(x) apply(x, 2, max),
    sum  = function(x) colSums(x),
    mean = function(x) colMeans(x)
  )

  gene_counts <- vapply(
    gene2peak,
    function(peaks) agg_fun(count_sub[peaks, , drop = FALSE]),
    FUN.VALUE = numeric(ncol(count_sub))
  )
  gene_counts <- t(gene_counts)
  colnames(gene_counts) <- colnames(count_sub)

  # Optional: gene-level filter for stability
  keep_genes <- rowSums(gene_counts >= min_reads) >= min_samples
  gene_counts <- gene_counts[keep_genes, , drop = FALSE]

  if (nrow(gene_counts) == 0L) {
    stop("No genes left after gene-level min_reads/min_samples filters.")
  }

  # ------------------------------------------------------------
  # logCPM + per-gene z-scores
  # ------------------------------------------------------------
  logcpm <- edgeR::cpm(gene_counts, log = TRUE, prior.count = 1)

  z_gene <- t(scale(t(logcpm)))
  z_gene[is.na(z_gene)] <- 0
  if (!is.null(clip_z)) {
    z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
  }

  # ------------------------------------------------------------
  # Average z-score per lineage (module matrix)
  # ------------------------------------------------------------
  ct_levels_local <- sort(unique(as.character(panel_long$cell_type)))

  avg_list <- lapply(ct_levels_local, function(ct) {
    g_ct <- panel_long$gene[panel_long$cell_type == ct]
    g_ct <- intersect(unique(as.character(g_ct)), rownames(z_gene))
    if (length(g_ct) == 0L) {
      rep(NA_real_, ncol(z_gene))
    } else {
      colMeans(z_gene[g_ct, , drop = FALSE])
    }
  })

  avg_z_by_ct <- do.call(rbind, avg_list)
  rownames(avg_z_by_ct) <- ct_levels_local
  colnames(avg_z_by_ct) <- colnames(z_gene)

  # Return ONLY data; all plotting happens in dedicated functions
  invisible(list(
    avg_z_by_ct = avg_z_by_ct,
    z_gene      = z_gene,
    gene_counts = gene_counts,
    panel_long  = panel_long,
    subset      = use_subset
  ))
}


## NOTE: uses build_modules_from_atac() defined above (no changes).

mods_spain_prom <- build_modules_from_atac(
    count_mat   = counts_annot,
    anno_tbl    = anno_df,
    panel_long  = panel_spain_prom_long,
    use_subset  = "promoter_only",       # like "Promoters only" in Ilaria section
    min_reads   = 10,
    min_samples = 5,
    aggregator  = "max",
    clip_z      = 2
)

mods_spain_enh <- build_modules_from_atac(
    count_mat   = counts_annot,
    anno_tbl    = anno_df,
    panel_long  = panel_spain_enh_long,
    use_subset  = "all_gene_assigned",   # enhancer markers can use all annotated peaks
    min_reads   = 10,
    min_samples = 5,
    aggregator  = "max",
    clip_z      = 2
)

cat("\nHead of raw Spain PROMOTER avg_z_by_ct:\n")
print(utils::head(mods_spain_prom$avg_z_by_ct, 2))
cat("\nHead of raw Spain ENHANCER avg_z_by_ct:\n")
print(utils::head(mods_spain_enh$avg_z_by_ct, 2))

##     HSC-max samples are leftmost, then CLP, then ProB, then PreB, then Immature-B
##     within each group, samples with the "reddest" (highest) module score appear first

prep_spain_modules <- function(mods_obj, ct_order) {
    mat0 <- mods_obj$avg_z_by_ct          # lineages x samples, unsorted
    
    ## Keep only Spain cell types and put them in canonical order (rows)
    ct_present <- intersect(ct_order, rownames(mat0))
    mat0 <- mat0[ct_present, , drop = FALSE]
    
    ## For each sample, identify top and second-best lineage and their scores
    top_idx     <- apply(mat0, 2, which.max)
    top_ct      <- rownames(mat0)[top_idx]
    top_score   <- mat0[cbind(top_idx, seq_along(top_idx))]
    
    second_idx  <- apply(mat0, 2, function(v) order(v, decreasing = TRUE)[2])
    second_score <- mat0[cbind(second_idx, seq_along(second_idx))]
    margin      <- top_score - second_score
    
    ## Ordering: first by top_ct (HSC → CLP → ProB → PreB → Immature-B),
    ## then by descending margin (how clearly that lineage "wins"),
    ## then by descending top_score (reddest first).
    winner_factor <- factor(top_ct, levels = ct_order)
    col_order <- order(winner_factor, -margin, -top_score)
    
    mat_ord <- mat0[, col_order, drop = FALSE]
    
    ## Quantile bins of margin, same labels as Section 6
    margin_bins <- cut(
        margin[col_order],
        breaks = stats::quantile(margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
        include.lowest = TRUE,
        labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
    )
    
    ann_col <- data.frame(
        top_ct = factor(top_ct[col_order], levels = ct_present),
        margin = margin_bins,
        row.names = colnames(mat_ord)
    )
    
    invisible(list(
        mat_ord  = mat_ord,
        ann_col  = ann_col
    ))
}

spain_prom_prepped <- prep_spain_modules(mods_spain_prom, ct_spain_order)
spain_enh_prepped  <- prep_spain_modules(mods_spain_enh,  ct_spain_order)

avg_z_spain_prom_ord   <- spain_prom_prepped$mat_ord
ann_col_spain_prom     <- spain_prom_prepped$ann_col

avg_z_spain_enh_ord    <- spain_enh_prepped$mat_ord
ann_col_spain_enh      <- spain_enh_prepped$ann_col

cat("\nHead of Spain PROMOTER modules (ordered):\n")
print(utils::head(avg_z_spain_prom_ord, 2))
cat("\nHead of Spain ENHANCER modules (ordered):\n")
print(utils::head(avg_z_spain_enh_ord, 2))

##    (same idea as plot_modules_with_genotype_subtype(), but with Spain
##     cell-type colors and our explicit HSC → CLP → ProB → PreB → Immature-B ordering)

plot_spain_modules <- function(mat_ord, ann_col, title) {
    stopifnot(is.matrix(mat_ord), is.data.frame(ann_col))
    stopifnot(exists("meta_sj"))
    
    # Minimal metadata
    meta_min <- meta_sj %>%
        dplyr::select(Sample, genotype, Subtype) %>%
        dplyr::mutate(genotype = factor(genotype, levels = c("TT", "TC", "CC"))) %>%
        dplyr::distinct(Sample, .keep_all = TRUE)
    
    ann2 <- ann_col[colnames(mat_ord), , drop = FALSE]
    ann2$genotype <- meta_min$genotype[match(rownames(ann2), meta_min$Sample)]
    ann2$Subtype  <- meta_min$Subtype[match(rownames(ann2), meta_min$Sample)]
    
    if (any(is.na(ann2$genotype))) {
        message("Samples missing genotype: ",
                paste(rownames(ann2)[is.na(ann2$genotype)], collapse = ", "))
    }
    if (any(is.na(ann2$Subtype))) {
        message("Samples missing Subtype: ",
                paste(rownames(ann2)[is.na(ann2$Subtype)], collapse = ", "))
    }
    
    ## Spain-specific top_ct colors (you can tweak these if you want)
    cell_type_colors_spain <- c(
        HSC         = "#fb8072",
        CLP         = "#bebada",
        ProB        = "#ff33ff",
        PreB        = "#00e5c0",
        `Immature-B` = "#00bfff"
    )
    
    sub_cols <- make_subtype_colors(ann2$Subtype)
    
    ## Column gaps between top_ct blocks (HSC, CLP, ProB, PreB, Immature-B)
    r <- rle(as.character(ann2$top_ct))
    gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL
    
    pheatmap::pheatmap(
        mat_ord,
        cluster_rows   = FALSE,
        cluster_cols   = FALSE,
        show_rownames  = TRUE,
        show_colnames  = FALSE,
        annotation_col = ann2,
        annotation_colors = list(
            top_ct   = cell_type_colors_spain[names(cell_type_colors_spain) %in% rownames(mat_ord)],
            margin   = margin_colors,
            genotype = geno_cols,
            Subtype  = sub_cols
        ),
        gaps_col    = gaps_col,
        gaps_row    = if (nrow(mat_ord) > 1L) seq_len(nrow(mat_ord) - 1L) else NULL,
        border_color = NA,
        main = title
    )
}

plot_spain_modules(
    mat_ord = avg_z_spain_prom_ord,
    ann_col = ann_col_spain_prom,
    title   = "ATAC module scores — Spain PROMOTER markers (Promoters only, ATAC openness)"
)

## 7.4.2 Spain ENHANCER markers: all gene-assigned peaks
plot_spain_modules(
    mat_ord = avg_z_spain_enh_ord,
    ann_col = ann_col_spain_enh,
    title   = "ATAC module scores — Spain ENHANCER markers (All gene-assigned peaks, ATAC openness)"
)


# write.table(avg_z_spain_prom_ord,
#             "ATAC_avgZ_Spain_PROM_markers_ord.tsv",
#             sep = "\t", quote = FALSE)
#
# write.table(avg_z_spain_enh_ord,
#             "ATAC_avgZ_Spain_ENH_markers_ord.tsv",
#             sep = "\t", quote = FALSE)

```


# 8. Diagnostics and QC of Ilaria vs Spain Modules


```{r}
# =============================================================
# Diagnostics: Ilaria vs Spain modules
# =============================================================

## 0. Basic SNP/genotype and metadata objects ------------------

cat("\n[0.1] combined_batches (SNP summary)\n")
print(dim(combined_batches))
print(head(combined_batches, 3))

cat("\n[0.2] ct_only (C/T-based state)\n")
print(dim(ct_only))
print(head(ct_only, 3))
cat("ct_state counts:\n")
print(table(ct_only$ct_state, useNA = "ifany"))

cat("\n[0.3] geno_qc_table (C/T vs ALT% genotype)\n")
print(geno_qc_table)

cat("\n[0.4] meta (ATAC metadata: Sample, genotype, ALT_pct)\n")
print(dim(meta))
print(head(meta, 5))
cat("Genotype distribution in meta:\n")
print(table(meta$genotype, useNA = "ifany"))

cat("\n[0.5] meta_sj (ATAC metadata + St Jude subtype)\n")
print(dim(meta_sj))
print(head(meta_sj, 5))
cat("Genotype distribution in meta_sj:\n")
print(table(meta_sj$genotype, useNA = "ifany"))
cat("Subtype distribution in meta_sj:\n")
print(table(meta_sj$Subtype, useNA = "ifany"))

## 1. ATAC counts and annotation --------------------------------

cat("\n[1.1] counts (raw consensus counts matrix)\n")
print(dim(counts))
cat("First 3 rows, first 5 samples:\n")
print(counts[1:3, 1:5])

cat("\n[1.2] anno_df (ChIPseeker annotation)\n")
print(dim(anno_df))
print(head(anno_df[, c("peak_id", "SYMBOL", "annotation", "distanceToTSS")], 5))

cat("\n[1.3] counts_annot (counts restricted to annotated peaks)\n")
print(dim(counts_annot))
cat("Row names example (1:5):\n")
print(rownames(counts_annot)[1:5])

## 2. Ilaria panel and modules ----------------------------------

cat("\n[2.1] panel_long (Ilaria 700 genes, long format)\n")
print(dim(panel_long))
cat("Cell type counts (Ilaria):\n")
print(table(panel_long$cell_type, useNA = "ifany"))
cat("Total unique genes in Ilaria panel:\n")
print(length(unique(panel_long$gene)))

cat("\n[2.2] Ilaria modules: mods_all$avg_z_by_ct\n")
print(dim(mods_all$avg_z_by_ct))
cat("Row (lineage) names:\n")
print(rownames(mods_all$avg_z_by_ct))
cat("Per-lineage value ranges:\n")
print(apply(mods_all$avg_z_by_ct, 1, range, na.rm = TRUE))

cat("\n[2.3] Ilaria modules: mods_prom$avg_z_by_ct (promoters only)\n")
print(dim(mods_prom$avg_z_by_ct))
cat("Row (lineage) names:\n")
print(rownames(mods_prom$avg_z_by_ct))
cat("Per-lineage value ranges:\n")
print(apply(mods_prom$avg_z_by_ct, 1, range, na.rm = TRUE))

cat("\n[2.4] Ordered Ilaria matrices\n")
cat("avg_z_by_ct_ord_all (all peaks) dim:\n")
print(dim(avg_z_by_ct_ord_all))
cat("avg_z_by_ct_ord_prom (promoter-only) dim:\n")
print(dim(avg_z_by_ct_ord_prom))

cat("\n[2.5] Ilaria top_ct distributions\n")
cat("ALL peaks top_ct:\n")
print(table(ann_col_all$top_ct, useNA = "ifany"))
cat("PROMOTER-only top_ct:\n")
print(table(ann_col_prom$top_ct, useNA = "ifany"))

## 3. Spain marker panels ---------------------------------------

cat("\n[3.1] panel_spain_prom_long (Spain PROMOTER markers, long)\n")
print(dim(panel_spain_prom_long))
cat("Cell type counts (Spain PROM):\n")
print(table(panel_spain_prom_long$cell_type, useNA = "ifany"))
cat("Unique PROMOTER marker genes:\n")
print(length(unique(panel_spain_prom_long$gene)))

cat("\n[3.2] panel_spain_enh_long (Spain ENHANCER markers, long)\n")
print(dim(panel_spain_enh_long))
cat("Cell type counts (Spain ENH):\n")
print(table(panel_spain_enh_long$cell_type, useNA = "ifany"))
cat("Unique ENHANCER marker genes:\n")
print(length(unique(panel_spain_enh_long$gene)))

## Overlap with ATAC genes (Ilaria vs Spain) --------------------

cat("\n[3.3] Overlap of gene sets with ATAC gene universe\n")
ilaria_genes      <- unique(panel_long$gene)
spain_prom_genes  <- unique(panel_spain_prom_long$gene)
spain_enh_genes   <- unique(panel_spain_enh_long$gene)

## Use Ilaria ALL z_gene as proxy for ATAC gene space
atac_genes_all <- rownames(mods_all$z_gene)

cat("Total ATAC genes (mods_all$z_gene):", length(atac_genes_all), "\n")
cat("Ilaria genes present in ATAC:", length(intersect(ilaria_genes, atac_genes_all)), "\n")
cat("Spain PROM genes present in ATAC:", length(intersect(spain_prom_genes, atac_genes_all)), "\n")
cat("Spain ENH genes present in ATAC:", length(intersect(spain_enh_genes, atac_genes_all)), "\n")

cat("Shared genes: Ilaria ∩ Spain PROM:", length(intersect(ilaria_genes, spain_prom_genes)), "\n")
cat("Shared genes: Ilaria ∩ Spain ENH:", length(intersect(ilaria_genes, spain_enh_genes)), "\n")
cat("Shared genes: Spain PROM ∩ Spain ENH:", length(intersect(spain_prom_genes, spain_enh_genes)), "\n")

## 4. Spain modules (PROMOTER vs ENHANCER) -----------------------

cat("\n[4.1] Spain PROMOTER modules: mods_spain_prom$avg_z_by_ct\n")
print(dim(mods_spain_prom$avg_z_by_ct))
cat("Row (lineage) names:\n")
print(rownames(mods_spain_prom$avg_z_by_ct))
cat("Per-lineage value ranges:\n")
print(apply(mods_spain_prom$avg_z_by_ct, 1, range, na.rm = TRUE))

cat("\n[4.2] Spain ENHANCER modules: mods_spain_enh$avg_z_by_ct\n")
print(dim(mods_spain_enh$avg_z_by_ct))
cat("Row (lineage) names:\n")
print(rownames(mods_spain_enh$avg_z_by_ct))
cat("Per-lineage value ranges:\n")
print(apply(mods_spain_enh$avg_z_by_ct, 1, range, na.rm = TRUE))

cat("\n[4.3] Ordered Spain matrices (after prep_spain_modules)\n")
cat("avg_z_spain_prom_ord dim:\n")
print(dim(avg_z_spain_prom_ord))
cat("avg_z_spain_enh_ord dim:\n")
print(dim(avg_z_spain_enh_ord))

cat("\n[4.4] Spain top_ct distributions\n")
cat("Spain PROM top_ct:\n")
print(table(ann_col_spain_prom$top_ct, useNA = "ifany"))
cat("Spain ENH top_ct:\n")
print(table(ann_col_spain_enh$top_ct, useNA = "ifany"))

## 5. Quick summary of value ranges across all module matrices -----------

cat("\n[5.1] Global ranges of module scores (all matrices)\n")
ranges_list <- list(
    Ilaria_ALL      = mods_all$avg_z_by_ct,
    Ilaria_PROM     = mods_prom$avg_z_by_ct,
    Spain_PROM      = mods_spain_prom$avg_z_by_ct,
    Spain_ENH       = mods_spain_enh$avg_z_by_ct
)

for (nm in names(ranges_list)) {
    mat <- ranges_list[[nm]]
    cat("\n", nm, ":\n", sep = "")
    cat("  dim =", paste(dim(mat), collapse = " x "), "\n")
    cat("  overall range =", paste(range(mat, na.rm = TRUE), collapse = " to "), "\n")
}

```

# 9. Saving Core State Objects (SJ156 + Spain)

## 9.1 Saving SJ156 state (only SJ156)

```{r}
# =====================================================================
# 9. Saving Core State Objects (SJ156 ONLY) — UPDATED
#   - Adds gene_counts_sj_prom / gene_counts_sj_enh
#   - Adds global_peak_df_sj (peak-level DF)
# =====================================================================
# 
# suppressPackageStartupMessages({
#     library(dplyr)
# })
# 
# # ---------------------------------------------------------------------
# # 0) Output directory
# # ---------------------------------------------------------------------
# combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"
# 
# if (!dir.exists(combined_dir)) {
#     dir.create(combined_dir, recursive = TRUE)
# }
# 
# # ---------------------------------------------------------------------
# # 1) Build peak-level SJ156 matrices (GLOBAL / PROMOTER / ENHANCER)
# # ---------------------------------------------------------------------
# stopifnot(exists("counts_annot"), exists("anno_df"))
# 
# peak_counts_sj <- counts_annot
# 
# ## Annotation aligned to peak order
# peak_anno <- anno_df %>%
#     dplyr::filter(peak_id %in% rownames(peak_counts_sj)) %>%
#     dplyr::arrange(match(peak_id, rownames(peak_counts_sj)))
# 
# stopifnot(identical(peak_anno$peak_id, rownames(peak_counts_sj)))
# 
# ## Promoter vs non-promoter categories
# base_cat <- sub(" \\(.*\\)$", "", peak_anno$annotation)
# 
# promoter_ids <- peak_anno$peak_id[base_cat == "Promoter"]
# enhancer_ids <- peak_anno$peak_id[base_cat != "Promoter"]
# 
# promoter_counts_sj <- peak_counts_sj[promoter_ids, , drop = FALSE]
# enhancer_counts_sj <- peak_counts_sj[enhancer_ids, , drop = FALSE]
# 
# cat("[SJ156] Peak-level matrices built:\n")
# cat("  • peak_counts_sj     :", paste(dim(peak_counts_sj),    collapse = " × "), "\n")
# cat("  • promoter_counts_sj :", paste(dim(promoter_counts_sj), collapse = " × "), "\n")
# cat("  • enhancer_counts_sj :", paste(dim(enhancer_counts_sj), collapse = " × "), "\n")
# 
# # ---------------------------------------------------------------------
# # 2) Build gene-level SJ156 matrices:
# #    - gene_counts_sj      (ALL peaks per gene)
# #    - gene_counts_sj_prom (PROMOTER-only peaks per gene)
# #    - gene_counts_sj_enh  (ENHANCER-only peaks per gene)
# # ---------------------------------------------------------------------
# stopifnot(exists("gene_anno_min"))
# 
# ## Gene ↔ peak mapping using all annotated peaks
# gene2peak_sj <- gene_anno_min %>%
#     dplyr::filter(!is.na(SYMBOL), SYMBOL != "") %>%
#     dplyr::distinct(SYMBOL, peak_id) %>%
#     dplyr::filter(peak_id %in% rownames(peak_counts_sj))
# 
# peaks_by_gene_sj <- split(gene2peak_sj$peak_id, gene2peak_sj$SYMBOL)
# 
# ## Helper: collapse peaks → gene-level counts by summing across peaks
# build_gene_counts <- function(peaks_by_gene, counts_mat, label) {
#     if (length(peaks_by_gene) == 0L) {
#         stop("[SJ156] ", label, ": no genes with assigned peaks.")
#     }
#     mat <- purrr::map_dfc(
#         peaks_by_gene,
#         ~ colSums(counts_mat[.x, , drop = FALSE])
#     )
#     mat <- t(as.matrix(mat))
#     rownames(mat) <- names(peaks_by_gene)
#     cat("[SJ156] ", label, " built. dim = ",
#         paste(dim(mat), collapse = " × "), "\n", sep = "")
#     mat
# }
# 
# ## (2.1) ALL peaks per gene
# gene_counts_sj <- build_gene_counts(
#     peaks_by_gene = peaks_by_gene_sj,
#     counts_mat    = peak_counts_sj,
#     label         = "gene_counts_sj (ALL peaks)"
# )
# 
# ## (2.2) PROMOTER-only peaks per gene
# promoter_peaks <- rownames(promoter_counts_sj)
# peaks_by_gene_prom <- lapply(peaks_by_gene_sj, function(pk) intersect(pk, promoter_peaks))
# peaks_by_gene_prom <- peaks_by_gene_prom[lengths(peaks_by_gene_prom) > 0]
# 
# gene_counts_sj_prom <- build_gene_counts(
#     peaks_by_gene = peaks_by_gene_prom,
#     counts_mat    = peak_counts_sj,  # counts_annot is equivalent here
#     label         = "gene_counts_sj_prom (PROMOTER-only)"
# )
# 
# ## (2.3) ENHANCER-only peaks per gene
# enhancer_peaks <- rownames(enhancer_counts_sj)
# peaks_by_gene_enh <- lapply(peaks_by_gene_sj, function(pk) intersect(pk, enhancer_peaks))
# peaks_by_gene_enh <- peaks_by_gene_enh[lengths(peaks_by_gene_enh) > 0]
# 
# gene_counts_sj_enh <- build_gene_counts(
#     peaks_by_gene = peaks_by_gene_enh,
#     counts_mat    = peak_counts_sj,
#     label         = "gene_counts_sj_enh (ENHANCER-only)"
# )
# 
# # ---------------------------------------------------------------------
# # 3) Global peak-level DF for SJ156
# # ---------------------------------------------------------------------
# global_peak_df_sj <- peak_anno
# cat("[SJ156] global_peak_df_sj dim: ",
#     paste(dim(global_peak_df_sj), collapse = " × "), "\n")
# 
# # ---------------------------------------------------------------------
# # 4) Bundle ALL SJ156 objects into RDS-safe state list
# # ---------------------------------------------------------------------
# sj156_state <- list(
# 
#     # ---- GENOTYPE / SNP ----
#     combined_batches = combined_batches,
#     ct_only          = ct_only,
#     geno_qc_table    = geno_qc_table,
#     meta             = meta,
#     meta_sj          = meta_sj,
#     allele_cols      = allele_cols,
#     geno_cols        = geno_cols,
# 
#     # ---- ATAC PEAK LEVEL ----
#     counts        = counts,
#     counts_annot  = counts_annot,
#     anno          = anno,
#     anno_df       = anno_df,
#     gr            = gr,
#     gene_anno_min = gene_anno_min,
# 
#     peak_counts_sj     = peak_counts_sj,
#     promoter_counts_sj = promoter_counts_sj,
#     enhancer_counts_sj = enhancer_counts_sj,
#     peak_anno          = peak_anno,
#     global_peak_df_sj  = global_peak_df_sj,
# 
#     # ---- PCA / PARAMETERS ----
#     MIN_READS_PCA   = MIN_READS_PCA,
#     MIN_SAMPLES_PCA = MIN_SAMPLES_PCA,
#     N_TOP_VAR_PCA   = N_TOP_VAR_PCA,
# 
#     # ---- ILARIA PANEL ----
#     panel_long       = panel_long,
#     ct_levels        = ct_levels,
#     cell_type_colors = cell_type_colors,
#     margin_colors    = margin_colors,
# 
#     mods_all             = mods_all,
#     mods_prom            = mods_prom,
#     avg_z_by_ct_ord_all  = avg_z_by_ct_ord_all,
#     ann_col_all          = ann_col_all,
#     avg_z_by_ct_ord_prom = avg_z_by_ct_ord_prom,
#     ann_col_prom         = ann_col_prom,
# 
#     # ---- GENE LEVEL ----
#     gene_counts_sj      = gene_counts_sj,       # ALL peaks per gene
#     gene_counts_sj_prom = gene_counts_sj_prom,  # PROMOTER-only per gene
#     gene_counts_sj_enh  = gene_counts_sj_enh    # ENHANCER-only per gene
# )
# 
# # ---------------------------------------------------------------------
# # 5) SAVE
# # ---------------------------------------------------------------------
# saveRDS(
#     sj156_state,
#     file = file.path(combined_dir, "sj156_atac_core_state.rds")
# )
# 
# cat("\n[SAVED] sj156_atac_core_state.rds stored at:\n",
#     file.path(combined_dir, "sj156_atac_core_state.rds"), "\n\n")

```

# 10. Integrating SJ156 and Spain (Ilaria modules)
## 10.1 Minimal annotation heatmap SJ156 + Spain

```{r}
# ================================================================
# 10. Integrating SJ156 and Spain (Ilaria modules)
# 10.1 Minimal annotation heatmap (cohort + margin + top_ct)
# ================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(edgeR)
    library(pheatmap)
    library(RColorBrewer)
})

# ---------------------------------------------------------------
# 1) Load core states
# ---------------------------------------------------------------
combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"

sj156_state  <- readRDS(file.path(combined_dir, "sj156_atac_core_state.rds"))
spain_state  <- readRDS(file.path(combined_dir, "spain_atac_core_state.rds"))

# Extract Ilaria module definitions
panel_long       <- sj156_state$panel_long
ct_levels        <- sj156_state$ct_levels
cell_type_colors <- sj156_state$cell_type_colors
margin_colors    <- sj156_state$margin_colors

avg_z_sj_all <- sj156_state$mods_all$avg_z_by_ct  # lineages × samples
panel_long$cell_type <- factor(panel_long$cell_type, levels = ct_levels)

# ---------------------------------------------------------------
# 2) Helper: compute modules from gene-level counts
# ---------------------------------------------------------------
build_modules_from_gene_counts <- function(gene_counts,
                                           panel_long,
                                           ct_levels,
                                           min_counts  = 10,
                                           min_samples = 5,
                                           clip_z      = 2) {
    
    keep <- rowSums(gene_counts >= min_counts) >= min_samples
    gene_counts_filt <- gene_counts[keep, , drop = FALSE]
    
    logcpm <- edgeR::cpm(gene_counts_filt, log = TRUE, prior.count = 1)
    
    z_gene <- t(scale(t(logcpm)))
    z_gene[is.na(z_gene)] <- 0
    if (!is.null(clip_z)) {
        z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
    }
    
    avg_list <- lapply(ct_levels, function(ct) {
        g_ct <- panel_long$gene[panel_long$cell_type == ct]
        g_ct <- intersect(unique(g_ct), rownames(z_gene))
        if (length(g_ct) == 0L) rep(NA_real_, ncol(z_gene))
        else colMeans(z_gene[g_ct, , drop = FALSE])
    })
    
    avg_z_by_ct <- do.call(rbind, avg_list)
    rownames(avg_z_by_ct) <- ct_levels
    colnames(avg_z_by_ct) <- colnames(z_gene)
    
    list(avg_z_by_ct = avg_z_by_ct, z_gene = z_gene)
}

# ---------------------------------------------------------------
# 3) Spain — gene-level modules
# ---------------------------------------------------------------
gene_counts_spain <- spain_state$gene_counts_spain_prom  # solo promotores
meta_spain        <- spain_state$meta_spain_coding %>%
    transmute(
        Sample    = as.character(Sample),
        genotype  = factor(genotype, levels = c("TT", "TC", "CC")),
        cell_type = as.character(cell_type)
    )

# Align samples
samples_spain <- intersect(colnames(gene_counts_spain), meta_spain$Sample)
gene_counts_spain <- gene_counts_spain[, samples_spain, drop = FALSE]
meta_spain        <- meta_spain %>% filter(Sample %in% samples_spain)
gene_counts_spain <- gene_counts_spain[, meta_spain$Sample, drop = FALSE]

mods_spain      <- build_modules_from_gene_counts(
    gene_counts = gene_counts_spain,
    panel_long  = panel_long,
    ct_levels   = ct_levels,
    min_counts  = 10,
    min_samples = 3,
    clip_z      = 2
)
avg_z_spain_all <- mods_spain$avg_z_by_ct

# ---------------------------------------------------------------
# 4) Combine SJ156 + Spain
# ---------------------------------------------------------------
common_ct <- intersect(ct_levels, rownames(avg_z_sj_all))

avg_z_sj_all    <- avg_z_sj_all[common_ct, , drop = FALSE]
avg_z_spain_all <- avg_z_spain_all[common_ct, , drop = FALSE]

mat_combined <- cbind(avg_z_sj_all, avg_z_spain_all)

# ---------------------------------------------------------------
# 5) Build annotation: cohort + top_ct + margin score
# ---------------------------------------------------------------
samples_sj    <- colnames(avg_z_sj_all)
samples_spain <- colnames(avg_z_spain_all)

ann_all <- data.frame(
    Sample = c(samples_sj, samples_spain),
    cohort = c(rep("SJ156", length(samples_sj)),
               rep("Spain", length(samples_spain))),
    stringsAsFactors = FALSE
)
rownames(ann_all) <- ann_all$Sample
ann_all <- ann_all[colnames(mat_combined), , drop = FALSE]

# ---- Compute top lineage and numerical margin ----
top_idx <- apply(mat_combined, 2, which.max)
top_ct  <- rownames(mat_combined)[top_idx]

second_idx <- apply(mat_combined, 2, function(v) order(v, decreasing = TRUE)[2])

margin_numeric <- mat_combined[cbind(top_idx, seq_along(top_idx))] -
    mat_combined[cbind(second_idx, seq_along(second_idx))]

ann_all$top_ct <- factor(top_ct, levels = common_ct)

# ---- Use labels EXACTLY matching names(margin_colors) ----
ann_all$margin <- cut(
    margin_numeric,
    breaks = quantile(margin_numeric, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = names(margin_colors)   # <── SOLUCIÓN CLAVE
)

# ---------------------------------------------------------------
# 6) Column ordering (winner lineage, then by margin)
# ---------------------------------------------------------------
winner_factor <- factor(top_ct, levels = common_ct)
col_order <- order(winner_factor, -margin_numeric)

mat_ord  <- mat_combined[, col_order, drop = FALSE]
ann_all  <- ann_all[colnames(mat_ord), , drop = FALSE]

# ---------------------------------------------------------------
# 7) Colors: only cohort + margin + top_ct
# ---------------------------------------------------------------
annotation_colors <- list(
    cohort = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
    margin = margin_colors,
    top_ct = cell_type_colors[names(cell_type_colors) %in% common_ct]
)

gaps_row <- if (length(common_ct) > 1) seq_len(length(common_ct) - 1)

# ---------------------------------------------------------------
# 8) Clean Heatmap
# ---------------------------------------------------------------
pheatmap(
    mat_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    annotation_col = ann_all,
    annotation_colors = annotation_colors,
    gaps_row       = gaps_row,
    show_colnames  = FALSE,
    show_rownames  = TRUE,
    border_color   = NA,
    main = "SJ156 + Spain — Ilaria lineage module heatmap (clean)"
)




```
## 10.2 Integration Heatmap (SJ→Spain ordering inside each lineage)

```{r}
# 8) Integration of SJ156 and Spain Ilaria modules
# ================================================================
# Assumes sj156_state and spain_state are already in the environment
# from previous chunks (no readRDS here).

suppressPackageStartupMessages({
  library(dplyr)
  library(edgeR)
  library(pheatmap)
  library(RColorBrewer)
})

# ------------------------------------------------
# 1) Extract core objects from existing state
# ------------------------------------------------
panel_long       <- sj156_state$panel_long
ct_levels        <- sj156_state$ct_levels
cell_type_colors <- sj156_state$cell_type_colors

# SJ156 lineage modules (already computed upstream)
avg_z_sj_all <- sj156_state$mods_all$avg_z_by_ct   # lineages × SJ156 samples

panel_long$cell_type <- factor(panel_long$cell_type, levels = ct_levels)

# ------------------------------------------------
# 2) Build modules-from-genes for Spain (reuse function if defined)
# ------------------------------------------------
if (!exists("build_modules_from_gene_counts")) {
  build_modules_from_gene_counts <- function(gene_counts,
                                             panel_long,
                                             ct_levels,
                                             min_counts   = 10,
                                             min_samples  = 5,
                                             clip_z       = 2) {

    keep <- rowSums(gene_counts >= min_counts) >= min_samples
    gene_counts_filt <- gene_counts[keep, , drop = FALSE]

    logcpm <- edgeR::cpm(gene_counts_filt, log = TRUE, prior.count = 1)

    z_gene <- t(scale(t(logcpm)))
    z_gene[is.na(z_gene)] <- 0
    if (!is.null(clip_z)) {
      z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
    }

    avg_list <- lapply(ct_levels, function(ct) {
      g_ct <- panel_long$gene[panel_long$cell_type == ct]
      g_ct <- intersect(unique(g_ct), rownames(z_gene))
      if (length(g_ct) == 0L) {
        rep(NA_real_, ncol(z_gene))
      } else {
        colMeans(z_gene[g_ct, , drop = FALSE])
      }
    })

    avg_z_by_ct <- do.call(rbind, avg_list)
    rownames(avg_z_by_ct) <- ct_levels
    colnames(avg_z_by_ct) <- colnames(z_gene)

    list(avg_z_by_ct = avg_z_by_ct, z_gene = z_gene)
  }
}

# Spain gene-level counts and metadata from spain_state
gene_counts_spain <- spain_state$gene_counts_spain
meta_spain_coding <- spain_state$meta_spain_coding

spain_meta <- meta_spain_coding %>%
  transmute(
    Sample    = as.character(Sample),
    genotype  = factor(genotype, levels = c("TT", "TC", "CC")),
    cell_type = as.character(cell_type)
  )

samples_spain <- intersect(colnames(gene_counts_spain), spain_meta$Sample)
gene_counts_spain <- gene_counts_spain[, samples_spain, drop = FALSE]
spain_meta <- spain_meta %>% filter(Sample %in% samples_spain)

gene_counts_spain <- gene_counts_spain[, spain_meta$Sample, drop = FALSE]

mods_spain <- build_modules_from_gene_counts(
  gene_counts = gene_counts_spain,
  panel_long  = panel_long,
  ct_levels   = ct_levels,
  min_counts  = 10,
  min_samples = 3,
  clip_z      = 2
)

avg_z_spain_all <- mods_spain$avg_z_by_ct   # lineages × Spain samples

# ------------------------------------------------
# 3) Harmonize lineages and combine cohorts
# ------------------------------------------------
common_ct <- intersect(ct_levels,
                       intersect(rownames(avg_z_sj_all), rownames(avg_z_spain_all)))

avg_z_sj_all    <- avg_z_sj_all[common_ct, , drop = FALSE]
avg_z_spain_all <- avg_z_spain_all[common_ct, , drop = FALSE]

mat_combined <- cbind(avg_z_sj_all, avg_z_spain_all)

# ------------------------------------------------
# 4) Annotation: ONLY cohort + top_ct
# ------------------------------------------------
samples_sj    <- colnames(avg_z_sj_all)
samples_spain <- colnames(avg_z_spain_all)

ann_all <- data.frame(
  cohort = c(rep("SJ156", length(samples_sj)),
             rep("Spain", length(samples_spain))),
  stringsAsFactors = FALSE
)
rownames(ann_all) <- c(samples_sj, samples_spain)
ann_all <- ann_all[colnames(mat_combined), , drop = FALSE]

ann_all$cohort <- factor(ann_all$cohort, levels = c("SJ156", "Spain"))

# Top Ilaria lineage per sample
top_idx <- apply(mat_combined, 2, which.max)
top_ct  <- rownames(mat_combined)[top_idx]
ann_all$top_ct <- factor(top_ct, levels = common_ct)

# ------------------------------------------------
# 5) Custom column ordering:
#    within each lineage: SJ156 samples first, then Spain samples
# ------------------------------------------------
col_order <- character(0)
for (ct in common_ct) {
  cols_ct_sj <- rownames(ann_all)[ann_all$top_ct == ct & ann_all$cohort == "SJ156"]
  cols_ct_spain <- rownames(ann_all)[ann_all$top_ct == ct & ann_all$cohort == "Spain"]
  col_order <- c(col_order, cols_ct_sj, cols_ct_spain)
}
# keep only columns that actually exist
col_order <- col_order[col_order %in% colnames(mat_combined)]

mat_ord <- mat_combined[, col_order, drop = FALSE]
ann_all <- ann_all[col_order, , drop = FALSE]

# Column gaps between lineage blocks (for vertical separators)
r <- rle(as.character(ann_all$top_ct))
gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL

# Row gaps between Ilaria lineages
gaps_row <- if (length(common_ct) > 1L) seq_len(length(common_ct) - 1L) else NULL

# ------------------------------------------------
# 6) Annotation colors — ONLY cohort + top_ct
# ------------------------------------------------
annotation_colors <- list(
  cohort = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
  top_ct = cell_type_colors[names(cell_type_colors) %in% common_ct]
)

# ------------------------------------------------
# 7) Plot clean heatmap
# ------------------------------------------------
pheatmap(
  mat_ord,
  cluster_rows   = FALSE,
  cluster_cols   = FALSE,
  annotation_col = ann_all,
  annotation_colors = annotation_colors,
  gaps_row       = gaps_row,
  gaps_col       = gaps_col,
  show_colnames  = FALSE,
  show_rownames  = TRUE,
  border_color   = NA,
  main = "SJ156 + Spain — Ilaria lineage module heatmap (SJ→Spain within each lineage)"
)


```


# 11. Task 1 — Using Ilaria’s markers + Spain TRUE cell types
### 11.1 Add Spain TRUE cell-type annotation

```{r}
# ------------------------------------------------------------------
# 5c) Add Spain TRUE cell-type annotation (from Spain metadata)
# ------------------------------------------------------------------
ann_all$spain_cell_type <- NA_character_

# We expect metadata in spain_state$meta_spain with cols: Sample, cell_type
meta_spain <- NULL
if (!is.null(spain_state$meta_spain)) {
    meta_spain <- spain_state$meta_spain
}

if (!is.null(meta_spain)) {
    if (!all(c("Sample", "cell_type") %in% colnames(meta_spain))) {
        warning("Spain metadata found but lacks 'Sample' and/or 'cell_type' columns; spain_cell_type will remain NA.")
    } else {
        meta_spain <- meta_spain %>%
            mutate(Sample = as.character(Sample)) %>%
            dplyr::select(Sample, cell_type)
        
        idx_spain <- ann_all$cohort == "Spain"
        
        ann_all$spain_cell_type[idx_spain] <- meta_spain$cell_type[
            match(rownames(ann_all)[idx_spain], meta_spain$Sample)
        ]
        
        # Ensure factor levels are exactly the distinct Spain cell types
        spain_ct_levels <- sort(unique(na.omit(as.character(ann_all$spain_cell_type))))
        ann_all$spain_cell_type <- factor(ann_all$spain_cell_type,
                                          levels = spain_ct_levels)
        
        cat("[5c] Spain cell-type annotation added for ",
            sum(idx_spain & !is.na(ann_all$spain_cell_type)),
            " Spain samples.\n", sep = "")
        cat("     Table of spain_cell_type by cohort:\n")
        print(table(ann_all$spain_cell_type, ann_all$cohort, useNA = "ifany"))
    }
} else {
    warning("No Spain sample metadata (meta_spain) found in spain_state; spain_cell_type annotation will be NA.")
}

# ------------------------------------------------------------------
# 6) Heatmap: build annotation_colors with proper Spain colors
# ------------------------------------------------------------------
annotation_colors <- list(
    cohort = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
    # Ilaria lineage colors (SJ156 panel)
    top_ct = cell_type_colors[names(cell_type_colors) %in% common_ct]
)

# Add colors for Spain true cell-type (use spain_state$cell_type_colors if available)
if ("spain_cell_type" %in% colnames(ann_all)) {
    spain_ct_levels <- levels(ann_all$spain_cell_type)
    
    if (length(spain_ct_levels) > 0L) {
        
        spain_colors <- NULL
        if (!is.null(spain_state$cell_type_colors)) {
            spain_colors <- spain_state$cell_type_colors
        }
        
        if (!is.null(spain_colors)) {
            # If some Spain levels are missing in the color vector, create new colors
            missing_spain <- setdiff(spain_ct_levels, names(spain_colors))
            if (length(missing_spain) > 0L) {
                warning("Spain cell types missing from spain_state$cell_type_colors: ",
                        paste(missing_spain, collapse = ", "),
                        "\nAssigning new colors for these.")
                extra_cols <- setNames(
                    grDevices::hcl.colors(length(missing_spain), "Set2"),
                    missing_spain
                )
                spain_colors <- c(spain_colors, extra_cols)
            }
            
            # Final color vector must have one color per factor level
            annotation_colors$spain_cell_type <- spain_colors[spain_ct_levels]
        } else {
            # Fallback: create a palette from scratch
            annotation_colors$spain_cell_type <- setNames(
                grDevices::hcl.colors(length(spain_ct_levels), "Set2"),
                spain_ct_levels
            )
        }
    }
}

pheatmap::pheatmap(
    mat_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    annotation_col = ann_all,
    annotation_colors = annotation_colors,
    gaps_row       = gaps_row,
    gaps_col       = gaps_col,
    show_colnames  = FALSE,
    show_rownames  = TRUE,
    border_color   = NA,
    main = "Ilaria lineage modules — SJ156 + Spain (gene-level)"
)

```

### 11.2 Rank samples within each lineage (Spain + SJ156)
#### Within each Ilaria lineage block (HSCMPP, GMP, pDC, EarlyLymphoid, ProB, PreB, B), take only the samples whose top_ct is that lineage and then rank those columns from highest to lowest based on that lineage’s module score (the row value for that lineage), so that, for example, the ProB block shows samples ordered from “most ProB-like” to “least ProB-like,” regardless of cohort, while still keeping the same row structure and Spain TRUE cell-type annotation.

```{r}
# ================================================================
# 11.2 – Ilaria PROMOTER modules for SJ156 + Spain (margin Q4→Q1)
#       All samples, one heatmap, using Ilaria markers (PROM-only)
#       NOTE: chunk-specific objects: mat_ord_11_2, ann_all_11_2, ...
# ================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(edgeR)
    library(pheatmap)
})

# ------------------------------------------------
# 1) Load SJ156 + Spain state objects
# ------------------------------------------------
combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"

if (!exists("sj156_state") || !exists("spain_state")) {
    cat("[1] Loading sj156_state and spain_state from:\n   ", combined_dir, "\n")
    sj156_state <- readRDS(file.path(combined_dir, "sj156_atac_core_state.rds"))
    spain_state <- readRDS(file.path(combined_dir, "spain_atac_core_state.rds"))
} else {
    cat("[1] Using sj156_state and spain_state already in memory.\n")
}

# ------------------------------------------------
# 2) Ilaria definitions + PROM modules for SJ156
# ------------------------------------------------
panel_long_11_2       <- sj156_state$panel_long
ct_levels_11_2        <- sj156_state$ct_levels
cell_type_colors_11_2 <- sj156_state$cell_type_colors
margin_colors_11_2    <- sj156_state$margin_colors

# Ilaria PROM-only modules for SJ156 (lineages × SJ samples)
avg_z_sj_prom_11_2 <- sj156_state$mods_prom$avg_z_by_ct

cat("\n[2] SJ156 Ilaria PROM modules (avg_z_sj_prom_11_2):\n")
cat("    dim =", paste(dim(avg_z_sj_prom_11_2), collapse = " × "), "\n")
cat("    lineages:", paste(rownames(avg_z_sj_prom_11_2), collapse = ", "), "\n")

panel_long_11_2$cell_type <- factor(panel_long_11_2$cell_type,
                                    levels = ct_levels_11_2)

# ------------------------------------------------
# 3) Ilaria PROM modules for Spain (gene_counts_spain_prom)
# ------------------------------------------------
gene_counts_spain_prom_11_2 <- spain_state$gene_counts_spain_prom
meta_spain_coding_11_2      <- spain_state$meta_spain_coding

cat("\n[3] gene_counts_spain_prom_11_2 (PROM-only):\n")
cat("    dim =", paste(dim(gene_counts_spain_prom_11_2), collapse = " × "), "\n")

meta_spain_11_2 <- meta_spain_coding_11_2 %>%
    transmute(
        Sample    = as.character(Sample),
        genotype  = factor(genotype, levels = c("TT", "TC", "CC")),
        cell_type = as.character(cell_type)
    )

# Align Spain samples between counts and metadata
samples_spain_11_2 <- intersect(colnames(gene_counts_spain_prom_11_2),
                                meta_spain_11_2$Sample)

gene_counts_spain_prom_11_2 <- gene_counts_spain_prom_11_2[, samples_spain_11_2,
                                                           drop = FALSE]
meta_spain_11_2 <- meta_spain_11_2 %>%
    filter(Sample %in% samples_spain_11_2)

# Reorder counts to match metadata
gene_counts_spain_prom_11_2 <- gene_counts_spain_prom_11_2[, meta_spain_11_2$Sample,
                                                           drop = FALSE]

cat("    Spain samples aligned:", ncol(gene_counts_spain_prom_11_2), "\n")

# Helper (defined once globally; safe to reuse)
if (!exists("build_modules_from_gene_counts")) {
    cat("[3b] Defining build_modules_from_gene_counts()...\n")
    build_modules_from_gene_counts <- function(gene_counts,
                                               panel_long,
                                               ct_levels,
                                               min_counts  = 10,
                                               min_samples = 5,
                                               clip_z      = 2) {
        stopifnot(is.matrix(gene_counts))
        
        keep <- rowSums(gene_counts >= min_counts) >= min_samples
        gene_counts_filt <- gene_counts[keep, , drop = FALSE]
        cat("    - build_modules: keeping", nrow(gene_counts_filt),
            "genes after min_counts/min_samples\n")
        
        logcpm <- edgeR::cpm(gene_counts_filt, log = TRUE, prior.count = 1)
        
        z_gene <- t(scale(t(logcpm)))
        z_gene[is.na(z_gene)] <- 0
        if (!is.null(clip_z)) {
            z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
        }
        
        avg_list <- lapply(ct_levels, function(ct) {
            g_ct <- panel_long$gene[panel_long$cell_type == ct]
            g_ct <- intersect(unique(g_ct), rownames(z_gene))
            if (length(g_ct) == 0L) {
                rep(NA_real_, ncol(z_gene))
            } else {
                colMeans(z_gene[g_ct, , drop = FALSE])
            }
        })
        
        avg_z_by_ct <- do.call(rbind, avg_list)
        rownames(avg_z_by_ct) <- ct_levels
        colnames(avg_z_by_ct) <- colnames(z_gene)
        
        invisible(list(avg_z_by_ct = avg_z_by_ct, z_gene = z_gene))
    }
} else {
    cat("[3b] Reusing existing build_modules_from_gene_counts().\n")
}

mods_spain_prom_ilaria_11_2 <- build_modules_from_gene_counts(
    gene_counts = gene_counts_spain_prom_11_2,
    panel_long  = panel_long_11_2,
    ct_levels   = ct_levels_11_2,
    min_counts  = 10,
    min_samples = 3,
    clip_z      = 2
)
avg_z_spain_prom_11_2 <- mods_spain_prom_ilaria_11_2$avg_z_by_ct

cat("\n[3c] Spain Ilaria PROM modules (avg_z_spain_prom_11_2):\n")
cat("    dim =", paste(dim(avg_z_spain_prom_11_2), collapse = " × "), "\n")
cat("    lineages:", paste(rownames(avg_z_spain_prom_11_2), collapse = ", "), "\n")

# ------------------------------------------------
# 4) Combine SJ156 + Spain (PROM), using only common lineages
# ------------------------------------------------
common_ct_11_2 <- intersect(rownames(avg_z_sj_prom_11_2),
                            rownames(avg_z_spain_prom_11_2))

avg_z_sj_prom_11_2    <- avg_z_sj_prom_11_2[common_ct_11_2, , drop = FALSE]
avg_z_spain_prom_11_2 <- avg_z_spain_prom_11_2[common_ct_11_2, , drop = FALSE]

mat_combined_prom_11_2 <- cbind(avg_z_sj_prom_11_2, avg_z_spain_prom_11_2)

cat("\n[4] Combined PROM matrix (SJ156 + Spain):\n")
cat("    dim =", paste(dim(mat_combined_prom_11_2), collapse = " × "), "\n")
cat("    common lineages:", paste(common_ct_11_2, collapse = ", "), "\n")
cat("    global range =", paste(range(mat_combined_prom_11_2, na.rm = TRUE),
                                collapse = " to "), "\n")

# ------------------------------------------------
# 5) Annotation: cohort + top_ct + margin (Q4→Q1)
# ------------------------------------------------
samples_sj_11_2    <- colnames(avg_z_sj_prom_11_2)
samples_spain_11_2 <- colnames(avg_z_spain_prom_11_2)

ann_all_11_2 <- data.frame(
    Sample = c(samples_sj_11_2, samples_spain_11_2),
    cohort = c(rep("SJ156", length(samples_sj_11_2)),
               rep("Spain", length(samples_spain_11_2))),
    stringsAsFactors = FALSE
)
rownames(ann_all_11_2) <- ann_all_11_2$Sample
ann_all_11_2 <- ann_all_11_2[colnames(mat_combined_prom_11_2), , drop = FALSE]

# Top lineage (Ilaria) per sample
top_idx_11_2 <- apply(mat_combined_prom_11_2, 2, which.max)
top_ct_11_2  <- rownames(mat_combined_prom_11_2)[top_idx_11_2]
ann_all_11_2$top_ct <- factor(top_ct_11_2, levels = common_ct_11_2)

# Second-best lineage + numeric margin
second_idx_11_2 <- apply(mat_combined_prom_11_2, 2,
                         function(v) order(v, decreasing = TRUE)[2])

margin_numeric_11_2 <- mat_combined_prom_11_2[cbind(top_idx_11_2,
                                                    seq_along(top_idx_11_2))] -
    mat_combined_prom_11_2[cbind(second_idx_11_2,
                                 seq_along(second_idx_11_2))]

# Quartile labels (logical order Q1<Q2<Q3<Q4)
margin_labels_11_2 <- c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")

ann_all_11_2$margin <- cut(
    margin_numeric_11_2,
    breaks = quantile(margin_numeric_11_2,
                      probs = seq(0, 1, 0.25),
                      na.rm = TRUE),
    include.lowest = TRUE,
    labels = margin_labels_11_2
)

# Relevel so that in the HEATMAP order is Q4 → Q3 → Q2 → Q1
ann_all_11_2$margin <- factor(
    ann_all_11_2$margin,
    levels = rev(margin_labels_11_2)  # Q4, Q3, Q2, Q1
)

cat("\n[5] top_ct and margin (visual order Q4→Q1):\n")
print(table(ann_all_11_2$top_ct, ann_all_11_2$cohort, useNA = "ifany"))
cat("\n    summary(margin_numeric_11_2):\n")
print(summary(margin_numeric_11_2))
cat("\n    margin level counts:\n")
print(table(ann_all_11_2$margin, useNA = "ifany"))

# ------------------------------------------------
# 6) Column ordering:
#    1) by top_ct,
#    2) then margin (Q4→Q1, Q4 left),
#    3) within each, by descending top_ct score
# ------------------------------------------------
top_score_11_2 <- mat_combined_prom_11_2[cbind(top_idx_11_2,
                                               seq_along(top_idx_11_2))]

col_order_11_2 <- order(
    ann_all_11_2$top_ct,   # lineages
    ann_all_11_2$margin,   # Q4 → Q3 → Q2 → Q1
    -top_score_11_2        # strongest first
)

mat_ord_11_2  <- mat_combined_prom_11_2[, col_order_11_2, drop = FALSE]
ann_all_11_2  <- ann_all_11_2[col_order_11_2, , drop = FALSE]

# Gaps between lineage blocks (columns) and between rows
r_11_2 <- rle(as.character(ann_all_11_2$top_ct))
gaps_col_11_2 <- if (length(r_11_2$lengths) > 1L)
    cumsum(r_11_2$lengths)[-length(r_11_2$lengths)] else NULL
gaps_row_11_2 <- if (length(common_ct_11_2) > 1L)
    seq_len(length(common_ct_11_2) - 1L) else NULL

cat("\n[6] Final column order by top_ct, margin (Q4→Q1) and score:\n")
print(table(ann_all_11_2$top_ct, ann_all_11_2$cohort, useNA = "ifany"))

# ------------------------------------------------
# 7) Annotation colors (chunk-specific)
# ------------------------------------------------
annotation_colors_11_2 <- list(
    cohort = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
    top_ct = cell_type_colors_11_2[names(cell_type_colors_11_2) %in% common_ct_11_2],
    margin = margin_colors_11_2
)

# ------------------------------------------------
# 8) Final pheatmap
# ------------------------------------------------
pheatmap::pheatmap(
    mat_ord_11_2,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    annotation_col = ann_all_11_2,
    annotation_colors = annotation_colors_11_2,
    gaps_row       = gaps_row_11_2,
    gaps_col       = gaps_col_11_2,
    show_colnames  = FALSE,
    show_rownames  = TRUE,
    border_color   = NA,
    main = "11.2 – Ilaria PROM modules — SJ156 + Spain (PROM-only, margin Q4→Q1; Q4 most separated first)"
)




```

## 11.3 doing top ct per cell type

```{r}
# ================================================================
# 11.3 (DIAG) – Ilaria PROM modules (SJ156 + Spain)
#                Lineage-specific margin quartiles (within-top_ct Q1–Q4)
#                + heavy diagnostics (all dplyr:: prefixed)
# ================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(pheatmap)
})

# ------------------------------------------------
# 1) Guardrails & base matrix
# ------------------------------------------------
stopifnot(exists("mat_combined_prom_11_2"))
stopifnot(exists("ann_all_11_2"))

mat_combined_prom_11_3 <- mat_combined_prom_11_2
common_ct_11_3         <- rownames(mat_combined_prom_11_3)

cat("\n[11.3/1] Base matrix (PROM, SJ156 + Spain)\n")
cat("  dim:", paste(dim(mat_combined_prom_11_3), collapse = " × "), "\n")
cat("  lineages (rows):", paste(common_ct_11_3, collapse = ", "), "\n")
cat("  global range:", paste(range(mat_combined_prom_11_3, na.rm = TRUE), collapse = " to "), "\n\n")

# ------------------------------------------------
# 2) Winner, runner-up, top_score, margin (numeric)
# ------------------------------------------------
top_idx_11_3    <- apply(mat_combined_prom_11_3, 2, which.max)
top_ct_11_3     <- rownames(mat_combined_prom_11_3)[top_idx_11_3]

second_idx_11_3 <- apply(
    mat_combined_prom_11_3, 2,
    function(v) order(v, decreasing = TRUE)[2]
)

top_score_11_3 <- mat_combined_prom_11_3[
    cbind(top_idx_11_3, seq_along(top_idx_11_3))
]

margin_numeric_11_3 <- mat_combined_prom_11_3[
    cbind(top_idx_11_3,   seq_along(top_idx_11_3))
] -
    mat_combined_prom_11_3[
        cbind(second_idx_11_3, seq_along(second_idx_11_3))
    ]

cat("[11.3/2] Winner & margin diagnostics (ALL samples)\n")
cat("  top_score range:", paste(range(top_score_11_3), collapse = " to "), "\n")
cat("  margin range   :", paste(range(margin_numeric_11_3), collapse = " to "), "\n")
cat("  correlation(top_score, margin):",
    round(cor(top_score_11_3, margin_numeric_11_3), 3), "\n\n")

# ------------------------------------------------
# 3) Build per-sample diagnostic data.frame
# ------------------------------------------------
df_margin_11_3 <- data.frame(
    Sample              = colnames(mat_combined_prom_11_3),
    top_ct              = factor(top_ct_11_3, levels = common_ct_11_3),
    top_score_11_3      = top_score_11_3,
    margin_numeric_11_3 = margin_numeric_11_3,
    stringsAsFactors    = FALSE
)

cat("[11.3/3] Per-lineage summaries (before binning)\n")
df_summary_global_11_3 <- df_margin_11_3 %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        n              = dplyr::n(),
        top_min        = min(top_score_11_3),
        top_med        = stats::median(top_score_11_3),
        top_max        = max(top_score_11_3),
        margin_min     = min(margin_numeric_11_3),
        margin_med     = stats::median(margin_numeric_11_3),
        margin_max     = max(margin_numeric_11_3),
        cor_top_margin = stats::cor(top_score_11_3, margin_numeric_11_3),
        .groups        = "drop"
    )
print(df_summary_global_11_3)
cat("\n")

# ------------------------------------------------
# 4) Lineage-specific margin quartiles (within top_ct)
#    Q1 = lowest margins for that lineage, Q4 = highest
# ------------------------------------------------
margin_labels_11_3 <- c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")

df_margin_11_3 <- df_margin_11_3 %>%
    dplyr::group_by(top_ct) %>%
    dplyr::mutate(
        margin_ct_bin_11_3 = cut(
            margin_numeric_11_3,
            breaks = stats::quantile(
                margin_numeric_11_3,
                probs = seq(0, 1, 0.25),
                na.rm = TRUE
            ),
            include.lowest = TRUE,
            labels = margin_labels_11_3
        )
    ) %>%
    dplyr::ungroup()

cat("[11.3/4] Counts by top_ct × local margin quartile (within lineage)\n")
print(table(df_margin_11_3$top_ct, df_margin_11_3$margin_ct_bin_11_3))
cat("\n")

# Quantiles per lineage (to see exact cutpoints)
cat("[11.3/4b] Margin quantiles within each lineage\n")
df_margin_quant_11_3 <- df_margin_11_3 %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        q0    = min(margin_numeric_11_3),
        q25   = stats::quantile(margin_numeric_11_3, 0.25),
        q50   = stats::quantile(margin_numeric_11_3, 0.50),
        q75   = stats::quantile(margin_numeric_11_3, 0.75),
        q100  = max(margin_numeric_11_3),
        .groups = "drop"
    )
print(df_margin_quant_11_3)
cat("\n")

# ------------------------------------------------
# 5) Are some Q3 samples "redder" (higher top_score) than Q4?
#    This is the key diagnostic you care about.
# ------------------------------------------------
cat("[11.3/5] Cross-over check: max(top_score in Q3) vs min(top_score in Q4)\n")
df_crossover_11_3 <- df_margin_11_3 %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        max_top_Q3 = if (any(margin_ct_bin_11_3 == "Q3"))
            max(top_score_11_3[margin_ct_bin_11_3 == "Q3"]) else NA_real_,
        min_top_Q4 = if (any(margin_ct_bin_11_3 == "Q4 (highest)"))
            min(top_score_11_3[margin_ct_bin_11_3 == "Q4 (highest)"]) else NA_real_,
        Q3_higher_than_Q4 = (max_top_Q3 > min_top_Q4),
        .groups = "drop"
    )
print(df_crossover_11_3)
cat("\n")

# Example: inspect lineage B ordered as in the heatmap
cat("[11.3/5b] Example rows for lineage B (ordered: margin_ct Q4→Q1, top_score desc)\n")
df_B_11_3 <- df_margin_11_3 %>%
    dplyr::filter(top_ct == "B") %>%
    dplyr::arrange(
        factor(margin_ct_bin_11_3,
               levels = c("Q4 (highest)", "Q3", "Q2", "Q1 (lowest)")),
        dplyr::desc(top_score_11_3)
    ) %>%
    dplyr::select(
        Sample,
        top_ct,
        top_score_11_3,
        margin_numeric_11_3,
        margin_ct_bin_11_3
    )

print(utils::head(df_B_11_3, 25))
cat("\n")

# ------------------------------------------------
# 6) Build annotation data.frame for the heatmap
# ------------------------------------------------
ann_all_11_3 <- data.frame(
    Sample           = colnames(mat_combined_prom_11_3),
    stringsAsFactors = FALSE
)
rownames(ann_all_11_3) <- ann_all_11_3$Sample

# Reuse cohort from 11.2 (do NOT overwrite that object)
ann_all_11_3$cohort <- ann_all_11_2[ann_all_11_3$Sample, "cohort"]

# Attach lineage and lineage-specific margin bins
ann_all_11_3$top_ct <- df_margin_11_3$top_ct[
    match(ann_all_11_3$Sample, df_margin_11_3$Sample)
]

ann_all_11_3$margin_ct <- factor(
    df_margin_11_3$margin_ct_bin_11_3[
        match(ann_all_11_3$Sample, df_margin_11_3$Sample)
    ],
    levels = c("Q4 (highest)", "Q3", "Q2", "Q1 (lowest)")  # display order
)

cat("[11.3/6] Annotation head (after matching to samples)\n")
print(utils::head(ann_all_11_3))
cat("\nMargin_ct level counts:\n")
print(table(ann_all_11_3$margin_ct, useNA = "ifany"))
cat("\n")

# ------------------------------------------------
# 7) Column order:
#    1) by top_ct (HSCMPP→…→B),
#    2) within each lineage: margin_ct Q4→Q1,
#    3) within each bin: descending top_score_11_3
# ------------------------------------------------
col_order_11_3 <- order(
    ann_all_11_3$top_ct,
    ann_all_11_3$margin_ct,
    -df_margin_11_3$top_score_11_3[
        match(ann_all_11_3$Sample, df_margin_11_3$Sample)
    ]
)

mat_ord_11_3 <- mat_combined_prom_11_3[, col_order_11_3, drop = FALSE]
ann_all_11_3 <- ann_all_11_3[col_order_11_3, , drop = FALSE]

# Gaps for pheatmap
r_11_3 <- rle(as.character(ann_all_11_3$top_ct))
gaps_col_11_3 <- if (length(r_11_3$lengths) > 1L)
    cumsum(r_11_3$lengths)[-length(r_11_3$lengths)] else NULL
gaps_row_11_3 <- if (length(common_ct_11_3) > 1L)
    seq_len(length(common_ct_11_3) - 1L) else NULL

cat("[11.3/7] Final column counts by top_ct × cohort\n")
print(table(ann_all_11_3$top_ct, ann_all_11_3$cohort))
cat("\nGaps between lineage blocks (column indices):\n")
print(gaps_col_11_3)
cat("\n")

# ------------------------------------------------
# 8) Annotation colors (reuse palettes from 11.2)
# ------------------------------------------------
stopifnot(exists("cell_type_colors_11_2"), exists("margin_colors_11_2"))

annotation_colors_11_3 <- list(
    cohort    = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
    top_ct    = cell_type_colors_11_2[
        names(cell_type_colors_11_2) %in% common_ct_11_3
    ],
    margin_ct = margin_colors_11_2
)

# ------------------------------------------------
# 9) Heatmap
# ------------------------------------------------
cat("[11.3/9] Drawing heatmap (lineage-specific margins Q4→Q1, DIAG)\n\n")

pheatmap::pheatmap(
    mat_ord_11_3,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    annotation_col = ann_all_11_3,
    annotation_colors = annotation_colors_11_3,
    gaps_row       = gaps_row_11_3,
    gaps_col       = gaps_col_11_3,
    show_colnames  = FALSE,
    show_rownames  = TRUE,
    border_color   = NA,
    main = "11.3 – Ilaria PROM modules — SJ156 + Spain\nLineage-specific margin quartiles (within-top_ct Q4→Q1; DIAG)"
)

```


## 11.4 without healthy
####11.4.1 preparation
```{r}
cat("\n================= FIX SJ GENE-LEVEL COLNAMES =================\n")

# Shortcuts
counts_sj         <- sj156_state$counts
gene_counts_sj    <- sj156_state$gene_counts_sj
gene_counts_sj_prom <- sj156_state$gene_counts_sj_prom
gene_counts_sj_enh  <- sj156_state$gene_counts_sj_enh

# 1. Safety: check column numbers match
stopifnot(
    ncol(counts_sj)         == ncol(gene_counts_sj),
    ncol(counts_sj)         == ncol(gene_counts_sj_prom),
    ncol(counts_sj)         == ncol(gene_counts_sj_enh)
)

cat("  • ncol(counts_sj) =", ncol(counts_sj), "\n")
cat("  • Column counts match across all SJ matrices ✔\n")

# 2. Copy colnames from counts_sj into all gene-level matrices
colnames(gene_counts_sj)      <- colnames(counts_sj)
colnames(gene_counts_sj_prom) <- colnames(counts_sj)
colnames(gene_counts_sj_enh)  <- colnames(counts_sj)

# 3. Write back into sj156_state to keep list and globals in sync
sj156_state$gene_counts_sj      <- gene_counts_sj
sj156_state$gene_counts_sj_prom <- gene_counts_sj_prom
sj156_state$gene_counts_sj_enh  <- gene_counts_sj_enh

# 4. Optional: quick sanity print
cat("\n[POST-FIX] Example colnames after repair:\n")
print(head(colnames(gene_counts_sj)))
print(head(colnames(gene_counts_sj_prom)))
print(head(colnames(gene_counts_sj_enh)))

cat("\n================= END FIX SJ GENE-LEVEL COLNAMES =================\n")

```

```{r}
# ================================================================
# 11.4 – Ilaria PROM modules — SJ156 only
#        Global margin quartiles (SJ-only, 11.2 / Tian-style)
#        Clean: NO Sample annotation, NO cohort
# ================================================================
# ================================================================
# TASK 2 — Spain-derived PROMOTER / ENHANCER markers on SJ156 + Healthy
# Using the markers you generated from the Spanish Data (promoter/enhancer)
# to plot the Spanish (Healthy) and SJ156 samples
# ================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(edgeR)
    library(pheatmap)
})

# ------------------------------------------------
# 1) Load core states (SJ156 + Healthy/Spain)
# ------------------------------------------------
combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"

if (!exists("sj156_state") || !exists("spain_state")) {
    cat("[1] Loading sj156_state and spain_state from:\n  ", combined_dir, "\n")
    
    if (!file.exists(file.path(combined_dir, "sj156_atac_core_state.rds"))) {
        stop("sj156_atac_core_state.rds not found in combined_dir.\n",
             "  → Please run the SJ156 saving chunk that creates sj156_atac_core_state.rds.")
    }
    if (!file.exists(file.path(combined_dir, "spain_atac_core_state.rds"))) {
        stop("spain_atac_core_state.rds not found in combined_dir.\n",
             "  → Please run the Spain saving chunk that creates spain_atac_core_state.rds.")
    }
    
    sj156_state <- readRDS(file.path(combined_dir, "sj156_atac_core_state.rds"))
    spain_state <- readRDS(file.path(combined_dir, "spain_atac_core_state.rds"))
} else {
    cat("[1] Using existing sj156_state and spain_state in memory.\n")
}

# ------------------------------------------------
# 2) Extract Spain-derived marker panels + gene-level counts
# ------------------------------------------------
panel_spain_prom_long <- spain_state$panel_spain_prom_long
panel_spain_enh_long  <- spain_state$panel_spain_enh_long
ct_spain_order        <- spain_state$ct_spain_order

if (is.null(panel_spain_prom_long) || is.null(panel_spain_enh_long)) {
    stop("panel_spain_prom_long or panel_spain_enh_long not found in spain_state.\n",
         "  → Make sure Spain marker panels are stored in spain_atac_core_state.rds.")
}

# Gene-level counts
gene_counts_sj      <- sj156_state$gene_counts_sj
gene_counts_healthy <- spain_state$gene_counts_spain

if (is.null(gene_counts_sj) || is.null(gene_counts_healthy)) {
    stop("gene_counts_sj or gene_counts_spain is NULL.\n",
         "  → Make sure both RDS files contain gene-level matrices.")
}

gene_counts_sj      <- as.matrix(gene_counts_sj)
gene_counts_healthy <- as.matrix(gene_counts_healthy)

cat("\n[2] Spain-derived marker panels (long format):\n")
cat("    ct_spain_order:", paste(ct_spain_order, collapse = " → "), "\n")
cat("    PROMOTER rows:", nrow(panel_spain_prom_long),
    " | unique genes:", length(unique(panel_spain_prom_long$gene)), "\n")
cat("    ENHANCER rows:", nrow(panel_spain_enh_long),
    " | unique genes:", length(unique(panel_spain_enh_long$gene)), "\n")

cat("\n[2b] Gene-level counts dimensions (genes × samples):\n")
cat("    SJ156  : ", paste(dim(gene_counts_sj),      collapse = " × "), "\n", sep = "")
cat("    Healthy: ", paste(dim(gene_counts_healthy), collapse = " × "), "\n", sep = "")

if (is.null(rownames(gene_counts_sj)) || is.null(rownames(gene_counts_healthy))) {
    stop("gene_counts_sj or gene_counts_healthy lack rownames (gene IDs). Please fix before proceeding.")
}

cat("\n[2c] Example gene IDs:\n")
cat("    SJ156 genes   :", paste(utils::head(rownames(gene_counts_sj), 10),      collapse = ", "), "\n")
cat("    Healthy genes :", paste(utils::head(rownames(gene_counts_healthy), 10), collapse = ", "), "\n")

# Asegurar niveles ordenados de cell_type
panel_spain_prom_long$cell_type <- factor(panel_spain_prom_long$cell_type,
                                          levels = ct_spain_order)
panel_spain_enh_long$cell_type  <- factor(panel_spain_enh_long$cell_type,
                                          levels = ct_spain_order)

# ------------------------------------------------
# 3) Diagnóstico de umbral en Healthy (España)
# ------------------------------------------------

check_threshold <- function(panel_long,
                            gene_counts_mat,
                            min_counts,
                            min_samples,
                            panel_label = "PANEL") {
    stopifnot(is.matrix(gene_counts_mat))
    
    cat("\n=== [check_threshold] ", panel_label,
        " | min_counts =", min_counts,
        " / min_samples =", min_samples, " ===\n", sep = "")
    
    ct_vals <- unique(panel_long$cell_type)
    
    for (ct in ct_vals) {
        g_ct <- unique(panel_long$gene[panel_long$cell_type == ct])
        g_ct <- intersect(g_ct, rownames(gene_counts_mat))
        
        if (length(g_ct) == 0L) {
            cat("  -", as.character(ct), ": panel=0 (ningún gen presente en counts)\n")
            next
        }
        
        expr   <- gene_counts_mat[g_ct, , drop = FALSE]
        keep   <- rowSums(expr >= min_counts) >= min_samples
        n_all  <- length(g_ct)
        n_keep <- sum(keep)
        
        cat("  -", as.character(ct), ": panel =", n_all,
            " | retenidos =", n_keep,
            sprintf(" (%.1f%%)", 100 * n_keep / n_all), "\n")
    }
}

# Lanza algunos thresholds para ver qué tan agresivo es 10/3
check_threshold(
    panel_long      = panel_spain_prom_long,
    gene_counts_mat = gene_counts_healthy,
    min_counts      = 5,
    min_samples     = 3,
    panel_label     = "PROMOTER"
)

check_threshold(
    panel_long      = panel_spain_prom_long,
    gene_counts_mat = gene_counts_healthy,
    min_counts      = 10,
    min_samples     = 3,
    panel_label     = "PROMOTER"
)

check_threshold(
    panel_long      = panel_spain_enh_long,
    gene_counts_mat = gene_counts_healthy,
    min_counts      = 5,
    min_samples     = 3,
    panel_label     = "ENHANCER"
)

check_threshold(
    panel_long      = panel_spain_enh_long,
    gene_counts_mat = gene_counts_healthy,
    min_counts      = 10,
    min_samples     = 3,
    panel_label     = "ENHANCER"
)

# Aquí decides, viendo las salidas, si 10/3 es razonable
# (que cada linaje conserve un número decente de genes, no 2–3).
# Por ahora seguimos con 10/3 como default, pero AJÚSTALO si ves algo raro.

# ------------------------------------------------
# 4) Congelar marcadores Spain en Healthy (Opción B)
# ------------------------------------------------

freeze_spain_markers <- function(panel_long,
                                 gene_counts_healthy,
                                 ct_levels,
                                 min_counts  = 10,
                                 min_samples = 3) {
    stopifnot(is.matrix(gene_counts_healthy))
    
    cat("\n[3] Congelando marcadores Spain en Healthy con umbrales:\n",
        "    min_counts  =", min_counts, "\n",
        "    min_samples =", min_samples, "\n")
    
    marker_list_raw <- split(panel_long$gene, panel_long$cell_type)
    marker_list_raw <- lapply(marker_list_raw, unique)
    
    marker_list_frozen <- list()
    
    for (ct in ct_levels) {
        g_ct <- marker_list_raw[[ct]]
        if (is.null(g_ct)) {
            cat("  [freeze] WARNING: no hay genes listados para", ct, "en panel_long\n")
            next
        }
        
        g_in_counts <- intersect(g_ct, rownames(gene_counts_healthy))
        if (length(g_in_counts) == 0L) {
            cat("  [freeze] WARNING:", ct, "sin genes presentes en gene_counts_healthy\n")
            next
        }
        
        expr <- gene_counts_healthy[g_in_counts, , drop = FALSE]
        keep <- rowSums(expr >= min_counts) >= min_samples
        g_keep <- g_in_counts[keep]
        
        cat("  [freeze] ", ct, ": panel =", length(g_ct),
            " | en_counts =", length(g_in_counts),
            " | retenidos =", length(g_keep), "\n", sep = "")
        
        if (length(g_keep) > 0L) {
            marker_list_frozen[[ct]] <- g_keep
        }
    }
    
    nonempty_ct <- intersect(ct_levels, names(marker_list_frozen))
    marker_list_frozen <- marker_list_frozen[nonempty_ct]
    
    cat("  [freeze] Lineajes finales con ≥1 gen marcador:\n      ",
        paste(names(marker_list_frozen), collapse = ", "), "\n")
    
    invisible(marker_list_frozen)
}

# Usa 10/3 por defecto, pero cámbialo si el diagnóstico te dice que es muy agresivo
frozen_prom_markers <- freeze_spain_markers(
    panel_long          = panel_spain_prom_long,
    gene_counts_healthy = gene_counts_healthy,
    ct_levels           = ct_spain_order,
    min_counts          = 10,
    min_samples         = 3
)

frozen_enh_markers <- freeze_spain_markers(
    panel_long          = panel_spain_enh_long,
    gene_counts_healthy = gene_counts_healthy,
    ct_levels           = ct_spain_order,
    min_counts          = 10,
    min_samples         = 3
)

# ------------------------------------------------
# 5) Construir módulos usando marcadores congelados
# ------------------------------------------------

build_modules_with_frozen_markers <- function(gene_counts,
                                              frozen_markers,
                                              clip_z = 2) {
    stopifnot(is.matrix(gene_counts))
    
    cat("  [modules_frozen] Input dim (genes × samples):",
        paste(dim(gene_counts), collapse = " × "), "\n")
    
    all_marker_genes <- unique(unlist(frozen_markers))
    genes_use <- intersect(all_marker_genes, rownames(gene_counts))
    if (length(genes_use) == 0L) {
        stop("  [modules_frozen] Ningún gen marcador congelado se encontró en gene_counts.")
    }
    
    gene_counts_sub <- gene_counts[genes_use, , drop = FALSE]
    cat("  [modules_frozen] Genes presentes de marcadores congelados:",
        nrow(gene_counts_sub), "\n")
    
    keep_nonzero <- rowSums(gene_counts_sub) > 0
    gene_counts_sub <- gene_counts_sub[keep_nonzero, , drop = FALSE]
    cat("  [modules_frozen] Tras quitar genes todo-cero:",
        nrow(gene_counts_sub), "genes.\n")
    
    logcpm <- edgeR::cpm(gene_counts_sub, log = TRUE, prior.count = 1)
    
    z_gene <- t(scale(t(logcpm)))
    z_gene[is.na(z_gene)] <- 0
    if (!is.null(clip_z)) {
        z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
    }
    
    ct_levels <- names(frozen_markers)
    avg_list <- lapply(ct_levels, function(ct) {
        g_ct <- intersect(frozen_markers[[ct]], rownames(z_gene))
        if (length(g_ct) == 0L) {
            cat("    [modules_frozen] WARNING:", ct,
                "tiene 0 genes presentes en este cohorte → fila NA.\n")
            return(rep(NA_real_, ncol(z_gene)))
        } else {
            return(colMeans(z_gene[g_ct, , drop = FALSE]))
        }
    })
    
    avg_z_by_ct <- do.call(rbind, avg_list)
    rownames(avg_z_by_ct) <- ct_levels
    colnames(avg_z_by_ct) <- colnames(z_gene)
    
    cat("  [modules_frozen] avg_z_by_ct dim (lineajes × muestras):",
        paste(dim(avg_z_by_ct), collapse = " × "), "\n")
    
    invisible(list(avg_z_by_ct = avg_z_by_ct, z_gene = z_gene))
}

# ------------------------------------------------
# 6) Heatmap conjunto SJ156 + Healthy con marcadores congelados
# ------------------------------------------------

cell_type_colors_spain <- c(
    HSC          = "#fb8072",
    CLP          = "#bebada",
    ProB         = "#ff33ff",
    PreB         = "#00e5c0",
    `Immature-B` = "#00bfff"
)

build_spain_joint_heatmap_frozen <- function(frozen_markers,
                                             marker_label = c("PROMOTER", "ENHANCER")) {
    marker_label <- match.arg(marker_label)
    cat("\n[4] Joint heatmap con MARCADORES CONGELADOS Spain (",
        marker_label, ") en SJ156 + Healthy...\n", sep = "")
    
    cat("    [4] Módulos en SJ156...\n")
    mods_sj <- build_modules_with_frozen_markers(
        gene_counts    = gene_counts_sj,
        frozen_markers = frozen_markers,
        clip_z         = 2
    )
    
    cat("    [4] Módulos en Healthy...\n")
    mods_healthy <- build_modules_with_frozen_markers(
        gene_counts    = gene_counts_healthy,
        frozen_markers = frozen_markers,
        clip_z         = 2
    )
    
    mat_sj      <- mods_sj$avg_z_by_ct
    mat_healthy <- mods_healthy$avg_z_by_ct
    
    common_ct <- intersect(rownames(mat_sj), rownames(mat_healthy))
    mat_sj      <- mat_sj[common_ct, , drop = FALSE]
    mat_healthy <- mat_healthy[common_ct, , drop = FALSE]
    
    mat_combined <- cbind(mat_sj, mat_healthy)
    
    cat("    [4] Matriz combinada dim (lineajes × muestras):",
        paste(dim(mat_combined), collapse = " × "), "\n")
    cat("    [4] Lineajes comunes:",
        paste(common_ct, collapse = ", "), "\n")
    
    samples_sj      <- colnames(mat_sj)
    samples_healthy <- colnames(mat_healthy)
    
    ann_all <- data.frame(
        cohort = factor(c(rep("SJ156",  length(samples_sj)),
                          rep("Healthy", length(samples_healthy))),
                        levels = c("SJ156", "Healthy")),
        row.names = c(samples_sj, samples_healthy)
    )
    ann_all <- ann_all[colnames(mat_combined), , drop = FALSE]
    
    top_idx <- apply(mat_combined, 2, function(v) {
        if (all(is.na(v))) return(NA_integer_)
        which.max(v)
    })
    top_ct <- ifelse(is.na(top_idx),
                     NA_character_,
                     rownames(mat_combined)[top_idx])
    ann_all$top_ct <- factor(top_ct, levels = common_ct)
    
    cat("    [4b] Distribución top_ct × cohorte (antes de ordenar):\n")
    print(table(ann_all$top_ct, ann_all$cohort, useNA = "ifany"))
    
    col_order <- character(0)
    for (ct in common_ct) {
        cols_ct_sj      <- rownames(ann_all)[ann_all$top_ct == ct & ann_all$cohort == "SJ156"]
        cols_ct_healthy <- rownames(ann_all)[ann_all$top_ct == ct & ann_all$cohort == "Healthy"]
        col_order       <- c(col_order, cols_ct_sj, cols_ct_healthy)
    }
    col_order <- col_order[col_order %in% colnames(mat_combined)]
    
    mat_ord <- mat_combined[, col_order, drop = FALSE]
    ann_all <- ann_all[col_order, , drop = FALSE]
    
    r <- rle(as.character(ann_all$top_ct))
    gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL
    gaps_row <- if (length(common_ct) > 1L) seq_len(length(common_ct) - 1L) else NULL
    
    cat("    [4c] Final top_ct × cohorte (después de ordenar):\n")
    print(table(ann_all$top_ct, ann_all$cohort, useNA = "ifany"))
    cat("    [4c] gaps_row:",
        if (is.null(gaps_row)) "NONE" else paste(gaps_row, collapse = ", "),
        "\n")
    cat("    [4c] gaps_col:",
        if (is.null(gaps_col)) "NONE" else paste(gaps_col, collapse = ", "),
        "\n")
    
    annotation_colors <- list(
        cohort = c(SJ156 = "#1f78b4", Healthy = "#33a02c"),
        top_ct = cell_type_colors_spain[names(cell_type_colors_spain) %in% common_ct]
    )
    
    pheatmap::pheatmap(
        mat_ord,
        cluster_rows   = FALSE,
        cluster_cols   = FALSE,
        annotation_col = ann_all,
        annotation_colors = annotation_colors,
        gaps_row       = gaps_row,
        gaps_col       = gaps_col,
        show_colnames  = FALSE,
        show_rownames  = TRUE,
        border_color   = NA,
        main = paste0(
            "Frozen Spain-derived ", marker_label,
            " markers — SJ156 + Healthy (gene-level modules)"
        )
    )
}

# ------------------------------------------------
# 7) Ejecutar para PROMOTER y ENHANCER
# ------------------------------------------------
build_spain_joint_heatmap_frozen(frozen_prom_markers, marker_label = "PROMOTER")
build_spain_joint_heatmap_frozen(frozen_enh_markers,  marker_label = "ENHANCER")

```


# 12  UMAP

```{r}
# ================================================================
# X. UMAP of promoter accessibility (SJ156 + Healthy, gene-level)
#    One embedding, all samples, features = promoter genes
#    NOW WITH ComBat batch correction (batch = cohort)
# ================================================================
suppressPackageStartupMessages({
    library(dplyr)
    library(DESeq2)
    library(matrixStats)
    library(uwot)
    library(ggplot2)
    library(sva)      # <- ComBat
})

# ------------------------------
# 1) Load core states if needed
# ------------------------------
combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"

if (!exists("sj156_state") || !exists("healthy_state")) {
    cat("[1] Loading sj156_state and healthy_state from:\n   ", combined_dir, "\n")
    sj156_state    <- readRDS(file.path(combined_dir, "sj156_atac_core_state.rds"))
    healthy_state  <- readRDS(file.path(combined_dir, "spain_atac_core_state.rds"))  # ORIGINAL FILE NAME
} else {
    cat("[1] Using sj156_state and healthy_state already in memory.\n")
}

# -------------------------------------------------
# 2) Build / obtain GENE-LEVEL promoter counts
# -------------------------------------------------

## 2a. SJ156
promoter_counts_sj <- sj156_state$promoter_counts_sj
peak_anno_sj       <- sj156_state$peak_anno

cat("\n[2a] SJ156 promoter_counts_sj dim: ",
    paste(dim(promoter_counts_sj), collapse = " × "), "\n", sep = "")
cat("[2a] SJ156 peak_anno_sj rows: ", nrow(peak_anno_sj), "\n", sep = "")

prom_anno <- peak_anno_sj[match(rownames(promoter_counts_sj),
                                peak_anno_sj$peak_id), ]

if (any(is.na(prom_anno$peak_id))) {
    missing <- rownames(promoter_counts_sj)[is.na(prom_anno$peak_id)]
    print(head(missing))
    stop("Fix peak_anno_sj / promoter_counts_sj alignment before continuing.")
}
stopifnot(identical(rownames(promoter_counts_sj), prom_anno$peak_id))

valid_gene <- !is.na(prom_anno$SYMBOL) & prom_anno$SYMBOL != ""
prom_anno_use      <- prom_anno[valid_gene, , drop = FALSE]
prom_counts_sj_use <- promoter_counts_sj[valid_gene, , drop = FALSE]

cat("[2a] promoter_counts_sj_use dim: ",
    paste(dim(prom_counts_sj_use), collapse = " × "), "\n", sep = "")

gene2peaks_sj <- split(prom_anno_use$peak_id, prom_anno_use$SYMBOL)

gene_counts_sj_prom <- vapply(
    gene2peaks_sj,
    function(peaks) colSums(prom_counts_sj_use[peaks, , drop = FALSE]),
    FUN.VALUE = numeric(ncol(prom_counts_sj_use))
)
gene_counts_sj_prom <- t(gene_counts_sj_prom)
colnames(gene_counts_sj_prom) <- colnames(prom_counts_sj_use)

cat("[2a] gene_counts_sj_prom dim: ",
    paste(dim(gene_counts_sj_prom), collapse = " × "), "\n", sep = "")

## 2b. Healthy
if (!is.null(healthy_state$gene_counts_spain_prom)) {
    gene_counts_healthy_prom <- as.matrix(healthy_state$gene_counts_spain_prom)
    cat("\n[2b] gene_counts_healthy_prom dim: ",
        paste(dim(gene_counts_healthy_prom), collapse = " × "), "\n", sep = "")
} else {
    stop("[2b] healthy_state$gene_counts_spain_prom is NULL.")
}

# -------------------------------------------------
# 3) Combine cohorts
# -------------------------------------------------
common_genes <- intersect(rownames(gene_counts_sj_prom),
                          rownames(gene_counts_healthy_prom))
cat("\n[3] Common promoter genes SJ156 ∩ Healthy: ",
    length(common_genes), "\n", sep = "")

gene_counts_sj_prom       <- gene_counts_sj_prom[common_genes, , drop = FALSE]
gene_counts_healthy_prom  <- gene_counts_healthy_prom[common_genes, , drop = FALSE]

prom_mat <- cbind(gene_counts_sj_prom, gene_counts_healthy_prom)

cat("[3] Combined promoter gene matrix dim: ",
    paste(dim(prom_mat), collapse = " × "), "\n", sep = "")

# -------------------------------------------------
# 4) Filter genes
# -------------------------------------------------
MIN_READS_UMAP   <- 5L
MIN_SAMPLES_UMAP <- 3L
N_TOP_VAR_UMAP   <- 5000L

keep <- rowSums(prom_mat >= MIN_READS_UMAP) >= MIN_SAMPLES_UMAP
prom_mat_filt <- prom_mat[keep, , drop = FALSE]

cat("\n[4] Genes passing min thresholds: ",
    nrow(prom_mat_filt), "\n", sep = "")

if (nrow(prom_mat_filt) > N_TOP_VAR_UMAP) {
    v <- matrixStats::rowVars(prom_mat_filt)
    o <- order(v, decreasing = TRUE)[seq_len(N_TOP_VAR_UMAP)]
    prom_mat_filt <- prom_mat_filt[o, , drop = FALSE]
    cat("[4] Restricted to top ", N_TOP_VAR_UMAP, " variable genes.\n", sep = "")
}

# -------------------------------------------------
# 5) VST transform
# -------------------------------------------------
n_sj      <- ncol(gene_counts_sj_prom)
n_healthy <- ncol(gene_counts_healthy_prom)

cat("\n[5] Samples — SJ156:", n_sj, "| Healthy:", n_healthy, "\n")

col_data_umap <- data.frame(
    Sample = colnames(prom_mat_filt),
    cohort = factor(c(rep("SJ156",  n_sj),
                      rep("Healthy", n_healthy)),
                    levels = c("SJ156", "Healthy"))
)

dds_umap <- DESeqDataSetFromMatrix(
    countData = prom_mat_filt,
    colData   = col_data_umap,
    design    = ~ 1
)
dds_umap <- estimateSizeFactors(dds_umap)
vsd_umap <- vst(dds_umap, blind = TRUE)
mat_vst  <- assay(vsd_umap)

# -------------------------------------------------
# 6) ComBat correction
# -------------------------------------------------
cat("\n[6] Running ComBat batch correction (batch = cohort)...\n")

batch <- col_data_umap$cohort
mod   <- model.matrix(~1, data = col_data_umap)

mat_vst_cb <- ComBat(
    dat   = as.matrix(mat_vst),
    batch = batch,
    mod   = mod,
    par.prior   = TRUE,
    prior.plots = FALSE
)

# -------------------------------------------------
# 7) UMAP embedding
# -------------------------------------------------
set.seed(123)

n_neighbors <- min(15L, ncol(mat_vst_cb) - 1L)

umap_coords <- uwot::umap(
    X           = t(mat_vst_cb),
    n_neighbors = n_neighbors,
    min_dist    = 0.3,
    metric      = "euclidean"
)

umap_df <- data.frame(
    Sample = colnames(mat_vst_cb),
    UMAP1  = umap_coords[, 1],
    UMAP2  = umap_coords[, 2],
    cohort = col_data_umap$cohort,
    stringsAsFactors = FALSE
)

# -------------------------------------------------
# 8) Metadata join (Healthy instead of Spain)
# -------------------------------------------------
meta_sj <- sj156_state$meta_sj %>%
    dplyr::select(Sample, genotype, Subtype) %>%
    mutate(cohort = "SJ156")

meta_healthy <- healthy_state$meta_spain %>%   # original name
    dplyr::select(Sample, genotype, cell_type) %>%
    mutate(cohort = "Healthy")

meta_all <- bind_rows(meta_sj, meta_healthy) %>%
    mutate(
        Sample   = as.character(Sample),
        cohort   = factor(cohort, levels = c("SJ156", "Healthy")),
        genotype = factor(genotype, levels = c("TT", "TC", "CC"))
    )

umap_df <- umap_df %>%
    left_join(meta_all, by = c("Sample", "cohort"))

# -------------------------------------------------
# 9) UMAP plots
# -------------------------------------------------
geno_cols <- sj156_state$geno_cols

## 9a — Genotype / Cohort
ggplot(umap_df, aes(UMAP1, UMAP2, color = genotype, shape = cohort)) +
    geom_point(size = 3, alpha = 0.9) +
    scale_color_manual(values = geno_cols) +
    theme_bw(14) +
    labs(
        title = "UMAP of promoter accessibility (SJ156 + Healthy, ComBat-corrected)",
        subtitle = "Features = promoter genes (VST + ComBat)",
        color = "Genotype",
        shape = "Cohort"
    )

## 9b — SJ subtype vs Healthy true cell type
ggplot(umap_df, aes(UMAP1, UMAP2)) +
    geom_point(aes(color = Subtype),
               data = subset(umap_df, cohort == "SJ156"),
               size = 3, alpha = 0.9) +
    geom_point(aes(color = cell_type),
               data = subset(umap_df, cohort == "Healthy"),
               size = 3, alpha = 0.9, shape = 17) +
    theme_bw(14) +
    labs(
        title = "UMAP promoter space: SJ156 subtypes vs Healthy cell types",
        subtitle = "Circles = SJ156, triangles = Healthy",
        x = "UMAP1", y = "UMAP2"
    )

```
# 13 Confusion matrix
```{r}
# ================================================================
# CONFUSION MATRIX — Naive CD5± removed + Transitional-B removed
# Dev order updated accordingly
# ================================================================
suppressPackageStartupMessages({
    library(ggplot2)
    library(FNN)
    library(dplyr)
    library(tidyr)
})

cat("\n=== CONFUSION MATRIX (FULL VERSION) — Naive CD5± + Transitional-B removed ===\n")

# -------------------------------------------------------------
# 0) Define developmental order (Transitional-B REMOVED)
# -------------------------------------------------------------
dev_order <- c("HSC", "CLP", "ProB", "PreB", "Immature-B")

# -------------------------------------------------------------
# 1) Healthy reference (remove Naives + Transitional-B)
# -------------------------------------------------------------
healthy_ref <- umap_df %>%
    dplyr::filter(cohort == "Healthy", !is.na(cell_type)) %>%
    dplyr::filter(!(cell_type %in% c("Naive-CD5-", "Naive-CD5--", "Transitional-B")))

cat("[CHECK] Healthy_ref n=", nrow(healthy_ref), "\n", sep = "")
cat("[CHECK] Healthy_ref cell_type counts:\n")
print(sort(table(healthy_ref$cell_type), decreasing = TRUE))

if (nrow(healthy_ref) == 0L) stop("No Healthy samples with valid cell_type after filtering.")

healthy_centroids <- healthy_ref %>%
    dplyr::group_by(cell_type) %>%
    dplyr::summarize(
        CX = mean(UMAP1),
        CY = mean(UMAP2),
        n  = dplyr::n(),
        .groups = "drop"
    ) %>%
    dplyr::mutate(cell_type = factor(cell_type, levels = dev_order)) %>%
    dplyr::arrange(cell_type)

cat("\n[1] Healthy centroids (filtered):\n")
print(healthy_centroids)

# -------------------------------------------------------------
# 2) Classify SJ156 by nearest centroid + compute confidence
# -------------------------------------------------------------
sj_samples_umap <- umap_df %>%
    dplyr::filter(cohort == "SJ156") %>%
    dplyr::select(Sample, UMAP1, UMAP2)

centroid_mat <- as.matrix(healthy_centroids[, c("CX", "CY")])
sj_mat       <- as.matrix(sj_samples_umap[, c("UMAP1", "UMAP2")])

nearest_idx <- FNN::knnx.index(
    data  = centroid_mat,
    query = sj_mat,
    k     = 1
)

all_dist <- FNN::knnx.dist(
    data  = centroid_mat,
    query = sj_mat,
    k     = nrow(centroid_mat)
)

closest        <- all_dist[, 1]
second_closest <- all_dist[, 2]
confidence_ratio <- closest / second_closest  # closer to 0 => more confident

sj_samples_umap <- sj_samples_umap %>%
    dplyr::mutate(
        inferred_lineage  = as.character(healthy_centroids$cell_type[nearest_idx]),
        confidence_ratio  = confidence_ratio
    )

# -------------------------------------------------------------
# 3) Build confusion matrix (WITH dev order)
# -------------------------------------------------------------
sj_meta <- sj156_state$meta_sj %>% dplyr::select(Sample, Subtype)

conf_df <- sj_samples_umap %>%
    dplyr::left_join(sj_meta, by = "Sample") %>%
    dplyr::mutate(
        inferred_lineage = factor(inferred_lineage, levels = dev_order),
        Subtype          = factor(Subtype)
    )

conf_mat <- table(conf_df$Subtype, conf_df$inferred_lineage)

cat("\n[2] Confusion matrix with developmental ordering (filtered refs):\n")
print(conf_mat)

# -------------------------------------------------------------
# 4) Heatmap
# -------------------------------------------------------------
conf_df_plot <- as.data.frame(conf_mat)
colnames(conf_df_plot) <- c("SJ_Subtype", "Inferred_Lineage", "Count")

ggplot(conf_df_plot,
       aes(x = Inferred_Lineage, y = SJ_Subtype, fill = Count)) +
    geom_tile(color = "white") +
    geom_text(aes(label = Count), size = 4) +
    scale_fill_gradient(low = "#e0f3db", high = "#43a2ca") +
    theme_bw(base_size = 14) +
    labs(
        title    = "Confusion Matrix: SJ156 Subtypes vs Healthy Lineages",
        subtitle = "Nearest-centroid classifier (ComBat-corrected); Naive CD5± + Transitional-B removed",
        x = "Inferred lineage (Healthy reference)",
        y = "SJ156 subtype"
    )

# -------------------------------------------------------------
# 5) Subtype-specific stacked barplots (%)
# -------------------------------------------------------------
stack_df <- conf_df %>%
    dplyr::count(Subtype, inferred_lineage) %>%
    dplyr::group_by(Subtype) %>%
    dplyr::mutate(percent = 100 * n / sum(n)) %>%
    dplyr::ungroup()

ggplot(stack_df,
       aes(x = Subtype, y = percent, fill = inferred_lineage)) +
    geom_bar(stat = "identity", position = "stack") +
    scale_fill_brewer(palette = "Set2") +
    theme_bw(base_size = 14) +
    coord_flip() +
    labs(
        title = "Subtype-specific distribution of inferred lineages",
        subtitle = "Reference lineages exclude Naive CD5± and Transitional-B",
        y = "% of samples",
        x = "SJ156 subtype",
        fill = "Inferred lineage"
    )

# -------------------------------------------------------------
# 6) Confidence ratio histogram
# -------------------------------------------------------------
ggplot(conf_df, aes(x = confidence_ratio)) +
    geom_histogram(bins = 30, fill = "#1f78b4", color = "white", alpha = 0.8) +
    theme_bw(base_size = 14) +
    labs(
        title = "Classification confidence (distance ratio)",
        subtitle = "Closer to 0 = more confident classification",
        x = "Distance ratio (closest / second closest centroid)",
        y = "Count"
    )

cat("\n[CHECK] Assigned inferred_lineage counts (SJ156):\n")
print(conf_df %>% dplyr::count(inferred_lineage))

```
Ditch transitional B on both matrix and umap
 
# 14 Heatmap of sj156 using ilarias markers

```{r}
# =====================================================================
# ATAC — ILARIA DOMINANCE MAP (ALL PEAKS; TSS-BASED COLLAPSE)
#        + ONE-PEAK-PER-GENE (closest-to-TSS across ALL peaks)
#        + QC for this strategy
#
# Rationale:
#   - Avoid "big gene = more peaks = more votes" by enforcing 1 gene = 1 vote
#   - For ALL peaks, we collapse peak→gene by selecting, per gene, the peak
#     with minimal abs(distanceToTSS) (i.e., most proximal peak overall).
#
# Requires:
#   - counts   : matrix [peaks × samples] (ATAC peak-level counts)
#   - anno_df  : data.frame with peak_id, SYMBOL, distanceToTSS (annotation optional)
#   - meta_sj  : data.frame with Sample, genotype
#
# Produces:
#   - counts_all_gene              (gene matrix; one peak per gene)
#   - avg_z_by_ct_ATAC_raw        (raw module scores)
#   - avg_z_by_ct_ATAC            (column-scaled module scores)
#   - dominant_tbl_ATAC           (winner + margin)
#   - ann_col_ATAC                (pheatmap annotations)
#   - ALL-peaks dominance heatmap
# =====================================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(readr)
  library(tibble)
  library(pheatmap)
  library(stringr)
})

cat("\n[ILARIA/ALL-TSS] =============================================\n")
cat("[ILARIA/ALL-TSS] ALL PEAKS — one peak per gene (closest-to-TSS)\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts"))  stop("[ILARIA/ALL-TSS] ERROR: `counts` not found.")
if (!exists("anno_df")) stop("[ILARIA/ALL-TSS] ERROR: `anno_df` not found.")
if (!exists("meta_sj")) stop("[ILARIA/ALL-TSS] ERROR: `meta_sj` not found.")

stopifnot(!is.null(rownames(counts)), !is.null(colnames(counts)))
stopifnot(all(c("peak_id", "SYMBOL") %in% colnames(anno_df)))
if (!("distanceToTSS" %in% colnames(anno_df))) {
  stop("[ILARIA/ALL-TSS] ERROR: anno_df must contain `distanceToTSS` for TSS-based collapsing.")
}

cat("[0] counts dim (peaks × samples): ", paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols): ", paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 1 — Load Ilaria panel (if needed)
# ---------------------------------------------------------------------
if (!exists("panel_long") || !exists("panel_genes") || !exists("ct_levels")) {

  cat("\n[1] Loading curated Ilaria panel (objects not found)...\n")

  panel_path <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/clean_ilarias_700_genes.csv"
  cat("    • panel_path = ", panel_path, "\n", sep = "")

  df_raw <- readr::read_csv(panel_path, show_col_types = FALSE)

  df_updated <- df_raw %>%
    dplyr::mutate(
      dplyr::across(
        .cols = dplyr::everything(),
        .fns  = ~ {
          x <- as.character(.)
          x <- stringr::str_trim(x)
          dplyr::na_if(x, "")
        }
      )
    )

  panel_long <- df_updated %>%
    tidyr::pivot_longer(
      cols      = dplyr::everything(),
      names_to  = "cell_type",
      values_to = "gene"
    ) %>%
    dplyr::filter(!is.na(gene), gene != "")

  panel_genes <- unique(panel_long$gene)
  ct_levels   <- colnames(df_updated)

  cat("[1] Panel loaded:\n")
  cat("    • unique marker genes : ", length(panel_genes), "\n", sep = "")
  cat("    • cell_type levels    : ", paste(ct_levels, collapse = " → "), "\n", sep = "")
}

# ---------------------------------------------------------------------
# 2 — Build ALL-peaks TSS-based peak→gene map + choose ONE peak per gene
# ---------------------------------------------------------------------
cat("\n[2] Building TSS-based peak→gene map (ALL peaks) + selecting closest peak per gene...\n")

anno_tss <- anno_df %>%
  dplyr::mutate(
    .tss_dist = suppressWarnings(as.numeric(as.character(.data$distanceToTSS))),
    .abs_tss  = abs(.tss_dist)
  )

cat("[2-QC] distanceToTSS |abs| summary:\n")
print(summary(anno_tss$.abs_tss))

n_na_dist <- sum(is.na(anno_tss$.abs_tss))
cat("[2-QC] peaks with NA distanceToTSS after coercion: ", n_na_dist, "\n", sep = "")

gene_map_all <- anno_tss %>%
  dplyr::filter(!is.na(SYMBOL), SYMBOL != "") %>%
  dplyr::select(peak_id, SYMBOL, .tss_dist, .abs_tss, dplyr::any_of("annotation")) %>%
  dplyr::distinct()

common_peaks_all <- intersect(rownames(counts), gene_map_all$peak_id)
cat("[2] peaks with SYMBOL (anno): ", nrow(gene_map_all), "\n", sep = "")
cat("[2] overlap with counts rownames: ", length(common_peaks_all), "\n", sep = "")

if (length(common_peaks_all) == 0L) {
  stop("[2] ERROR: No overlap between gene_map_all$peak_id and rownames(counts).")
}

# QC: peaks per gene (ALL peaks)
peaks_per_gene_all <- gene_map_all %>%
  dplyr::filter(peak_id %in% common_peaks_all) %>%
  dplyr::count(SYMBOL, name = "n_peaks") %>%
  dplyr::arrange(dplyr::desc(n_peaks))

cat("[2-QC] peaks-per-gene summary (ALL peaks with SYMBOL):\n")
print(summary(peaks_per_gene_all$n_peaks))
cat("[2-QC] top genes by # peaks (first 10):\n")
print(utils::head(peaks_per_gene_all, 10))

# One peak per gene: closest-to-TSS across ALL peaks
gene_map_one <- gene_map_all %>%
  dplyr::filter(peak_id %in% common_peaks_all) %>%
  dplyr::group_by(SYMBOL) %>%
  dplyr::slice_min(.abs_tss, with_ties = FALSE) %>%
  dplyr::ungroup() %>%
  dplyr::select(SYMBOL, peak_id, .tss_dist, .abs_tss) %>%
  dplyr::distinct()

cat("[2] selected 1 peak/gene (closest-to-TSS across ALL peaks): ", nrow(gene_map_one), "\n", sep = "")
stopifnot(!anyDuplicated(gene_map_one$SYMBOL))

# QC: any selected peak maps to >1 gene?
genes_per_peak_all <- gene_map_one %>%
  dplyr::count(peak_id, name = "n_genes") %>%
  dplyr::arrange(dplyr::desc(n_genes))

n_ambig_peak <- sum(genes_per_peak_all$n_genes > 1)
cat("[2-QC] selected peaks mapping to >1 gene: ", n_ambig_peak, "\n", sep = "")

# ---------------------------------------------------------------------
# 3 — Build gene matrix (genes × samples) using ONE peak per gene
# ---------------------------------------------------------------------
cat("\n[3] Building counts_all_gene (genes × samples) using ONE peak/gene...\n")

counts_all_gene <- counts[gene_map_one$peak_id, , drop = FALSE]
rownames(counts_all_gene) <- gene_map_one$SYMBOL

cat("[3] counts_all_gene dim (genes × samples): ", paste(dim(counts_all_gene), collapse = " × "), "\n", sep = "")
stopifnot(!anyDuplicated(rownames(counts_all_gene)))
stopifnot(all(colnames(counts_all_gene) == colnames(counts)))

# OPTIONAL QC (fast-ish): compare one-peak vs sum-of-peaks BUT ONLY for Ilaria genes
cat("\n[3-QC] OPTIONAL: one-peak vs SUM-OF-PEAKS comparison (restricted to Ilaria genes)...\n")

gene_map_panel <- gene_map_all %>%
  dplyr::filter(SYMBOL %in% panel_genes, peak_id %in% common_peaks_all) %>%
  dplyr::select(peak_id, SYMBOL) %>%
  dplyr::distinct()

cat("[3-QC] Ilaria-mapped peaks for SUM comparison: ", nrow(gene_map_panel), "\n", sep = "")
cat("[3-QC] unique Ilaria genes with ≥1 peak: ", length(unique(gene_map_panel$SYMBOL)), "\n", sep = "")

if (nrow(gene_map_panel) > 0) {
  counts_panel_df <- as.data.frame(counts[unique(gene_map_panel$peak_id), , drop = FALSE])
  counts_panel_df$peak_id <- rownames(counts_panel_df)

  sum_join <- gene_map_panel %>%
    dplyr::left_join(counts_panel_df, by = "peak_id", relationship = "many-to-many")

  counts_all_gene_sum_panel <- sum_join %>%
    dplyr::select(-peak_id) %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::summarise(dplyr::across(dplyr::where(is.numeric), sum), .groups = "drop") %>%
    as.data.frame()

  rownames(counts_all_gene_sum_panel) <- counts_all_gene_sum_panel$SYMBOL
  counts_all_gene_sum_panel$SYMBOL <- NULL
  counts_all_gene_sum_panel <- as.matrix(counts_all_gene_sum_panel)

  common_g <- intersect(rownames(counts_all_gene), rownames(counts_all_gene_sum_panel))
  cat("[3-QC] genes comparable (one-peak vs sum): ", length(common_g), "\n", sep = "")

  if (length(common_g) > 50) {
    m1 <- rowMeans(counts_all_gene[common_g, , drop = FALSE], na.rm = TRUE)
    m2 <- rowMeans(counts_all_gene_sum_panel[common_g, , drop = FALSE], na.rm = TRUE)
    cat("[3-QC] Spearman corr of gene mean signal (one-peak vs sum; Ilaria genes): ",
        round(stats::cor(m1, m2, method = "spearman", use = "pairwise.complete.obs"), 3), "\n", sep = "")
  }
}

# ---------------------------------------------------------------------
# 4 — Subset to Ilaria genes & z-score per gene across samples
# ---------------------------------------------------------------------
cat("\n[4] Subsetting to Ilaria genes & z-scoring per gene...\n")

genes_in_atac <- intersect(rownames(counts_all_gene), panel_genes)
cat("[4] genes in (ALL one-peak ∩ Ilaria): ", length(genes_in_atac), "\n", sep = "")
if (length(genes_in_atac) == 0L) stop("[4] ERROR: No Ilaria genes found in counts_all_gene.")

atac_mat <- counts_all_gene[genes_in_atac, , drop = FALSE]
cat("[4] atac_mat dim (Ilaria genes × samples): ", paste(dim(atac_mat), collapse = " × "), "\n", sep = "")

atac_z_gene <- t(scale(t(atac_mat)))
atac_z_gene[is.na(atac_z_gene)] <- 0

cat("[4] Example gene z-scores (5 genes × 5 samples):\n")
print(round(atac_z_gene[1:5, 1:5, drop = FALSE], 3))

# QC: marker overlap per cell type
cat("\n[4-QC] Marker overlap per cell_type under ALL one-peak strategy:\n")
marker_overlap <- panel_long %>%
  dplyr::group_by(cell_type) %>%
  dplyr::summarise(
    n_markers_panel   = dplyr::n_distinct(gene),
    n_markers_present = sum(unique(gene) %in% genes_in_atac),
    frac_present      = n_markers_present / n_markers_panel,
    .groups = "drop"
  ) %>%
  dplyr::arrange(dplyr::desc(frac_present))
print(marker_overlap)

# ---------------------------------------------------------------------
# 5 — Raw module matrix (CT × samples)
# ---------------------------------------------------------------------
cat("\n[5] Computing raw module matrix (avg_z_by_ct_ATAC_raw)...\n")

avg_z_by_ct_ATAC_raw <- do.call(
  rbind,
  lapply(ct_levels, function(ct) {

    genes_ct <- panel_long %>%
      dplyr::filter(cell_type == ct, gene %in% genes_in_atac) %>%
      dplyr::pull(gene) %>%
      unique()

    if (length(genes_ct) == 0L) {
      cat("[5] WARNING: no markers present for cell_type ", ct, "; filling NA.\n", sep = "")
      return(rep(NA_real_, ncol(atac_z_gene)))
    }

    colMeans(atac_z_gene[genes_ct, , drop = FALSE], na.rm = TRUE)
  })
)
rownames(avg_z_by_ct_ATAC_raw) <- ct_levels
colnames(avg_z_by_ct_ATAC_raw) <- colnames(atac_z_gene)

cat("[5] avg_z_by_ct_ATAC_raw dim: ", paste(dim(avg_z_by_ct_ATAC_raw), collapse = " × "), "\n", sep = "")
cat("[5] Example RAW module scores (first 5 samples):\n")
print(round(avg_z_by_ct_ATAC_raw[, 1:5, drop = FALSE], 3))

# QC: module SD BEFORE scaling
cat("\n[5-QC] Module SD BEFORE column scaling (per sample):\n")
sd_by_sample <- apply(avg_z_by_ct_ATAC_raw, 2, stats::sd, na.rm = TRUE)
print(summary(sd_by_sample))
low_sd <- names(sd_by_sample)[sd_by_sample < 0.05]
cat("[5-QC] samples with sd < 0.05 across modules: ", length(low_sd), "\n", sep = "")
if (length(low_sd) > 0) print(low_sd)

# ---------------------------------------------------------------------
# 6 — Column-wise scaling across modules (per sample)
# ---------------------------------------------------------------------
cat("\n[6] Column-wise scaling across modules (per sample)...\n")
avg_z_by_ct_ATAC <- scale(avg_z_by_ct_ATAC_raw, center = TRUE, scale = TRUE)

col_means_mod <- apply(avg_z_by_ct_ATAC, 2, mean)
col_sds_mod   <- apply(avg_z_by_ct_ATAC, 2, sd)

cat("[6] Per-sample mean(z) across 7 lineages (after scaling):\n")
print(summary(col_means_mod))
cat("[6] Per-sample sd(z) across 7 lineages (after scaling):\n")
print(summary(col_sds_mod))

all_pos <- apply(avg_z_by_ct_ATAC, 2, function(v) all(v > 0))
cat("[6] Samples with ALL module scores > 0 (should be 0): ", sum(all_pos), "\n", sep = "")

# ---------------------------------------------------------------------
# 7 — Dominant lineage + margins + QC RAW vs SCALED
# ---------------------------------------------------------------------
cat("\n[7] Dominant lineage & margins + QC RAW vs SCALED...\n")

top_idx    <- apply(avg_z_by_ct_ATAC, 2, which.max)
second_idx <- apply(avg_z_by_ct_ATAC, 2, function(v) order(v, decreasing = TRUE)[2])

dominant_tbl_ATAC <- tibble::tibble(
  sample       = colnames(avg_z_by_ct_ATAC),
  top_ct       = ct_levels[top_idx],
  top_score    = avg_z_by_ct_ATAC[cbind(top_idx, seq_along(top_idx))],
  second_ct    = ct_levels[second_idx],
  second_score = avg_z_by_ct_ATAC[cbind(second_idx, seq_along(second_idx))]
) %>%
  dplyr::mutate(margin = top_score - second_score) %>%
  dplyr::left_join(meta_sj %>% dplyr::select(Sample, genotype),
                   by = c("sample" = "Sample"))

cat("[7] top_ct frequencies:\n")
print(sort(table(dominant_tbl_ATAC$top_ct), decreasing = TRUE))
cat("[7] margin summary:\n")
print(summary(dominant_tbl_ATAC$margin))

cat("\n[7-QC] Dominance consistency: RAW vs SCALED...\n")
raw_top  <- apply(avg_z_by_ct_ATAC_raw, 2, which.max)
sc_top   <- apply(avg_z_by_ct_ATAC,     2, which.max)
raw_call <- ct_levels[raw_top]
sc_call  <- ct_levels[sc_top]
cat("  • % same top_ct (RAW vs SCALED): ", round(100 * mean(raw_call == sc_call, na.rm = TRUE), 2), "%\n", sep = "")
cat("  • Confusion (RAW rows vs SCALED cols):\n")
print(table(raw_call, sc_call))

# ---------------------------------------------------------------------
# 8 — Order samples + pheatmap annotations
# ---------------------------------------------------------------------
cat("\n[8] Ordering samples (top_ct → margin → top_score)...\n")

col_order <- order(
  factor(dominant_tbl_ATAC$top_ct, levels = ct_levels),
  -dominant_tbl_ATAC$margin,
  -dominant_tbl_ATAC$top_score
)

avg_z_by_ct_ord  <- avg_z_by_ct_ATAC[, col_order, drop = FALSE]
dominant_tbl_ord <- dominant_tbl_ATAC[col_order, ]

margin_bins <- cut(
  dominant_tbl_ord$margin,
  breaks = quantile(dominant_tbl_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
  include.lowest = TRUE,
  labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

ann_col_ATAC <- data.frame(
  top_ct    = factor(dominant_tbl_ord$top_ct, levels = ct_levels),
  margin    = margin_bins,
  genotype  = dominant_tbl_ord$genotype,
  row.names = dominant_tbl_ord$sample,
  stringsAsFactors = FALSE
)

# Palettes (reuse if present; otherwise define)
if (!exists("cell_type_colors")) {
  cell_type_colors <- c(
    HSCMPP        = "#fb8072",
    GMP           = "#bebada",
    pDC           = "#ffd92f",
    EarlyLymphoid = "#f781bf",
    ProB          = "#ff33ff",
    PreB          = "#00e5c0",
    B             = "#00bfff"
  )
}
if (!exists("margin_colors")) {
  margin_colors <- c(
    "Q1 (lowest)"  = "#c7e9c0",
    "Q2"           = "#a1d99b",
    "Q3"           = "#74c476",
    "Q4 (highest)" = "#238b45"
  )
}
if (!exists("genotype_colors")) {
  genotype_colors <- c(
    TT = "#f65e0dff",
    TC = "#0c2e18ff",
    CC = "#d7a419ff"
  )
}

# ---------------------------------------------------------------------
# 9 — Heatmap
# ---------------------------------------------------------------------
cat("\n[9] Drawing ALL-peaks dominance heatmap...\n")

z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)

pheatmap::pheatmap(
  avg_z_by_ct_ord,
  color             = z_col_fun,
  cluster_rows      = FALSE,
  cluster_cols      = FALSE,
  show_rownames     = TRUE,
  show_colnames     = FALSE,
  annotation_col    = ann_col_ATAC,
  annotation_colors = list(
    top_ct   = cell_type_colors,
    margin   = margin_colors,
    genotype = genotype_colors
  ),
  border_color = NA,
  main = "ATAC module activity Ilaria's markers (ALL peaks; one peak/gene = closest-to-TSS; column-scaled)"
)
```

### 14.1 Promoters only

```{r}
# =====================================================================
# ATAC — PROMOTER-ONLY ILARIA DOMINANCE MAP (TSS-WINDOW DEFINITION)
#        + ONE-PEAK-PER-GENE (closest-to-TSS) to enforce "one gene = one vote"
#        + QC for the new strategy
#
# Promoter definition here is NOT string-based ("Promoter") — instead:
#   promoter peak := abs(distanceToTSS) <= PROMOTER_WINDOW_BP
#
# Gene-level promoter score here is NOT "sum of promoter peaks" — instead:
#   gene promoter peak := per gene, select the single peak with min abs(distanceToTSS)
#   => prevents genes with many promoter peaks from having more "votes"
#
# Requires:
#   - counts   : matrix [peaks × samples] (ATAC peak-level counts)
#   - anno_df  : data.frame with peak_id, SYMBOL, distanceToTSS, annotation (optional)
#   - meta_sj  : data.frame with Sample, genotype
#   - panel_long, panel_genes, ct_levels (or it will load panel)
#
# Produces:
#   - prom_counts_all_gene          (promoter-only gene matrix; one peak per gene)
#   - prom_avg_z_by_ct_ATAC_raw    (raw module scores)
#   - prom_avg_z_by_ct_ATAC        (column-scaled module scores)
#   - prom_dominant_tbl_ATAC       (winner + margin)
#   - prom_ann_col_ATAC            (pheatmap annotations)
#   - promoter-only dominance heatmap
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(readr)
    library(tibble)
    library(pheatmap)
    library(stringr)
})

cat("\n===============================================================\n")
cat("ATAC ILARIA PIPELINE — PROMOTER-ONLY (TSS WINDOW), ONE PEAK/GENE\n")
cat("===============================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Parameters + sanity checks
# ---------------------------------------------------------------------
PROMOTER_WINDOW_BP <- 2000  # e.g., 1000 or 2000; keep constant across runs

if (!exists("counts"))  stop("[PROM-TSS] ERROR: `counts` (peak × sample matrix) not found.")
if (!exists("anno_df")) stop("[PROM-TSS] ERROR: `anno_df` (annotation table) not found.")
if (!exists("meta_sj")) stop("[PROM-TSS] ERROR: `meta_sj` (Sample + genotype) not found.")

cat("[0] PROMOTER_WINDOW_BP: ±", PROMOTER_WINDOW_BP, "bp around TSS\n", sep = "")
cat("[0] counts dim (peaks × samples): ", paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols): ", paste(dim(anno_df), collapse = " × "), "\n", sep = "")

stopifnot(!is.null(rownames(counts)), !is.null(colnames(counts)))
stopifnot(all(c("peak_id", "SYMBOL") %in% colnames(anno_df)))

# Require distanceToTSS for the new strategy
if (!("distanceToTSS" %in% colnames(anno_df))) {
    stop("[PROM-TSS] ERROR: anno_df must contain `distanceToTSS` for TSS-window promoter definition.")
}

# ---------------------------------------------------------------------
# 1 — Load & clean Ilaria panel (if not already loaded)
# ---------------------------------------------------------------------
if (!exists("panel_long") || !exists("panel_genes") || !exists("ct_levels")) {
    
    cat("\n[1] Loading curated Ilaria panel (objects not found)...\n")
    
    panel_path <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/clean_ilarias_700_genes.csv"
    cat("    • panel_path = ", panel_path, "\n", sep = "")
    
    df_raw <- readr::read_csv(panel_path, show_col_types = FALSE)
    
    df_updated <- df_raw %>%
        dplyr::mutate(
            dplyr::across(
                .cols = dplyr::everything(),
                .fns  = ~ {
                    x <- as.character(.)
                    x <- stringr::str_trim(x)
                    dplyr::na_if(x, "")
                }
            )
        )
    
    panel_long <- df_updated %>%
        tidyr::pivot_longer(
            cols      = dplyr::everything(),
            names_to  = "cell_type",
            values_to = "gene"
        ) %>%
        dplyr::filter(!is.na(gene), gene != "")
    
    panel_genes <- unique(panel_long$gene)
    ct_levels   <- colnames(df_updated)
    
    cat("[1] Panel loaded:\n")
    cat("    • unique marker genes : ", length(panel_genes), "\n", sep = "")
    cat("    • cell_type levels    : ", paste(ct_levels, collapse = " → "), "\n", sep = "")
}

# ---------------------------------------------------------------------
# 2 — QC + Build promoter peak set by TSS-window (abs(distanceToTSS) <= window)
# ---------------------------------------------------------------------
cat("\n[2] Defining promoter peaks by TSS-window using distanceToTSS...\n")

anno_tss <- anno_df %>%
    dplyr::mutate(
        .tss_dist = suppressWarnings(as.numeric(as.character(.data$distanceToTSS))),
        .abs_tss  = abs(.tss_dist)
    )

cat("[2] QC: distanceToTSS numeric coercion summary (abs):\n")
print(summary(anno_tss$.abs_tss))

n_na_dist <- sum(is.na(anno_tss$.abs_tss))
cat("[2] QC: peaks with NA distanceToTSS after coercion: ", n_na_dist, "\n", sep = "")

prom_tss_df <- anno_tss %>%
    dplyr::filter(!is.na(.abs_tss), .abs_tss <= PROMOTER_WINDOW_BP) %>%
    dplyr::filter(!is.na(SYMBOL), SYMBOL != "") %>%
    dplyr::select(peak_id, SYMBOL, .tss_dist, .abs_tss, dplyr::any_of("annotation")) %>%
    dplyr::distinct()

cat("[2] promoter peaks in TSS window (with SYMBOL): ", nrow(prom_tss_df), "\n", sep = "")
cat("[2] unique SYMBOL captured by TSS-window promoters: ",
    length(unique(prom_tss_df$SYMBOL)), "\n", sep = "")

# Optional QC: how much does this differ from string-based promoter annotation?
if ("annotation" %in% colnames(prom_tss_df)) {
    cat("\n[2-QC] Overlap check: TSS-window promoters vs annotation containing 'Promoter'\n")
    tab_prom <- prom_tss_df %>%
        dplyr::mutate(.annot_prom = stringr::str_detect(.data$annotation, "Promoter")) %>%
        dplyr::count(.annot_prom)
    print(tab_prom)
    
    cat("[2-QC] annotation categories within TSS-window (top 10):\n")
    print(
        prom_tss_df %>%
            dplyr::count(annotation, sort = TRUE) %>%
            utils::head(10)
    )
} else {
    cat("\n[2-QC] NOTE: anno_df has no `annotation` column; skipping string-based overlap QC.\n")
}

# Ensure overlap with counts
prom_common_peaks <- intersect(rownames(counts), prom_tss_df$peak_id)
cat("\n[2] promoter peaks overlapping rownames(counts): ", length(prom_common_peaks), "\n", sep = "")
if (length(prom_common_peaks) == 0L) stop("[2] ERROR: No overlap between TSS-window promoter peaks and rownames(counts).")

# ---------------------------------------------------------------------
# 3 — QC: peaks-per-gene in promoter window + choose ONE peak per gene (closest to TSS)
# ---------------------------------------------------------------------
cat("\n[3] QC: peaks-per-gene within TSS-window + selecting closest peak per gene...\n")

peaks_per_gene_prom <- prom_tss_df %>%
    dplyr::filter(peak_id %in% prom_common_peaks) %>%
    dplyr::count(SYMBOL, name = "n_prom_peaks") %>%
    dplyr::arrange(dplyr::desc(n_prom_peaks))

cat("[3] peaks-per-gene (TSS-window) summary:\n")
print(summary(peaks_per_gene_prom$n_prom_peaks))

cat("[3] top genes by # promoter-window peaks (first 10):\n")
print(utils::head(peaks_per_gene_prom, 10))

# Choose the single closest-to-TSS peak per gene
prom_gene_map_one <- prom_tss_df %>%
    dplyr::filter(peak_id %in% prom_common_peaks) %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::slice_min(.abs_tss, with_ties = FALSE) %>%
    dplyr::ungroup() %>%
    dplyr::select(SYMBOL, peak_id, .tss_dist, .abs_tss) %>%
    dplyr::distinct()

cat("[3] selected 1 peak/gene (closest-to-TSS): ", nrow(prom_gene_map_one), "\n", sep = "")
stopifnot(!anyDuplicated(prom_gene_map_one$SYMBOL))

# QC: any peak maps to multiple genes (should usually be 0 if your anno_df is clean)
genes_per_peak_prom <- prom_gene_map_one %>%
    dplyr::count(peak_id, name = "n_genes") %>%
    dplyr::arrange(dplyr::desc(n_genes))

n_ambig_peak <- sum(genes_per_peak_prom$n_genes > 1)
cat("[3-QC] peaks mapping to >1 gene among selected closest peaks: ", n_ambig_peak, "\n", sep = "")
if (n_ambig_peak > 0) {
    cat("[3-QC] WARNING: ambiguous peak→gene mapping detected (first 10):\n")
    print(utils::head(dplyr::filter(genes_per_peak_prom, n_genes > 1), 10))
    cat("        Consider forcing a unique assignment upstream.\n")
}

# ---------------------------------------------------------------------
# 4 — Build promoter-only gene matrix (one peak per gene)
# ---------------------------------------------------------------------
cat("\n[4] Building prom_counts_all_gene (genes × samples) using ONE peak/gene...\n")

prom_counts_all_gene <- counts[prom_gene_map_one$peak_id, , drop = FALSE]
rownames(prom_counts_all_gene) <- prom_gene_map_one$SYMBOL

cat("[4] prom_counts_all_gene dim (genes × samples): ", paste(dim(prom_counts_all_gene), collapse = " × "), "\n", sep = "")

# QC: quick sanity check for missing/duplicated rownames
stopifnot(!anyDuplicated(rownames(prom_counts_all_gene)))
stopifnot(all(colnames(prom_counts_all_gene) == colnames(counts)))

# OPTIONAL QC: compare "one peak/gene" vs "sum of promoter peaks/gene"
# (kept as QC only — not used downstream unless you swap it in)
cat("\n[4-QC] OPTIONAL: building sum-of-promoter-peaks gene matrix for comparison...\n")
prom_counts_df <- as.data.frame(counts)
prom_counts_df$peak_id <- rownames(prom_counts_df)

prom_sum_join <- prom_tss_df %>%
    dplyr::filter(peak_id %in% prom_common_peaks) %>%
    dplyr::select(peak_id, SYMBOL) %>%
    dplyr::left_join(prom_counts_df, by = "peak_id", relationship = "many-to-many")

prom_counts_all_gene_sum <- prom_sum_join %>%
    dplyr::select(-peak_id) %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::summarise(dplyr::across(dplyr::where(is.numeric), sum), .groups = "drop") %>%
    as.data.frame()

rownames(prom_counts_all_gene_sum) <- prom_counts_all_gene_sum$SYMBOL
prom_counts_all_gene_sum$SYMBOL <- NULL
prom_counts_all_gene_sum <- as.matrix(prom_counts_all_gene_sum)

common_genes_compare <- intersect(rownames(prom_counts_all_gene), rownames(prom_counts_all_gene_sum))
cat("[4-QC] genes comparable (one-peak vs sum): ", length(common_genes_compare), "\n", sep = "")

if (length(common_genes_compare) > 50) {
    # Correlate per-gene mean signal across samples as a quick “are these wildly different?” check
    m1 <- rowMeans(prom_counts_all_gene[common_genes_compare, , drop = FALSE], na.rm = TRUE)
    m2 <- rowMeans(prom_counts_all_gene_sum[common_genes_compare, , drop = FALSE], na.rm = TRUE)
    cat("[4-QC] Spearman corr of gene mean signal (one-peak vs sum): ",
        round(stats::cor(m1, m2, method = "spearman", use = "pairwise.complete.obs"), 3), "\n", sep = "")
} else {
    cat("[4-QC] Skipping correlation (too few comparable genes).\n")
}

# ---------------------------------------------------------------------
# 5 — Subset promoter matrix to Ilaria genes & gene-level z-score
# ---------------------------------------------------------------------
cat("\n[5] Subsetting promoter matrix to Ilaria genes and z-scoring per gene...\n")

prom_genes_in_atac <- intersect(rownames(prom_counts_all_gene), panel_genes)
cat("[5] genes in (TSS-window promoters ∩ Ilaria): ", length(prom_genes_in_atac), "\n", sep = "")

if (length(prom_genes_in_atac) == 0L) stop("[5] ERROR: No Ilaria genes found in promoter-only gene matrix.")

prom_atac_mat <- prom_counts_all_gene[prom_genes_in_atac, , drop = FALSE]
cat("[5] prom_atac_mat dim (Ilaria genes × samples): ", paste(dim(prom_atac_mat), collapse = " × "), "\n", sep = "")

prom_atac_z_gene <- t(scale(t(prom_atac_mat)))
prom_atac_z_gene[is.na(prom_atac_z_gene)] <- 0

cat("[5] Example promoter gene z-scores (5 genes × 5 samples):\n")
print(round(prom_atac_z_gene[1:5, 1:5, drop = FALSE], 3))

# QC: marker coverage per cell type under this promoter definition
cat("\n[5-QC] Marker overlap per cell_type under TSS-window promoters:\n")
marker_overlap <- panel_long %>%
    dplyr::group_by(cell_type) %>%
    dplyr::summarise(
        n_markers_panel   = dplyr::n_distinct(gene),
        n_markers_present = sum(unique(gene) %in% prom_genes_in_atac),
        frac_present      = n_markers_present / n_markers_panel,
        .groups = "drop"
    ) %>%
    dplyr::arrange(dplyr::desc(frac_present))
print(marker_overlap)

# ---------------------------------------------------------------------
# 6 — Raw module matrix: prom_avg_z_by_ct_ATAC_raw (no expansion join needed)
# ---------------------------------------------------------------------
cat("\n[6] Computing raw module matrix (prom_avg_z_by_ct_ATAC_raw) from z-scored genes...\n")

prom_avg_z_by_ct_ATAC_raw <- do.call(
    rbind,
    lapply(ct_levels, function(ct) {
        genes_ct <- panel_long %>%
            dplyr::filter(cell_type == ct, gene %in% prom_genes_in_atac) %>%
            dplyr::pull(gene) %>%
            unique()
        
        if (length(genes_ct) == 0L) {
            cat("[6] WARNING: no promoter markers available for cell_type ", ct, "; filling with NA.\n", sep = "")
            return(rep(NA_real_, ncol(prom_atac_z_gene)))
        }
        colMeans(prom_atac_z_gene[genes_ct, , drop = FALSE], na.rm = TRUE)
    })
)
rownames(prom_avg_z_by_ct_ATAC_raw) <- ct_levels
colnames(prom_avg_z_by_ct_ATAC_raw) <- colnames(prom_atac_z_gene)

cat("[6] prom_avg_z_by_ct_ATAC_raw dim (CT × samples): ",
    paste(dim(prom_avg_z_by_ct_ATAC_raw), collapse = " × "), "\n", sep = "")
cat("[6] Example RAW promoter module scores (first 5 samples):\n")
print(round(prom_avg_z_by_ct_ATAC_raw[, 1:5, drop = FALSE], 3))

# QC: module SD BEFORE column scaling (critical)
cat("\n[6-QC] Module SD BEFORE column scaling (across CTs, per sample):\n")
sd_by_sample <- apply(prom_avg_z_by_ct_ATAC_raw, 2, stats::sd, na.rm = TRUE)
print(summary(sd_by_sample))

low_sd <- names(sd_by_sample)[sd_by_sample < 0.05]
cat("[6-QC] samples with sd < 0.05 across modules (scaling can amplify noise): ", length(low_sd), "\n", sep = "")
if (length(low_sd) > 0) print(low_sd)

# ---------------------------------------------------------------------
# 7 — Column-wise scaling across modules (per sample)
# ---------------------------------------------------------------------
cat("\n[7] Column-wise scaling across the 7 lineages (TSS-window promoters)...\n")
cat("    This standardizes each sample across CT modules (mean~0, sd~1).\n\n")

prom_avg_z_by_ct_ATAC <- scale(prom_avg_z_by_ct_ATAC_raw, center = TRUE, scale = TRUE)

col_means_mod_prom <- apply(prom_avg_z_by_ct_ATAC, 2, mean)
col_sds_mod_prom   <- apply(prom_avg_z_by_ct_ATAC, 2, sd)

cat("[7] Per-sample mean(z) across 7 lineages (after scaling):\n")
print(summary(col_means_mod_prom))
cat("[7] Per-sample sd(z) across 7 lineages (after scaling):\n")
print(summary(col_sds_mod_prom))

all_pos_prom <- apply(prom_avg_z_by_ct_ATAC, 2, function(v) all(v > 0))
cat("[7] Samples with ALL module scores > 0 (should be ~0): ", sum(all_pos_prom), "\n", sep = "")

cat("[7] Example SCALED promoter module scores (first 5 samples):\n")
print(round(prom_avg_z_by_ct_ATAC[, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 8 — Dominant lineage + margins (scaled)
# ---------------------------------------------------------------------
cat("\n[8] Computing dominant lineage & margins (TSS-window promoters, scaled)...\n")

prom_top_idx    <- apply(prom_avg_z_by_ct_ATAC, 2, which.max)
prom_second_idx <- apply(prom_avg_z_by_ct_ATAC, 2, function(v) order(v, decreasing = TRUE)[2])

prom_dominant_tbl_ATAC <- tibble::tibble(
    sample       = colnames(prom_avg_z_by_ct_ATAC),
    top_ct       = ct_levels[prom_top_idx],
    top_score    = prom_avg_z_by_ct_ATAC[cbind(prom_top_idx, seq_along(prom_top_idx))],
    second_ct    = ct_levels[prom_second_idx],
    second_score = prom_avg_z_by_ct_ATAC[cbind(prom_second_idx, seq_along(prom_second_idx))]
) %>%
    dplyr::mutate(margin = top_score - second_score) %>%
    dplyr::left_join(meta_sj %>% dplyr::select(Sample, genotype),
                     by = c("sample" = "Sample"))

cat("[8] First 10 promoter dominance calls:\n")
print(utils::head(prom_dominant_tbl_ATAC, 10))

cat("\n[8] Frequency of top_ct assignments:\n")
print(sort(table(prom_dominant_tbl_ATAC$top_ct), decreasing = TRUE))

cat("\n[8] Margin summary:\n")
print(summary(prom_dominant_tbl_ATAC$margin))

# ---------------------------------------------------------------------
# 9 — QC: Dominance consistency RAW vs SCALED (are you forcing winners?)
# ---------------------------------------------------------------------
cat("\n[9-QC] Dominance consistency: RAW vs COLUMN-SCALED...\n")

raw_top <- apply(prom_avg_z_by_ct_ATAC_raw, 2, which.max)
sc_top  <- apply(prom_avg_z_by_ct_ATAC,     2, which.max)

raw_call <- ct_levels[raw_top]
sc_call  <- ct_levels[sc_top]

concord <- mean(raw_call == sc_call, na.rm = TRUE)
cat("  • % samples with same top_ct (RAW vs SCALED): ", round(100 * concord, 2), "%\n", sep = "")

cat("  • Confusion (RAW rows vs SCALED cols):\n")
print(table(raw_call, sc_call))

# ---------------------------------------------------------------------
# 10 — Order samples: top_ct → margin → top_score
# ---------------------------------------------------------------------
cat("\n[10] Ordering samples (top_ct → margin → top_score)...\n")

prom_col_order <- order(
    factor(prom_dominant_tbl_ATAC$top_ct, levels = ct_levels),
    -prom_dominant_tbl_ATAC$margin,
    -prom_dominant_tbl_ATAC$top_score
)

prom_avg_z_by_ct_ord  <- prom_avg_z_by_ct_ATAC[, prom_col_order, drop = FALSE]
prom_dominant_tbl_ord <- prom_dominant_tbl_ATAC[prom_col_order, ]

cat("[10] prom_avg_z_by_ct_ord dim: ", paste(dim(prom_avg_z_by_ct_ord), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 11 — Build annotations for pheatmap
# ---------------------------------------------------------------------
cat("\n[11] Building prom_ann_col_ATAC for pheatmap...\n")

prom_margin_bins <- cut(
    prom_dominant_tbl_ord$margin,
    breaks = quantile(prom_dominant_tbl_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

prom_ann_col_ATAC <- data.frame(
    top_ct   = factor(prom_dominant_tbl_ord$top_ct, levels = ct_levels),
    margin   = prom_margin_bins,
    genotype = prom_dominant_tbl_ord$genotype,
    row.names = prom_dominant_tbl_ord$sample,
    stringsAsFactors = FALSE
)

cat("[11] prom_ann_col_ATAC head:\n")
print(utils::head(prom_ann_col_ATAC, 10))

# Palettes (reuse if present; otherwise define)
if (!exists("cell_type_colors")) {
    cell_type_colors <- c(
        HSCMPP        = "#fb8072",
        GMP           = "#bebada",
        pDC           = "#ffd92f",
        EarlyLymphoid = "#f781bf",
        ProB          = "#ff33ff",
        PreB          = "#00e5c0",
        B             = "#00bfff"
    )
}
if (!exists("margin_colors")) {
    margin_colors <- c(
        "Q1 (lowest)"  = "#c7e9c0",
        "Q2"           = "#a1d99b",
        "Q3"           = "#74c476",
        "Q4 (highest)" = "#238b45"
    )
}
if (!exists("genotype_colors")) {
    genotype_colors <- c(
        TT = "#f65e0dff",
        TC = "#0c2e18ff",
        CC = "#d7a419ff"
    )
}

# ---------------------------------------------------------------------
# 12 — Final promoter-only dominance heatmap
# ---------------------------------------------------------------------
cat("\n[12] Drawing promoter-only ATAC dominance heatmap (column-scaled)...\n")

prom_z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)

pheatmap::pheatmap(
    prom_avg_z_by_ct_ord,
    color              = prom_z_col_fun,
    cluster_rows       = FALSE,
    cluster_cols       = FALSE,
    show_rownames      = TRUE,
    show_colnames      = FALSE,
    annotation_col     = prom_ann_col_ATAC,
    annotation_colors  = list(
        top_ct   = cell_type_colors,
        margin   = margin_colors,
        genotype = genotype_colors
    ),
    border_color = NA,
    main = paste0("ATAC module activity of Ilaria's markers (PROMOTERS = |distanceToTSS| ≤ ",
                  PROMOTER_WINDOW_BP, "bp; ONE peak/gene; column-scaled)")
)

cat("\n[PROM-TSS] DONE — promoters defined by fixed TSS window; one peak per gene.\n")
cat("           QC printed above: distance distributions, peaks-per-gene,\n")
cat("           marker overlap, low-SD samples, RAW vs SCALED concordance.\n")
cat("===============================================================\n\n")

```

### 14.2 Enhancers only
```{r}
# =====================================================================
# ATAC — ENHANCER-ONLY ILARIA DOMINANCE MAP (TSS-WINDOW COMPLEMENT)
#        + ONE-PEAK-PER-GENE (closest enhancer peak per gene)
#        + QC for this strategy
#
# Enhancer definition (explicit, reviewer-proof):
#   enhancer peak := abs(distanceToTSS) > PROMOTER_WINDOW_BP
#
# Gene-level enhancer score (avoid gene-size bias):
#   per gene, select single enhancer peak with minimal abs(distanceToTSS)
#   among enhancer peaks => "closest enhancer" = one gene = one vote
#
# Requires:
#   - counts   : matrix [peaks × samples]
#   - anno_df  : data.frame with peak_id, SYMBOL, distanceToTSS (annotation optional)
#   - meta_sj  : data.frame with Sample, genotype
#   - panel_long, panel_genes, ct_levels (or it will load panel)
# =====================================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(readr)
  library(tibble)
  library(pheatmap)
  library(stringr)
})

cat("\n[ILARIA/ENH-TSS] =============================================\n")
cat("[ILARIA/ENH-TSS] ENHANCERS — |distanceToTSS| > window; one peak/gene\n")

# ---------------------------------------------------------------------
# 0 — Parameters + sanity checks
# ---------------------------------------------------------------------
PROMOTER_WINDOW_BP <- 2000  # keep consistent with your promoter chunk

if (!exists("counts"))  stop("[ILARIA/ENH-TSS] ERROR: `counts` not found.")
if (!exists("anno_df")) stop("[ILARIA/ENH-TSS] ERROR: `anno_df` not found.")
if (!exists("meta_sj")) stop("[ILARIA/ENH-TSS] ERROR: `meta_sj` not found.")

stopifnot(!is.null(rownames(counts)), !is.null(colnames(counts)))
stopifnot(all(c("peak_id", "SYMBOL") %in% colnames(anno_df)))
if (!("distanceToTSS" %in% colnames(anno_df))) {
  stop("[ILARIA/ENH-TSS] ERROR: anno_df must contain `distanceToTSS` for TSS-window complement definition.")
}

cat("[0] PROMOTER_WINDOW_BP: ±", PROMOTER_WINDOW_BP, "bp\n", sep = "")
cat("[0] counts dim (peaks × samples): ", paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols): ", paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 1 — Load Ilaria panel (if needed)
# ---------------------------------------------------------------------
if (!exists("panel_long") || !exists("panel_genes") || !exists("ct_levels")) {

  cat("\n[1] Loading curated Ilaria panel (objects not found)...\n")

  panel_path <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/clean_ilarias_700_genes.csv"
  cat("    • panel_path = ", panel_path, "\n", sep = "")

  df_raw <- readr::read_csv(panel_path, show_col_types = FALSE)

  df_updated <- df_raw %>%
    dplyr::mutate(
      dplyr::across(
        .cols = dplyr::everything(),
        .fns  = ~ {
          x <- as.character(.)
          x <- stringr::str_trim(x)
          dplyr::na_if(x, "")
        }
      )
    )

  panel_long <- df_updated %>%
    tidyr::pivot_longer(
      cols      = dplyr::everything(),
      names_to  = "cell_type",
      values_to = "gene"
    ) %>%
    dplyr::filter(!is.na(gene), gene != "")

  panel_genes <- unique(panel_long$gene)
  ct_levels   <- colnames(df_updated)

  cat("[1] Panel loaded:\n")
  cat("    • unique marker genes : ", length(panel_genes), "\n", sep = "")
  cat("    • cell_type levels    : ", paste(ct_levels, collapse = " → "), "\n", sep = "")
}

# ---------------------------------------------------------------------
# 2 — Define enhancer peaks by TSS-window complement + QC
# ---------------------------------------------------------------------
cat("\n[2] Defining enhancer peaks by |distanceToTSS| > PROMOTER_WINDOW_BP...\n")

anno_tss <- anno_df %>%
  dplyr::mutate(
    .tss_dist = suppressWarnings(as.numeric(as.character(.data$distanceToTSS))),
    .abs_tss  = abs(.tss_dist)
  )

cat("[2-QC] distanceToTSS |abs| summary:\n")
print(summary(anno_tss$.abs_tss))

n_na_dist <- sum(is.na(anno_tss$.abs_tss))
cat("[2-QC] peaks with NA distanceToTSS after coercion: ", n_na_dist, "\n", sep = "")

enh_tss_df <- anno_tss %>%
  dplyr::filter(!is.na(.abs_tss), .abs_tss > PROMOTER_WINDOW_BP) %>%
  dplyr::filter(!is.na(SYMBOL), SYMBOL != "") %>%
  dplyr::select(peak_id, SYMBOL, .tss_dist, .abs_tss, dplyr::any_of("annotation")) %>%
  dplyr::distinct()

cat("[2] enhancer peaks (TSS-complement) with SYMBOL: ", nrow(enh_tss_df), "\n", sep = "")
cat("[2] unique SYMBOL captured by enhancers: ", length(unique(enh_tss_df$SYMBOL)), "\n", sep = "")

# Optional QC: how many of these would have been labeled "Promoter" by annotation?
if ("annotation" %in% colnames(enh_tss_df)) {
  cat("\n[2-QC] Overlap check: enhancer-by-distance vs annotation containing 'Promoter'\n")
  tab_prom <- enh_tss_df %>%
    dplyr::mutate(.annot_prom = stringr::str_detect(.data$annotation, "Promoter")) %>%
    dplyr::count(.annot_prom)
  print(tab_prom)

  cat("[2-QC] annotation categories within enhancer-by-distance (top 10):\n")
  print(
    enh_tss_df %>%
      dplyr::count(annotation, sort = TRUE) %>%
      utils::head(10)
  )
}

enh_common_peaks <- intersect(rownames(counts), enh_tss_df$peak_id)
cat("[2] enhancer peaks overlapping rownames(counts): ", length(enh_common_peaks), "\n", sep = "")
if (length(enh_common_peaks) == 0L) stop("[2] ERROR: No overlap between enhancer peaks and rownames(counts).")

# ---------------------------------------------------------------------
# 3 — QC: peaks-per-gene among enhancers + choose ONE enhancer peak per gene
# ---------------------------------------------------------------------
cat("\n[3] QC: peaks-per-gene (enhancers) + selecting closest enhancer peak per gene...\n")

peaks_per_gene_enh <- enh_tss_df %>%
  dplyr::filter(peak_id %in% enh_common_peaks) %>%
  dplyr::count(SYMBOL, name = "n_enh_peaks") %>%
  dplyr::arrange(dplyr::desc(n_enh_peaks))

cat("[3-QC] peaks-per-gene summary (enhancers):\n")
print(summary(peaks_per_gene_enh$n_enh_peaks))
cat("[3-QC] top genes by # enhancer peaks (first 10):\n")
print(utils::head(peaks_per_gene_enh, 10))

# One enhancer peak per gene: closest enhancer (min abs(distanceToTSS) among enhancers)
enh_gene_map_one <- enh_tss_df %>%
  dplyr::filter(peak_id %in% enh_common_peaks) %>%
  dplyr::group_by(SYMBOL) %>%
  dplyr::slice_min(.abs_tss, with_ties = FALSE) %>%
  dplyr::ungroup() %>%
  dplyr::select(SYMBOL, peak_id, .tss_dist, .abs_tss) %>%
  dplyr::distinct()

cat("[3] selected 1 enhancer peak/gene (closest enhancer): ", nrow(enh_gene_map_one), "\n", sep = "")
stopifnot(!anyDuplicated(enh_gene_map_one$SYMBOL))

genes_per_peak_enh <- enh_gene_map_one %>%
  dplyr::count(peak_id, name = "n_genes") %>%
  dplyr::arrange(dplyr::desc(n_genes))

n_ambig_peak <- sum(genes_per_peak_enh$n_genes > 1)
cat("[3-QC] selected enhancer peaks mapping to >1 gene: ", n_ambig_peak, "\n", sep = "")

# ---------------------------------------------------------------------
# 4 — Build enhancer gene matrix (genes × samples)
# ---------------------------------------------------------------------
cat("\n[4] Building enh_counts_all_gene (genes × samples) using ONE enhancer peak/gene...\n")

enh_counts_all_gene <- counts[enh_gene_map_one$peak_id, , drop = FALSE]
rownames(enh_counts_all_gene) <- enh_gene_map_one$SYMBOL

cat("[4] enh_counts_all_gene dim: ", paste(dim(enh_counts_all_gene), collapse = " × "), "\n", sep = "")
stopifnot(!anyDuplicated(rownames(enh_counts_all_gene)))
stopifnot(all(colnames(enh_counts_all_gene) == colnames(counts)))

# ---------------------------------------------------------------------
# 5 — Subset to Ilaria genes & z-score per gene
# ---------------------------------------------------------------------
cat("\n[5] Subsetting enhancer gene matrix to Ilaria genes & z-scoring...\n")

enh_genes_in_atac <- intersect(rownames(enh_counts_all_gene), panel_genes)
cat("[5] genes in (enhancers one-peak ∩ Ilaria): ", length(enh_genes_in_atac), "\n", sep = "")
if (length(enh_genes_in_atac) == 0L) stop("[5] ERROR: No Ilaria genes found in enhancer-only gene matrix.")

enh_mat <- enh_counts_all_gene[enh_genes_in_atac, , drop = FALSE]
cat("[5] enh_mat dim (Ilaria genes × samples): ", paste(dim(enh_mat), collapse = " × "), "\n", sep = "")

enh_z_gene <- t(scale(t(enh_mat)))
enh_z_gene[is.na(enh_z_gene)] <- 0

cat("[5] Example enhancer gene z-scores (5 genes × 5 samples):\n")
print(round(enh_z_gene[1:5, 1:5, drop = FALSE], 3))

cat("\n[5-QC] Marker overlap per cell_type under enhancer-only one-peak strategy:\n")
marker_overlap <- panel_long %>%
  dplyr::group_by(cell_type) %>%
  dplyr::summarise(
    n_markers_panel   = dplyr::n_distinct(gene),
    n_markers_present = sum(unique(gene) %in% enh_genes_in_atac),
    frac_present      = n_markers_present / n_markers_panel,
    .groups = "drop"
  ) %>%
  dplyr::arrange(dplyr::desc(frac_present))
print(marker_overlap)

# ---------------------------------------------------------------------
# 6 — Raw module matrix (CT × samples) + QC low-SD samples
# ---------------------------------------------------------------------
cat("\n[6] Computing enhancer-only raw module matrix (enh_avg_z_by_ct_ATAC_raw)...\n")

enh_avg_z_by_ct_ATAC_raw <- do.call(
  rbind,
  lapply(ct_levels, function(ct) {

    genes_ct <- panel_long %>%
      dplyr::filter(cell_type == ct, gene %in% enh_genes_in_atac) %>%
      dplyr::pull(gene) %>%
      unique()

    if (length(genes_ct) == 0L) {
      cat("[6] WARNING: no enhancer markers present for ", ct, "; filling NA.\n", sep = "")
      return(rep(NA_real_, ncol(enh_z_gene)))
    }

    colMeans(enh_z_gene[genes_ct, , drop = FALSE], na.rm = TRUE)
  })
)
rownames(enh_avg_z_by_ct_ATAC_raw) <- ct_levels
colnames(enh_avg_z_by_ct_ATAC_raw) <- colnames(enh_z_gene)

cat("[6] enh_avg_z_by_ct_ATAC_raw dim: ", paste(dim(enh_avg_z_by_ct_ATAC_raw), collapse = " × "), "\n", sep = "")
cat("[6] Example RAW enhancer module scores (first 5 samples):\n")
print(round(enh_avg_z_by_ct_ATAC_raw[, 1:5, drop = FALSE], 3))

cat("\n[6-QC] Module SD BEFORE column scaling (per sample):\n")
sd_by_sample <- apply(enh_avg_z_by_ct_ATAC_raw, 2, stats::sd, na.rm = TRUE)
print(summary(sd_by_sample))
low_sd <- names(sd_by_sample)[sd_by_sample < 0.05]
cat("[6-QC] samples with sd < 0.05 across modules: ", length(low_sd), "\n", sep = "")
if (length(low_sd) > 0) print(low_sd)

# ---------------------------------------------------------------------
# 7 — Column-wise scaling across modules + QC
# ---------------------------------------------------------------------
cat("\n[7] Column-wise scaling across enhancer-only modules (per sample)...\n")

enh_avg_z_by_ct_ATAC <- scale(enh_avg_z_by_ct_ATAC_raw, center = TRUE, scale = TRUE)

col_means_mod <- apply(enh_avg_z_by_ct_ATAC, 2, mean)
col_sds_mod   <- apply(enh_avg_z_by_ct_ATAC, 2, sd)

cat("[7] Per-sample mean(z) across modules (after scaling):\n")
print(summary(col_means_mod))
cat("[7] Per-sample sd(z) across modules (after scaling):\n")
print(summary(col_sds_mod))

all_pos <- apply(enh_avg_z_by_ct_ATAC, 2, function(v) all(v > 0))
cat("[7] Samples with ALL enhancer module scores > 0 (should be 0): ", sum(all_pos), "\n", sep = "")

# ---------------------------------------------------------------------
# 8 — Dominant lineage + margins + QC RAW vs SCALED
# ---------------------------------------------------------------------
cat("\n[8] Dominant lineage & margins (enhancer-only) + QC RAW vs SCALED...\n")

top_idx    <- apply(enh_avg_z_by_ct_ATAC, 2, which.max)
second_idx <- apply(enh_avg_z_by_ct_ATAC, 2, function(v) order(v, decreasing = TRUE)[2])

enh_dominant_tbl_ATAC <- tibble::tibble(
  sample       = colnames(enh_avg_z_by_ct_ATAC),
  top_ct       = ct_levels[top_idx],
  top_score    = enh_avg_z_by_ct_ATAC[cbind(top_idx, seq_along(top_idx))],
  second_ct    = ct_levels[second_idx],
  second_score = enh_avg_z_by_ct_ATAC[cbind(second_idx, seq_along(second_idx))]
) %>%
  dplyr::mutate(margin = top_score - second_score) %>%
  dplyr::left_join(meta_sj %>% dplyr::select(Sample, genotype),
                   by = c("sample" = "Sample"))

cat("[8] top_ct frequencies:\n")
print(sort(table(enh_dominant_tbl_ATAC$top_ct), decreasing = TRUE))
cat("[8] margin summary:\n")
print(summary(enh_dominant_tbl_ATAC$margin))

cat("\n[8-QC] Dominance consistency: RAW vs SCALED...\n")
raw_top  <- apply(enh_avg_z_by_ct_ATAC_raw, 2, which.max)
sc_top   <- apply(enh_avg_z_by_ct_ATAC,     2, which.max)
raw_call <- ct_levels[raw_top]
sc_call  <- ct_levels[sc_top]
cat("  • % same top_ct (RAW vs SCALED): ", round(100 * mean(raw_call == sc_call, na.rm = TRUE), 2), "%\n", sep = "")
cat("  • Confusion (RAW rows vs SCALED cols):\n")
print(table(raw_call, sc_call))

# ---------------------------------------------------------------------
# 9 — Order samples + pheatmap annotations + heatmap
# ---------------------------------------------------------------------
cat("\n[9] Ordering samples (top_ct → margin → top_score) + heatmap...\n")

enh_col_order <- order(
  factor(enh_dominant_tbl_ATAC$top_ct, levels = ct_levels),
  -enh_dominant_tbl_ATAC$margin,
  -enh_dominant_tbl_ATAC$top_score
)

enh_avg_z_by_ct_ord  <- enh_avg_z_by_ct_ATAC[, enh_col_order, drop = FALSE]
enh_dominant_tbl_ord <- enh_dominant_tbl_ATAC[enh_col_order, ]

enh_margin_bins <- cut(
  enh_dominant_tbl_ord$margin,
  breaks = quantile(enh_dominant_tbl_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
  include.lowest = TRUE,
  labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

enh_ann_col_ATAC <- data.frame(
  top_ct    = factor(enh_dominant_tbl_ord$top_ct, levels = ct_levels),
  margin    = enh_margin_bins,
  genotype  = enh_dominant_tbl_ord$genotype,
  row.names = enh_dominant_tbl_ord$sample,
  stringsAsFactors = FALSE
)

# Palettes (reuse if present; otherwise define)
if (!exists("cell_type_colors")) {
  cell_type_colors <- c(
    HSCMPP        = "#fb8072",
    GMP           = "#bebada",
    pDC           = "#ffd92f",
    EarlyLymphoid = "#f781bf",
    ProB          = "#ff33ff",
    PreB          = "#00e5c0",
    B             = "#00bfff"
  )
}
if (!exists("margin_colors")) {
  margin_colors <- c(
    "Q1 (lowest)"  = "#c7e9c0",
    "Q2"           = "#a1d99b",
    "Q3"           = "#74c476",
    "Q4 (highest)" = "#238b45"
  )
}
if (!exists("genotype_colors")) {
  genotype_colors <- c(
    TT = "#f65e0dff",
    TC = "#0c2e18ff",
    CC = "#d7a419ff"
  )
}

enh_z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)

pheatmap::pheatmap(
  enh_avg_z_by_ct_ord,
  color             = enh_z_col_fun,
  cluster_rows      = FALSE,
  cluster_cols      = FALSE,
  show_rownames     = TRUE,
  show_colnames     = FALSE,
  annotation_col    = enh_ann_col_ATAC,
  annotation_colors = list(
    top_ct   = cell_type_colors,
    margin   = margin_colors,
    genotype = genotype_colors
  ),
  border_color = NA,
  main = paste0("ATAC module activity of Ilaria's markers (ENHANCERS = |distanceToTSS| > ",
                PROMOTER_WINDOW_BP, "bp; one peak/gene = closest enhancer; column-scaled)")
)


```

## 15 Savics

```{r}
# =====================================================================
# ATAC — Savics S3 ALL-PEAKS dominance map WITH LIFTOVER (hg19 → hg38)
# UPDATED (per your decision: ignore multi-lineage labels)
#   (1) KEEP ONLY SINGLE Defining_Progenitor labels (DROP comma-lists; NO splitting)
#   (A) Normalization confirmation (library sizes + integer-ness check)
#   (B) Per-module support sizes (unique peak_id per progenitor after overlap)
#   (C) Liftover multi-map inflation report (+ dedup impact into peak_id×ct)
#   (D) Flag low-signal samples using sd across RAW module scores
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(readxl)
    library(tibble)
    library(pheatmap)
    library(stringr)
    library(GenomicRanges)
    library(rtracklayer)
    library(GenomeInfoDb)
    library(R.utils)
})

cat("\n===============================================================\n")
cat("ATAC SAVICS (ALL PEAKS) — LIFTOVER + OVERLAP + COLUMN-SCALED MODULES\n")
cat("UPDATED: SINGLE-LABEL ONLY (drop comma-list progenitors) + normalization/module support/multimap reports\n")
cat("===============================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts"))  stop("[0] ERROR: `counts` not found.")
if (!exists("meta_sj")) stop("[0] ERROR: `meta_sj` not found.")
if (!exists("anno_df")) stop("[0] ERROR: `anno_df` not found.")
if (!all(c("seqnames","start","end","peak_id") %in% colnames(anno_df))) {
    stop("[0] ERROR: anno_df must contain: seqnames, start, end, peak_id.")
}

cat("[0] counts dim (peaks × samples): ", paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols):    ", paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 0a — Normalization confirmation (pre-flight)
# ---------------------------------------------------------------------
cat("\n[0a] NORMALIZATION CHECK (counts):\n")

lib_all <- suppressWarnings(colSums(counts))
lib_all <- lib_all[is.finite(lib_all)]
cv_all  <- if (length(lib_all) > 1) stats::sd(lib_all) / mean(lib_all) else NA_real_

cat("[0a] Library-size summary (all peaks):\n")
print(summary(lib_all))
cat("[0a] Library-size CV (all peaks): ", signif(cv_all, 4), "\n", sep = "")

set.seed(1)
nr <- nrow(counts); nc <- ncol(counts)
r_idx <- if (nr > 0) sample.int(nr, size = min(2000, nr)) else integer(0)
c_idx <- if (nc > 0) sample.int(nc, size = min(50, nc)) else integer(0)
vals  <- as.numeric(counts[r_idx, c_idx, drop = FALSE])
vals  <- vals[is.finite(vals)]
is_integerish <- if (length(vals) > 0) all(abs(vals - round(vals)) < 1e-6) else NA

cat("[0a] counts look integer-like (sampled): ", is_integerish, "\n", sep = "")
if (isTRUE(is_integerish) && is.finite(cv_all) && cv_all > 0.10) {
    cat("[0a] NOTE: counts appear RAW (integer + variable library sizes). ",
        "Per-peak z-scoring is NOT library-size normalization.\n", sep = "")
} else if (isTRUE(is_integerish) && is.finite(cv_all) && cv_all <= 0.10) {
    cat("[0a] NOTE: counts are integer-like but library sizes are relatively similar.\n")
} else {
    cat("[0a] NOTE: counts may already be normalized/transformed (non-integer-ish) or sampling inconclusive.\n")
}

# ---------------------------------------------------------------------
# 0b — Chain file (hg19 → hg38)
# ---------------------------------------------------------------------
chain_gz  <- "hg19ToHg38.over.chain.gz"
chain_txt <- "hg19ToHg38.over.chain"

if (!file.exists(chain_gz)) stop("[0b] ERROR: Chain .gz not found: ", chain_gz)

if (!file.exists(chain_txt)) {
    cat("[0b] Unzipping chain file: ", chain_gz, " → ", chain_txt, "\n", sep = "")
    R.utils::gunzip(chain_gz, destname = chain_txt, overwrite = TRUE, remove = FALSE)
}

first_line <- readLines(chain_txt, n = 1, warn = FALSE)
if (!startsWith(first_line, "chain ")) stop("[0b] ERROR: Invalid chain header: ", first_line)

hg19_to_hg38_chain <- rtracklayer::import.chain(chain_txt)
cat("[0b] Loaded chain: ", chain_txt, "\n", sep = "")

# ---------------------------------------------------------------------
# 1 — Load Savics S3 hg19 peaks (KEEP SINGLE-LABEL ONLY; DROP comma-lists)
# ---------------------------------------------------------------------
savics_path <- "Savics_S3.xlsx"
if (!file.exists(savics_path)) stop("[1] ERROR: Savics file not found: ", savics_path)

savics_raw <- readxl::read_xlsx(savics_path)

savics_ct_levels <- c("HSC", "MPP", "LMPP", "CLP", "PreProB", "ProB", "CD19CD20")

cat("\n[1] Defining_Progenitor label audit (single vs comma-list):\n")
label_audit <- savics_raw %>%
    as.data.frame() %>%
    dplyr::transmute(
        Defining_Progenitor = stringr::str_trim(as.character(.data$Defining_Progenitor)),
        is_multilabel       = stringr::str_detect(.data$Defining_Progenitor, ",")
    ) %>%
    dplyr::count(.data$is_multilabel, name = "n") %>%
    dplyr::mutate(pct = round(100 * .data$n / sum(.data$n), 2))
print(label_audit)

cat("[1] Top comma-list strings (WILL BE DROPPED):\n")
top_multis <- savics_raw %>%
    as.data.frame() %>%
    dplyr::transmute(Defining_Progenitor = stringr::str_trim(as.character(.data$Defining_Progenitor))) %>%
    dplyr::filter(stringr::str_detect(.data$Defining_Progenitor, ",")) %>%
    dplyr::count(.data$Defining_Progenitor, sort = TRUE)
print(utils::head(top_multis, 25))

savics_hg19_df <- savics_raw %>%
    as.data.frame() %>%
    dplyr::mutate(
        chr                 = as.character(.data$chr),
        start               = as.integer(.data$start),
        stop                = as.integer(.data$stop),
        Defining_Progenitor = stringr::str_trim(as.character(.data$Defining_Progenitor))
    ) %>%
    dplyr::filter(!is.na(.data$chr), !is.na(.data$start), !is.na(.data$stop)) %>%
    dplyr::filter(!is.na(.data$Defining_Progenitor), .data$Defining_Progenitor != "") %>%
    dplyr::filter(!stringr::str_detect(.data$Defining_Progenitor, ",")) %>%        # << DROP comma-lists
    dplyr::filter(.data$Defining_Progenitor %in% savics_ct_levels) %>%
    dplyr::distinct(.data$chr, .data$start, .data$stop, .data$Defining_Progenitor, .keep_all = TRUE)

cat("[1] savics_hg19_df rows (single-label only): ", nrow(savics_hg19_df), "\n", sep = "")

# ---------------------------------------------------------------------
# 1c — GRanges + liftover to hg38 (+ multi-map report)
# ---------------------------------------------------------------------
cat("\n[1c] Building GRanges (hg19) and running liftOver → hg38...\n")

savics_gr_hg19 <- GenomicRanges::GRanges(
    seqnames = savics_hg19_df$chr,
    ranges   = IRanges::IRanges(start = savics_hg19_df$start, end = savics_hg19_df$stop)
)

savics_gr_hg38_list <- rtracklayer::liftOver(savics_gr_hg19, hg19_to_hg38_chain)

n_maps <- lengths(savics_gr_hg38_list)
cat("[1c] LiftOver mapping multiplicity (per hg19 row):\n")
cat("     • total hg19 rows: ", length(n_maps), "\n", sep = "")
cat("     • unmapped (0):    ", sum(n_maps == 0L), "\n", sep = "")
cat("     • 1-to-1 (1):      ", sum(n_maps == 1L), "\n", sep = "")
cat("     • multi-map (>1):  ", sum(n_maps > 1L), "\n", sep = "")
cat("     • max maps:        ", if (length(n_maps) > 0) max(n_maps) else NA_integer_, "\n", sep = "")

orig_idx       <- rep(seq_along(savics_gr_hg19), n_maps)
savics_gr_hg38 <- unlist(savics_gr_hg38_list)

cat("[1c] LiftOver: hg19 peaks=", length(savics_gr_hg19),
    " | hg38 intervals=", length(savics_gr_hg38), "\n", sep = "")

if (length(savics_gr_hg38) == 0L) stop("[1c] ERROR: liftover produced no hg38 mappings.")

savics_hg38_df <- savics_hg19_df[orig_idx, , drop = FALSE] %>%
    dplyr::mutate(
        chr_hg38   = as.character(GenomeInfoDb::seqnames(savics_gr_hg38)),
        start_hg38 = as.integer(GenomicRanges::start(savics_gr_hg38)),
        stop_hg38  = as.integer(GenomicRanges::end(savics_gr_hg38))
    )

# ---------------------------------------------------------------------
# 2 — Build SJ156 peak GRanges (hg38) & overlaps
# ---------------------------------------------------------------------
cat("\n[2] Building SJ156 peak GRanges and finding overlaps...\n")

sj156_gr <- GenomicRanges::GRanges(
    seqnames = as.character(anno_df$seqnames),
    ranges   = IRanges::IRanges(start = as.integer(anno_df$start), end = as.integer(anno_df$end)),
    peak_id  = anno_df$peak_id
)

savics_gr_hg38_clean <- GenomicRanges::GRanges(
    seqnames = savics_hg38_df$chr_hg38,
    ranges   = IRanges::IRanges(start = savics_hg38_df$start_hg38, end = savics_hg38_df$stop_hg38)
)

hits <- GenomicRanges::findOverlaps(
    query         = savics_gr_hg38_clean,
    subject       = sj156_gr,
    ignore.strand = TRUE
)

cat("[2] overlap pairs (Savics×SJ156): ", length(hits), "\n", sep = "")
if (length(hits) == 0L) stop("[2] ERROR: No overlaps found.")

savics_overlap_pairs <- tibble::tibble(
    savics_idx = S4Vectors::queryHits(hits),
    sj156_idx  = S4Vectors::subjectHits(hits)
) %>%
    dplyr::mutate(
        Defining_Progenitor = savics_hg38_df$Defining_Progenitor[.data$savics_idx],
        peak_id             = as.character(S4Vectors::mcols(sj156_gr)$peak_id[.data$sj156_idx])
    )

# Deduplicate to peak_id × progenitor (prevents overweighting from multi-map or multiple overlaps)
savics_overlap_df <- savics_overlap_pairs %>%
    dplyr::select("peak_id", "Defining_Progenitor") %>%
    dplyr::distinct()

cat("[2] savics_overlap_df dim (distinct peak_id×ct): ", paste(dim(savics_overlap_df), collapse = " × "), "\n", sep = "")
cat("[2] DEDUP IMPACT (inflation check):\n")
cat("     • raw overlap pairs:         ", nrow(savics_overlap_pairs), "\n", sep = "")
cat("     • distinct peak_id×ct pairs: ", nrow(savics_overlap_df), "\n", sep = "")
cat("     • compression ratio:         ",
    signif(nrow(savics_overlap_df) / max(1, nrow(savics_overlap_pairs)), 4), "\n", sep = "")

# ---------------------------------------------------------------------
# 3 — Restrict to peaks present in counts + per-module support sizes
# ---------------------------------------------------------------------
cat("\n[3] Restricting to peak_id present in counts...\n")

mapped_peaks_all <- unique(savics_overlap_df$peak_id)
peaks_in_counts  <- intersect(mapped_peaks_all, rownames(counts))

cat("[3] mapped unique peak_id: ", length(mapped_peaks_all), "\n", sep = "")
cat("[3] mapped ∩ counts:       ", length(peaks_in_counts), "\n", sep = "")
if (length(peaks_in_counts) == 0L) stop("[3] ERROR: No overlapping peak_id in counts.")

savics_long_use <- savics_overlap_df %>%
    dplyr::filter(.data$peak_id %in% peaks_in_counts) %>%
    dplyr::filter(.data$Defining_Progenitor %in% savics_ct_levels)

cat("[3] PER-MODULE SUPPORT (unique peak_id per progenitor):\n")
module_support <- savics_long_use %>%
    dplyr::group_by(.data$Defining_Progenitor) %>%
    dplyr::summarise(
        n_unique_peak_id = dplyr::n_distinct(.data$peak_id),
        n_pairs          = dplyr::n(),
        .groups          = "drop"
    ) %>%
    dplyr::arrange(dplyr::desc(.data$n_unique_peak_id))
print(module_support)

low_support <- module_support %>% dplyr::filter(.data$n_unique_peak_id < 50)
if (nrow(low_support) > 0) {
    cat("[3] WARNING: Some modules have <50 unique peaks after overlap+counts.\n")
    print(low_support)
}

# ---------------------------------------------------------------------
# 3b — Normalization confirmation (subset peaks used)
# ---------------------------------------------------------------------
cat("\n[3b] NORMALIZATION CHECK (subset peaks used for Savics):\n")

savics_counts_mat <- counts[peaks_in_counts, , drop = FALSE]
lib_subset <- suppressWarnings(colSums(savics_counts_mat))
lib_subset <- lib_subset[is.finite(lib_subset)]
cv_subset  <- if (length(lib_subset) > 1) stats::sd(lib_subset) / mean(lib_subset) else NA_real_

cat("[3b] Library-size summary (subset peaks_in_counts):\n")
print(summary(lib_subset))
cat("[3b] Library-size CV (subset): ", signif(cv_subset, 4), "\n", sep = "")

# ---------------------------------------------------------------------
# 4 — Per-peak z-scores (within peak across samples)
# NOTE: this standardizes each peak across samples; it does NOT normalize library size.
# ---------------------------------------------------------------------
cat("\n[4] Z-scoring per peak (within peak across samples)...\n")

savics_z_peak <- t(scale(t(savics_counts_mat)))
savics_z_peak[is.na(savics_z_peak)] <- 0

# ---------------------------------------------------------------------
# 5 — Expand to peak×progenitor rows
# ---------------------------------------------------------------------
cat("[5] Expanding to peak×progenitor rows...\n")

savics_expanded <- savics_long_use %>%
    dplyr::mutate(row_id = paste(.data$peak_id, .data$Defining_Progenitor, sep = "|")) %>%
    dplyr::left_join(
        savics_z_peak %>% as.data.frame() %>% tibble::rownames_to_column("peak_id"),
        by = "peak_id"
    )

savics_mat_expanded <- savics_expanded %>%
    dplyr::select(-"peak_id", -"Defining_Progenitor") %>%
    tibble::column_to_rownames("row_id") %>%
    as.matrix()

savics_ct_for_row <- savics_expanded$Defining_Progenitor
names(savics_ct_for_row) <- rownames(savics_mat_expanded)

# ---------------------------------------------------------------------
# 6 — Raw module matrix + stability (sd across modules per sample)
# ---------------------------------------------------------------------
cat("[6] Computing RAW module activity (7 × samples) ...\n")

savics_avg_z_by_ct_ATAC_raw <- do.call(
    rbind,
    lapply(savics_ct_levels, function(ct) {
        idx <- which(savics_ct_for_row == ct)
        if (length(idx) == 0L) {
            return(rep(NA_real_, ncol(savics_mat_expanded)))
        } else {
            return(colMeans(savics_mat_expanded[idx, , drop = FALSE], na.rm = TRUE))
        }
    })
)
rownames(savics_avg_z_by_ct_ATAC_raw) <- savics_ct_levels

sd_raw_modules <- apply(savics_avg_z_by_ct_ATAC_raw, 2, stats::sd, na.rm = TRUE)

cat("[6] RAW module sd across progenitors (per sample) summary:\n")
print(summary(sd_raw_modules))
cat("[6] n samples with sd<0.05 (LOW_SD): ", sum(sd_raw_modules < 0.05, na.rm = TRUE), "\n", sep = "")

# ---------------------------------------------------------------------
# 7 — Column-wise scaling (within-sample z across progenitors)
# ---------------------------------------------------------------------
cat("[7] Column-wise scaling (within-sample across 7 progenitors) ...\n")

savics_avg_z_by_ct_ATAC <- scale(savics_avg_z_by_ct_ATAC_raw, center = TRUE, scale = TRUE)
savics_avg_z_by_ct_ATAC[is.na(savics_avg_z_by_ct_ATAC)] <- 0

# ---------------------------------------------------------------------
# 8 — Dominant progenitor + margins + low-signal flag
# ---------------------------------------------------------------------
cat("[8] Computing dominance calls + margins + low-signal flags ...\n")

savics_top_idx    <- apply(savics_avg_z_by_ct_ATAC, 2, which.max)
savics_second_idx <- apply(savics_avg_z_by_ct_ATAC, 2, function(v) order(v, decreasing = TRUE)[2])

savics_dominant_tbl <- tibble::tibble(
    sample       = colnames(savics_avg_z_by_ct_ATAC),
    top_ct       = savics_ct_levels[savics_top_idx],
    top_score    = savics_avg_z_by_ct_ATAC[cbind(savics_top_idx, seq_along(savics_top_idx))],
    second_ct    = savics_ct_levels[savics_second_idx],
    second_score = savics_avg_z_by_ct_ATAC[cbind(savics_second_idx, seq_along(savics_second_idx))]
) %>%
    dplyr::mutate(
        margin         = .data$top_score - .data$second_score,
        sd_raw_modules = sd_raw_modules[.data$sample],
        low_signal     = factor(ifelse(.data$sd_raw_modules < 0.05, "LOW_SD", "OK"),
                                levels = c("OK", "LOW_SD"))
    ) %>%
    dplyr::left_join(
        meta_sj %>% dplyr::select("Sample", "genotype"),
        by = c("sample" = "Sample")
    )

# ---------------------------------------------------------------------
# 9 — Order samples: top_ct → margin → top_score
# ---------------------------------------------------------------------
savics_col_order <- order(
    factor(savics_dominant_tbl$top_ct, levels = savics_ct_levels),
    -savics_dominant_tbl$margin,
    -savics_dominant_tbl$top_score
)

savics_avg_z_by_ct_ord  <- savics_avg_z_by_ct_ATAC[, savics_col_order, drop = FALSE]
savics_dominant_tbl_ord <- savics_dominant_tbl[savics_col_order, ]

# ---------------------------------------------------------------------
# 10 — Annotation column (robust quartiles via ntile)
# ---------------------------------------------------------------------
margin_q <- dplyr::ntile(savics_dominant_tbl_ord$margin, 4)

savics_margin_bins <- factor(
    dplyr::case_when(
        is.na(margin_q) ~ "NA",
        margin_q == 1L  ~ "Q1 (lowest)",
        margin_q == 2L  ~ "Q2",
        margin_q == 3L  ~ "Q3",
        margin_q == 4L  ~ "Q4 (highest)",
        TRUE            ~ "NA"
    ),
    levels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)", "NA")
)

savics_ann_col <- data.frame(
    top_ct     = factor(savics_dominant_tbl_ord$top_ct, levels = savics_ct_levels),
    margin     = savics_margin_bins,
    genotype   = savics_dominant_tbl_ord$genotype,
    low_signal = savics_dominant_tbl_ord$low_signal,
    row.names  = savics_dominant_tbl_ord$sample,
    stringsAsFactors = FALSE
)

savics_ann_col <- savics_ann_col[colnames(savics_avg_z_by_ct_ord), , drop = FALSE]

# ---------------------------------------------------------------------
# 11 — Heatmap
# ---------------------------------------------------------------------
if (!exists("savics_cell_type_colors")) {
    savics_cell_type_colors <- c(
        HSC      = "#fb8072",
        MPP      = "#bebada",
        LMPP     = "#ffd92f",
        CLP      = "#f781bf",
        PreProB  = "#ff33ff",
        ProB     = "#00e5c0",
        CD19CD20 = "#00bfff"
    )
}
if (!exists("margin_colors")) {
    margin_colors <- c(
        "Q1 (lowest)"  = "#c7e9c0",
        "Q2"           = "#a1d99b",
        "Q3"           = "#74c476",
        "Q4 (highest)" = "#238b45",
        "NA"           = "#dddddd"
    )
}
if (!exists("genotype_colors")) {
    genotype_colors <- c(TT = "#f65e0dff", TC = "#0c2e18ff", CC = "#d7a419ff")
}
savics_low_signal_colors <- c(OK = "#f0f0f0", LOW_SD = "#000000")

savics_z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)

pheatmap::pheatmap(
    savics_avg_z_by_ct_ord,
    color             = savics_z_col_fun,
    cluster_rows      = FALSE,
    cluster_cols      = FALSE,
    show_rownames     = TRUE,
    show_colnames     = FALSE,
    annotation_col    = savics_ann_col,
    annotation_colors = list(
        top_ct     = savics_cell_type_colors,
        margin     = margin_colors,
        genotype   = genotype_colors,
        low_signal = savics_low_signal_colors
    ),
    border_color      = NA,
    main              = "ATAC module activity Savic's markers [ALL peaks]"
)

cat("\n[SAVICS ALL] DONE — SINGLE-LABEL ONLY used (comma-list progenitors dropped); low-signal samples flagged.\n")
cat("===============================================================\n\n")

```


#### Promoter only savic
```{r}
# =====================================================================
# ATAC — Savics S3 PROMOTERS-ONLY dominance map WITH LIFTOVER (hg19 → hg38)
# SINGLE-LABEL ONLY (drop comma-lists) + same audits + HEATMAP
# IMPORTANT: This chunk auto-detects a promoter-annotation column in anno_df.
# ALL objects prefixed with `prom_`
# =====================================================================

suppressPackageStartupMessages({  library(dplyr)
  library(tidyr)
  library(readxl)
  library(tibble)
  library(pheatmap)
  library(stringr)
  library(GenomicRanges)
  library(rtracklayer)
  library(GenomeInfoDb)
  library(R.utils)
})

cat("\n===============================================================\n")
cat("ATAC SAVICS (PROMOTERS ONLY) — LIFTOVER + OVERLAP + COLUMN-SCALED MODULES\n")
cat("SINGLE-LABEL ONLY (drop comma-list progenitors) + audits + heatmap\n")
cat("===============================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts"))  stop("[0] ERROR: `counts` not found.")
if (!exists("meta_sj")) stop("[0] ERROR: `meta_sj` not found.")
if (!exists("anno_df")) stop("[0] ERROR: `anno_df` not found.")
if (!all(c("seqnames","start","end","peak_id") %in% colnames(anno_df))) {
  stop("[0] ERROR: anno_df must contain: seqnames, start, end, peak_id.")
}

cat("[0] counts dim (peaks × samples): ", paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols):    ", paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 0a — Normalization confirmation (pre-flight)
# ---------------------------------------------------------------------
cat("\n[0a] NORMALIZATION CHECK (counts):\n")

prom_lib_all <- suppressWarnings(colSums(counts))
prom_lib_all <- prom_lib_all[is.finite(prom_lib_all)]
prom_cv_all  <- if (length(prom_lib_all) > 1) stats::sd(prom_lib_all) / mean(prom_lib_all) else NA_real_

print(summary(prom_lib_all))
cat("[0a] Library-size CV (all peaks): ", signif(prom_cv_all, 4), "\n", sep = "")

set.seed(1)
prom_nr <- nrow(counts); prom_nc <- ncol(counts)
prom_r_idx <- if (prom_nr > 0) sample.int(prom_nr, size = min(2000, prom_nr)) else integer(0)
prom_c_idx <- if (prom_nc > 0) sample.int(prom_nc, size = min(50, prom_nc)) else integer(0)
prom_vals  <- as.numeric(counts[prom_r_idx, prom_c_idx, drop = FALSE])
prom_vals  <- prom_vals[is.finite(prom_vals)]
prom_is_integerish <- if (length(prom_vals) > 0) all(abs(prom_vals - round(prom_vals)) < 1e-6) else NA

cat("[0a] counts look integer-like (sampled): ", prom_is_integerish, "\n", sep = "")
if (isTRUE(prom_is_integerish) && is.finite(prom_cv_all) && prom_cv_all > 0.10) {
  cat("[0a] NOTE: counts appear RAW (integer + variable library sizes). ",
      "Per-peak z-scoring is NOT library-size normalization.\n", sep = "")
}

# ---------------------------------------------------------------------
# 0b — Detect promoters in anno_df (robust auto-detect)
# ---------------------------------------------------------------------
cat("\n[0b] Detecting promoter peaks in anno_df...\n")

prom_anno_chr_cols <- names(anno_df)[
  vapply(anno_df, function(x) is.character(x) || is.factor(x), logical(1))
]
prom_anno_chr_cols <- setdiff(prom_anno_chr_cols, c("seqnames", "peak_id"))

if (length(prom_anno_chr_cols) == 0) {
  stop("[0b] ERROR: No character/factor columns found in anno_df to detect promoters.")
}

prom_annot_like <- prom_anno_chr_cols[
  grepl("annot|feature|region|genomic|type|class", tolower(prom_anno_chr_cols))
]
if (length(prom_annot_like) == 0) prom_annot_like <- prom_anno_chr_cols

prom_promoter_rate <- vapply(
  prom_annot_like,
  function(col) {
    x <- tolower(as.character(anno_df[[col]]))
    mean(grepl("promoter|tss", x), na.rm = TRUE)
  },
  numeric(1)
)

prom_best_col  <- prom_annot_like[which.max(prom_promoter_rate)]
prom_best_rate <- max(prom_promoter_rate)

print(utils::head(sort(prom_promoter_rate, decreasing = TRUE), 10))

if (!is.finite(prom_best_rate) || prom_best_rate < 0.001) {
  stop("[0b] ERROR: No column shows promoter/TSS-like strings.")
}

cat("[0b] Using column '", prom_best_col,
    "' (promoter hit-rate ~", signif(prom_best_rate, 3), ").\n", sep = "")

prom_anno_promoters_df <- anno_df %>%
  dplyr::mutate(.anno = tolower(as.character(.data[[prom_best_col]]))) %>%
  dplyr::filter(grepl("promoter|tss", .data$.anno)) %>%
  dplyr::select(-.data$.anno)

cat("[0b] Promoter peaks in anno_df: ", nrow(prom_anno_promoters_df), "\n", sep = "")
if (nrow(prom_anno_promoters_df) == 0L) stop("[0b] ERROR: promoter filter produced 0 rows.")

# ---------------------------------------------------------------------
# 0c — Chain file (hg19 → hg38)
# ---------------------------------------------------------------------
prom_chain_gz  <- "hg19ToHg38.over.chain.gz"
prom_chain_txt <- "hg19ToHg38.over.chain"

if (!file.exists(prom_chain_gz)) stop("[0c] ERROR: Chain .gz not found.")

if (!file.exists(prom_chain_txt)) {
  R.utils::gunzip(prom_chain_gz, destname = prom_chain_txt, overwrite = TRUE, remove = FALSE)
}

prom_chain <- rtracklayer::import.chain(prom_chain_txt)

# ---------------------------------------------------------------------
# 1 — Load Savics S3 hg19 peaks (SINGLE-LABEL ONLY)
# ---------------------------------------------------------------------
prom_savics_raw <- readxl::read_xlsx("Savics_S3.xlsx")
prom_ct_levels  <- c("HSC","MPP","LMPP","CLP","PreProB","ProB","CD19CD20")

prom_savics_hg19_df <- prom_savics_raw %>%
  as.data.frame() %>%
  dplyr::mutate(
    chr = as.character(.data$chr),
    start = as.integer(.data$start),
    stop  = as.integer(.data$stop),
    Defining_Progenitor = stringr::str_trim(as.character(.data$Defining_Progenitor))
  ) %>%
  dplyr::filter(
    !is.na(.data$chr),
    !is.na(.data$start),
    !is.na(.data$stop),
    !is.na(.data$Defining_Progenitor),
    .data$Defining_Progenitor %in% prom_ct_levels,
    !stringr::str_detect(.data$Defining_Progenitor, ",")
  ) %>%
  dplyr::distinct(.data$chr, .data$start, .data$stop, .data$Defining_Progenitor)

# ---------------------------------------------------------------------
# 1c — liftOver to hg38
# ---------------------------------------------------------------------
prom_gr_hg19 <- GenomicRanges::GRanges(
  seqnames = prom_savics_hg19_df$chr,
  ranges   = IRanges::IRanges(start = prom_savics_hg19_df$start,
                              end   = prom_savics_hg19_df$stop)
)

prom_gr_hg38_list <- rtracklayer::liftOver(prom_gr_hg19, prom_chain)
prom_orig_idx <- rep(seq_along(prom_gr_hg19), lengths(prom_gr_hg38_list))
prom_gr_hg38  <- unlist(prom_gr_hg38_list)

prom_savics_hg38_df <- prom_savics_hg19_df[prom_orig_idx, , drop = FALSE] %>%
  dplyr::mutate(
    chr_hg38   = as.character(GenomeInfoDb::seqnames(prom_gr_hg38)),
    start_hg38 = as.integer(GenomicRanges::start(prom_gr_hg38)),
    stop_hg38  = as.integer(GenomicRanges::end(prom_gr_hg38))
  )

# ---------------------------------------------------------------------
# 2 — Overlap Savics(hg38) to SJ156 PROMOTERS
# ---------------------------------------------------------------------
prom_sj_gr <- GenomicRanges::GRanges(
  seqnames = as.character(prom_anno_promoters_df$seqnames),
  ranges   = IRanges::IRanges(start = prom_anno_promoters_df$start,
                              end   = prom_anno_promoters_df$end),
  peak_id  = prom_anno_promoters_df$peak_id
)

prom_hits <- GenomicRanges::findOverlaps(
  query         = GenomicRanges::GRanges(
    seqnames = prom_savics_hg38_df$chr_hg38,
    ranges   = IRanges::IRanges(start = prom_savics_hg38_df$start_hg38,
                                end   = prom_savics_hg38_df$stop_hg38)
  ),
  subject       = prom_sj_gr,
  ignore.strand = TRUE
)

prom_overlap_df <- tibble::tibble(
  peak_id = as.character(S4Vectors::mcols(prom_sj_gr)$peak_id[S4Vectors::subjectHits(prom_hits)]),
  Defining_Progenitor = prom_savics_hg38_df$Defining_Progenitor[S4Vectors::queryHits(prom_hits)]
) %>%
  dplyr::distinct()

# ---------------------------------------------------------------------
# 3 — Restrict to peaks present in counts
# ---------------------------------------------------------------------
prom_peaks_in_counts <- intersect(unique(prom_overlap_df$peak_id), rownames(counts))
if (length(prom_peaks_in_counts) == 0L) stop("[3] ERROR: No overlapping promoter peak_id in counts.")

prom_long_use <- prom_overlap_df %>%
  dplyr::filter(.data$peak_id %in% prom_peaks_in_counts)

# ---------------------------------------------------------------------
# 4 — Per-peak z-scores
# ---------------------------------------------------------------------
prom_counts_mat <- counts[prom_peaks_in_counts, , drop = FALSE]
prom_z_peak <- t(scale(t(prom_counts_mat)))
prom_z_peak[is.na(prom_z_peak)] <- 0

# ---------------------------------------------------------------------
# 5 — Expand to peak×progenitor rows
# ---------------------------------------------------------------------
prom_expanded <- prom_long_use %>%
  dplyr::mutate(row_id = paste(.data$peak_id, .data$Defining_Progenitor, sep="|")) %>%
  dplyr::left_join(
    prom_z_peak %>% as.data.frame() %>% tibble::rownames_to_column("peak_id"),
    by = "peak_id"
  )

prom_mat_expanded <- prom_expanded %>%
  dplyr::select(-.data$peak_id, -.data$Defining_Progenitor) %>%
  tibble::column_to_rownames("row_id") %>%
  as.matrix()

prom_ct_for_row <- prom_expanded$Defining_Progenitor
names(prom_ct_for_row) <- rownames(prom_mat_expanded)

# ---------------------------------------------------------------------
# 6 — Raw module matrix
# ---------------------------------------------------------------------
prom_avg_raw <- do.call(
  rbind,
  lapply(prom_ct_levels, function(ct) {
    idx <- which(prom_ct_for_row == ct)
    if (length(idx) == 0L) rep(NA_real_, ncol(prom_mat_expanded))
    else colMeans(prom_mat_expanded[idx, , drop = FALSE], na.rm = TRUE)
  })
)
rownames(prom_avg_raw) <- prom_ct_levels

# ---------------------------------------------------------------------
# 7 — Column-wise scaling
# ---------------------------------------------------------------------
prom_avg_scaled <- scale(prom_avg_raw, center = TRUE, scale = TRUE)
prom_avg_scaled[is.na(prom_avg_scaled)] <- 0

# ---------------------------------------------------------------------
# 8 — Dominance + margins
# ---------------------------------------------------------------------
prom_top_idx    <- apply(prom_avg_scaled, 2, which.max)
prom_second_idx <- apply(prom_avg_scaled, 2, function(v) order(v, decreasing = TRUE)[2])

prom_dom_tbl <- tibble::tibble(
  sample       = colnames(prom_avg_scaled),
  top_ct       = prom_ct_levels[prom_top_idx],
  top_score    = prom_avg_scaled[cbind(prom_top_idx, seq_along(prom_top_idx))],
  second_ct    = prom_ct_levels[prom_second_idx],
  second_score = prom_avg_scaled[cbind(prom_second_idx, seq_along(prom_second_idx))]
) %>%
  dplyr::mutate(margin = .data$top_score - .data$second_score) %>%
  dplyr::left_join(
    meta_sj %>% dplyr::select("Sample", "genotype"),
    by = c("sample" = "Sample")
  )

# ---------------------------------------------------------------------
# 9 — Order samples
# ---------------------------------------------------------------------
prom_col_order <- order(
  factor(prom_dom_tbl$top_ct, levels = prom_ct_levels),
  -prom_dom_tbl$margin,
  -prom_dom_tbl$top_score
)

prom_avg_scaled_ord <- prom_avg_scaled[, prom_col_order, drop = FALSE]
prom_dom_tbl_ord    <- prom_dom_tbl[prom_col_order, ]

# ---------------------------------------------------------------------
# 10 — Annotation + heatmap
# ---------------------------------------------------------------------
prom_margin_q <- dplyr::ntile(prom_dom_tbl_ord$margin, 4)

prom_ann_col <- data.frame(
  top_ct   = factor(prom_dom_tbl_ord$top_ct, levels = prom_ct_levels),
  margin   = factor(c("Q1 (lowest)","Q2","Q3","Q4 (highest)")[prom_margin_q],
                    levels = c("Q1 (lowest)","Q2","Q3","Q4 (highest)")),
  genotype = prom_dom_tbl_ord$genotype,
  row.names = prom_dom_tbl_ord$sample
)

pheatmap::pheatmap(
  prom_avg_scaled_ord,
  color             = savics_z_col_fun,
  cluster_rows      = FALSE,
  cluster_cols      = FALSE,
  show_colnames     = FALSE,
  annotation_col    = prom_ann_col,
  annotation_colors = list(
    top_ct   = savics_cell_type_colors,
    margin   = margin_colors,
    genotype = genotype_colors
  ),
  border_color = NA,
  main = "ATAC module activity Savic's markers [PROMOTERS]"
)

cat("\n[SAVICS PROMOTERS] DONE — dplyr:: explicit, prom_ prefixed, logic preserved.\n")

```
##### Saving for footpringint
```{r}
# ================================================================
# EXPORT ProB-ONLY SAMPLE CLASSIFICATIONS (PROMOTERS, SAVICS)
# + Adds leukemia Subtype from meta_sj (matched by sample ID)
# ================================================================
# Keeps: sample, top_ct, genotype, Subtype
# Filters to top_ct == "ProB"
# Writes CSV: only_proB_samples_savics.csv
# ================================================================

stopifnot(exists("prom_dom_tbl_ord"))
stopifnot(exists("meta_sj"))

library(dplyr)
library(readr)

# ---- Prepare subtype lookup (defensive: unique per sample) ----
meta_subtype <- meta_sj %>%
  dplyr::select(Sample, Subtype) %>%
  dplyr::distinct()

# ---- Build ProB-only table + join subtype ----
only_proB_samples <- prom_dom_tbl_ord %>%
  dplyr::select(sample, top_ct, genotype) %>%
  dplyr::filter(top_ct == "ProB") %>%
  dplyr::left_join(
    meta_subtype,
    by = c("sample" = "Sample")
  )

# ---- Guardrails ----
# 1) No duplicated samples
stopifnot(!anyDuplicated(only_proB_samples$sample))

# 2) Report missing subtype annotations (do NOT hard-stop)
n_missing_subtype <- sum(is.na(only_proB_samples$Subtype))
if (n_missing_subtype > 0) {
  warning(
    "[WARN] ", n_missing_subtype,
    " ProB samples have no Subtype annotation in meta_sj"
  )
}

# ---- Write CSV ----
readr::write_csv(
  only_proB_samples,
  file = "only_proB_samples_savics.csv"
)

cat("\n[EXPORT] ProB-only samples with Subtype saved to 'only_proB_samples_savics.csv'\n")
cat("[INFO] Rows written: ", nrow(only_proB_samples), "\n", sep = "")
cat("[INFO] Missing Subtype annotations: ", n_missing_subtype, "\n", sep = "")

```


#### Enhancer only Savic

```{r}
# =====================================================================
# ATAC — Savics S3 ENHANCERS-ONLY dominance map WITH LIFTOVER (hg19 → hg38)
# SINGLE-LABEL ONLY (drop comma-lists) + audits + HEATMAP
# Conservative enhancer definition (NOT promoter/TSS)
# ALL objects prefixed with `enh_`
# =====================================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(readxl)
  library(tibble)
  library(pheatmap)
  library(stringr)
  library(GenomicRanges)
  library(rtracklayer)
  library(GenomeInfoDb)
  library(R.utils)
})

cat("\n===============================================================\n")
cat("ATAC SAVICS (ENHANCERS ONLY) — LIFTOVER + OVERLAP + COLUMN-SCALED MODULES\n")
cat("SINGLE-LABEL ONLY (drop comma-list progenitors) + audits + heatmap\n")
cat("===============================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts"))  stop("[0] ERROR: `counts` not found.")
if (!exists("meta_sj")) stop("[0] ERROR: `meta_sj` not found.")
if (!exists("anno_df")) stop("[0] ERROR: `anno_df` not found.")
if (!all(c("seqnames","start","end","peak_id") %in% colnames(anno_df))) {
  stop("[0] ERROR: anno_df must contain: seqnames, start, end, peak_id.")
}

cat("[0] counts dim (peaks × samples): ", paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols):    ", paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 0a — Normalization confirmation (pre-flight)
# ---------------------------------------------------------------------
cat("\n[0a] NORMALIZATION CHECK (counts):\n")

enh_lib_all <- suppressWarnings(colSums(counts))
enh_lib_all <- enh_lib_all[is.finite(enh_lib_all)]
enh_cv_all  <- if (length(enh_lib_all) > 1) stats::sd(enh_lib_all) / mean(enh_lib_all) else NA_real_

print(summary(enh_lib_all))
cat("[0a] Library-size CV (all peaks): ", signif(enh_cv_all, 4), "\n", sep = "")

set.seed(1)
enh_nr <- nrow(counts); enh_nc <- ncol(counts)
enh_r_idx <- if (enh_nr > 0) sample.int(enh_nr, size = min(2000, enh_nr)) else integer(0)
enh_c_idx <- if (enh_nc > 0) sample.int(enh_nc, size = min(50, enh_nc)) else integer(0)
enh_vals  <- as.numeric(counts[enh_r_idx, enh_c_idx, drop = FALSE])
enh_vals  <- enh_vals[is.finite(enh_vals)]
enh_is_integerish <- if (length(enh_vals) > 0) all(abs(enh_vals - round(enh_vals)) < 1e-6) else NA

cat("[0a] counts look integer-like (sampled): ", enh_is_integerish, "\n", sep = "")
if (isTRUE(enh_is_integerish) && is.finite(enh_cv_all) && enh_cv_all > 0.10) {
  cat("[0a] NOTE: counts appear RAW (integer + variable library sizes). ",
      "Per-peak z-scoring is NOT library-size normalization.\n", sep = "")
}

# ---------------------------------------------------------------------
# 0b — Detect enhancer annotation column
# ---------------------------------------------------------------------
cat("\n[0b] Detecting enhancer peaks in anno_df...\n")

enh_anno_chr_cols <- names(anno_df)[
  vapply(anno_df, function(x) is.character(x) || is.factor(x), logical(1))
]
enh_anno_chr_cols <- setdiff(enh_anno_chr_cols, c("seqnames", "peak_id"))

if (length(enh_anno_chr_cols) == 0) {
  stop("[0b] ERROR: No character/factor columns found in anno_df.")
}

enh_annot_like <- enh_anno_chr_cols[
  grepl("annot|feature|region|genomic|type|class", tolower(enh_anno_chr_cols))
]
if (length(enh_annot_like) == 0) enh_annot_like <- enh_anno_chr_cols

enh_enhancer_rate <- vapply(
  enh_annot_like,
  function(col) {
    x <- tolower(as.character(anno_df[[col]]))
    mean(grepl("enhancer|distal|intergenic|intron", x), na.rm = TRUE)
  },
  numeric(1)
)

enh_best_col  <- enh_annot_like[which.max(enh_enhancer_rate)]
enh_best_rate <- max(enh_enhancer_rate)

print(utils::head(sort(enh_enhancer_rate, decreasing = TRUE), 10))

if (!is.finite(enh_best_rate) || enh_best_rate < 0.005) {
  stop("[0b] ERROR: No column shows enhancer-like strings at sufficient frequency.")
}

cat("[0b] Using column '", enh_best_col,
    "' (enhancer hit-rate ~", signif(enh_best_rate, 3), ").\n", sep = "")

enh_anno_enhancers_df <- anno_df %>%
  dplyr::mutate(.anno = tolower(as.character(.data[[enh_best_col]]))) %>%
  dplyr::filter(!grepl("promoter|tss", .data$.anno)) %>%
  dplyr::filter(grepl("enhancer|distal|intergenic|intron", .data$.anno)) %>%
  dplyr::select(-.data$.anno)

cat("[0b] Enhancer peaks in anno_df: ", nrow(enh_anno_enhancers_df), "\n", sep = "")
if (nrow(enh_anno_enhancers_df) == 0L) stop("[0b] ERROR: enhancer filter produced 0 rows.")

# ---------------------------------------------------------------------
# 0c — Chain file
# ---------------------------------------------------------------------
enh_chain_gz  <- "hg19ToHg38.over.chain.gz"
enh_chain_txt <- "hg19ToHg38.over.chain"

if (!file.exists(enh_chain_gz)) stop("[0c] ERROR: Chain .gz not found.")

if (!file.exists(enh_chain_txt)) {
  R.utils::gunzip(enh_chain_gz, destname = enh_chain_txt, overwrite = TRUE, remove = FALSE)
}

enh_chain <- rtracklayer::import.chain(enh_chain_txt)

# ---------------------------------------------------------------------
# 1 — Load Savics S3 hg19 peaks (single-label)
# ---------------------------------------------------------------------
enh_savics_raw <- readxl::read_xlsx("Savics_S3.xlsx")
enh_ct_levels  <- c("HSC","MPP","LMPP","CLP","PreProB","ProB","CD19CD20")

enh_savics_hg19_df <- enh_savics_raw %>%
  as.data.frame() %>%
  dplyr::mutate(
    chr = as.character(.data$chr),
    start = as.integer(.data$start),
    stop  = as.integer(.data$stop),
    Defining_Progenitor = stringr::str_trim(as.character(.data$Defining_Progenitor))
  ) %>%
  dplyr::filter(
    !is.na(.data$chr),
    !is.na(.data$start),
    !is.na(.data$stop),
    !is.na(.data$Defining_Progenitor),
    .data$Defining_Progenitor %in% enh_ct_levels,
    !stringr::str_detect(.data$Defining_Progenitor, ",")
  ) %>%
  dplyr::distinct(.data$chr, .data$start, .data$stop, .data$Defining_Progenitor)

# ---------------------------------------------------------------------
# 1c — liftOver hg19 → hg38
# ---------------------------------------------------------------------
enh_gr_hg19 <- GenomicRanges::GRanges(
  seqnames = enh_savics_hg19_df$chr,
  ranges   = IRanges::IRanges(start = enh_savics_hg19_df$start,
                              end   = enh_savics_hg19_df$stop)
)

enh_gr_hg38_list <- rtracklayer::liftOver(enh_gr_hg19, enh_chain)
enh_orig_idx <- rep(seq_along(enh_gr_hg19), lengths(enh_gr_hg38_list))
enh_gr_hg38  <- unlist(enh_gr_hg38_list)

enh_savics_hg38_df <- enh_savics_hg19_df[enh_orig_idx, , drop = FALSE] %>%
  dplyr::mutate(
    chr_hg38   = as.character(GenomeInfoDb::seqnames(enh_gr_hg38)),
    start_hg38 = as.integer(GenomicRanges::start(enh_gr_hg38)),
    stop_hg38  = as.integer(GenomicRanges::end(enh_gr_hg38))
  )

# ---------------------------------------------------------------------
# 2 — Overlap to SJ156 ENHANCERS
# ---------------------------------------------------------------------
enh_sj_gr <- GenomicRanges::GRanges(
  seqnames = as.character(enh_anno_enhancers_df$seqnames),
  ranges   = IRanges::IRanges(start = enh_anno_enhancers_df$start,
                              end   = enh_anno_enhancers_df$end),
  peak_id  = enh_anno_enhancers_df$peak_id
)

enh_hits <- GenomicRanges::findOverlaps(
  query = GenomicRanges::GRanges(
    seqnames = enh_savics_hg38_df$chr_hg38,
    ranges   = IRanges::IRanges(start = enh_savics_hg38_df$start_hg38,
                                end   = enh_savics_hg38_df$stop_hg38)
  ),
  subject = enh_sj_gr,
  ignore.strand = TRUE
)

enh_overlap_df <- tibble::tibble(
  peak_id = as.character(S4Vectors::mcols(enh_sj_gr)$peak_id[S4Vectors::subjectHits(enh_hits)]),
  Defining_Progenitor = enh_savics_hg38_df$Defining_Progenitor[S4Vectors::queryHits(enh_hits)]
) %>%
  dplyr::distinct()

# ---------------------------------------------------------------------
# 3 — Restrict to peaks in counts
# ---------------------------------------------------------------------
enh_peaks_in_counts <- intersect(unique(enh_overlap_df$peak_id), rownames(counts))
if (length(enh_peaks_in_counts) == 0L) stop("[3] ERROR: No enhancer peak_id in counts.")

enh_long_use <- enh_overlap_df %>%
  dplyr::filter(.data$peak_id %in% enh_peaks_in_counts)

# ---------------------------------------------------------------------
# 4 — Z-scoring
# ---------------------------------------------------------------------
enh_counts_mat <- counts[enh_peaks_in_counts, , drop = FALSE]
enh_z_peak <- t(scale(t(enh_counts_mat)))
enh_z_peak[is.na(enh_z_peak)] <- 0

# ---------------------------------------------------------------------
# 5 — Expand peak × progenitor
# ---------------------------------------------------------------------
enh_expanded <- enh_long_use %>%
  dplyr::mutate(row_id = paste(.data$peak_id, .data$Defining_Progenitor, sep="|")) %>%
  dplyr::left_join(
    enh_z_peak %>% as.data.frame() %>% tibble::rownames_to_column("peak_id"),
    by = "peak_id"
  )

enh_mat_expanded <- enh_expanded %>%
  dplyr::select(-.data$peak_id, -.data$Defining_Progenitor) %>%
  tibble::column_to_rownames("row_id") %>%
  as.matrix()

enh_ct_for_row <- enh_expanded$Defining_Progenitor
names(enh_ct_for_row) <- rownames(enh_mat_expanded)

# ---------------------------------------------------------------------
# 6 — Raw module matrix
# ---------------------------------------------------------------------
enh_avg_raw <- do.call(
  rbind,
  lapply(enh_ct_levels, function(ct) {
    idx <- which(enh_ct_for_row == ct)
    if (length(idx) == 0L) rep(NA_real_, ncol(enh_mat_expanded))
    else colMeans(enh_mat_expanded[idx, , drop = FALSE], na.rm = TRUE)
  })
)
rownames(enh_avg_raw) <- enh_ct_levels

# ---------------------------------------------------------------------
# 7 — Column-wise scaling
# ---------------------------------------------------------------------
enh_avg_scaled <- scale(enh_avg_raw, center = TRUE, scale = TRUE)
enh_avg_scaled[is.na(enh_avg_scaled)] <- 0

# ---------------------------------------------------------------------
# 8 — Dominance + margins
# ---------------------------------------------------------------------
enh_top_idx    <- apply(enh_avg_scaled, 2, which.max)
enh_second_idx <- apply(enh_avg_scaled, 2, function(v) order(v, decreasing = TRUE)[2])

enh_dom_tbl <- tibble::tibble(
  sample       = colnames(enh_avg_scaled),
  top_ct       = enh_ct_levels[enh_top_idx],
  top_score    = enh_avg_scaled[cbind(enh_top_idx, seq_along(enh_top_idx))],
  second_ct    = enh_ct_levels[enh_second_idx],
  second_score = enh_avg_scaled[cbind(enh_second_idx, seq_along(enh_second_idx))]
) %>%
  dplyr::mutate(margin = .data$top_score - .data$second_score) %>%
  dplyr::left_join(
    meta_sj %>% dplyr::select("Sample", "genotype"),
    by = c("sample" = "Sample")
  )

# ---------------------------------------------------------------------
# 9 — Order samples
# ---------------------------------------------------------------------
enh_col_order <- order(
  factor(enh_dom_tbl$top_ct, levels = enh_ct_levels),
  -enh_dom_tbl$margin,
  -enh_dom_tbl$top_score
)

enh_avg_scaled_ord <- enh_avg_scaled[, enh_col_order, drop = FALSE]
enh_dom_tbl_ord    <- enh_dom_tbl[enh_col_order, ]

# ---------------------------------------------------------------------
# 10 — Annotation + heatmap
# ---------------------------------------------------------------------
enh_margin_q <- dplyr::ntile(enh_dom_tbl_ord$margin, 4)

enh_ann_col <- data.frame(
  top_ct   = factor(enh_dom_tbl_ord$top_ct, levels = enh_ct_levels),
  margin   = factor(c("Q1 (lowest)","Q2","Q3","Q4 (highest)")[enh_margin_q],
                    levels = c("Q1 (lowest)","Q2","Q3","Q4 (highest)")),
  genotype = enh_dom_tbl_ord$genotype,
  row.names = enh_dom_tbl_ord$sample
)

pheatmap::pheatmap(
  enh_avg_scaled_ord,
  color             = savics_z_col_fun,
  cluster_rows      = FALSE,
  cluster_cols      = FALSE,
  show_colnames     = FALSE,
  annotation_col    = enh_ann_col,
  annotation_colors = list(
    top_ct   = savics_cell_type_colors,
    margin   = margin_colors,
    genotype = genotype_colors
  ),
  border_color = NA,
  main = "ATAC module activity Savic's markers [ENHANCERS]"
)

cat("\n[SAVICS ENHANCERS] DONE — enh_ prefixed, dplyr:: explicit, logic preserved.\n")

```




#### Saving SAVICS for SJ19

```{r}
# ============================================================
# A — Save global Savics objects for reuse (ATAC + RNA-seq)
#     Run AFTER section 1c (when savics_hg38_df exists)
# ============================================================

suppressPackageStartupMessages({
    library(GenomicRanges)
    library(tibble)
})

# Directory where you want to keep shared Savics objects
savics_shared_dir <- "savics_shared_objects"  # <-- change path if you prefer
if (!dir.exists(savics_shared_dir)) {
    dir.create(savics_shared_dir, recursive = TRUE, showWarnings = FALSE)
}

# Ensure savics_ct_levels exists (in case not yet defined above)
if (!exists("savics_ct_levels")) {
    savics_ct_levels <- c("HSC", "MPP", "LMPP", "CLP", "PreProB", "ProB", "CD19CD20")
}

# GRanges with hg38 coordinates + progenitor label
savics_gr_hg38_global <- GenomicRanges::GRanges(
    seqnames = savics_hg38_df$chr_hg38,
    ranges   = IRanges::IRanges(
        start = savics_hg38_df$start_hg38,
        end   = savics_hg38_df$stop_hg38
    ),
    Defining_Progenitor = savics_hg38_df$Defining_Progenitor
)

# Save as RDS
saveRDS(
    savics_hg38_df,
    file = file.path(savics_shared_dir, "savics_hg38_df.rds")
)

saveRDS(
    savics_ct_levels,
    file = file.path(savics_shared_dir, "savics_ct_levels.rds")
)

saveRDS(
    savics_gr_hg38_global,
    file = file.path(savics_shared_dir, "savics_gr_hg38_global.rds")
)

cat("\n[SAVICS-SAVE] Saved global Savics objects:\n",
    "  - savics_hg38_df        → ", file.path(savics_shared_dir, "savics_hg38_df.rds"), "\n",
    "  - savics_ct_levels      → ", file.path(savics_shared_dir, "savics_ct_levels.rds"), "\n",
    "  - savics_gr_hg38_global → ", file.path(savics_shared_dir, "savics_gr_hg38_global.rds"), "\n\n", sep = "")

```

### Counting TC
```{r}
# ============================================================
# ATAC rs7090445 — TC allele imbalance stratified by cell state
#   (NA cell states EXCLUDED + FIXED depth-weighted T fraction)
# ============================================================
# Requires:
#   - ct_only           : Sample, C, T, ct_state (TT / TC / CC)
#   - dominant_tbl_ATAC : sample, top_ct (Ilaria dominance)
#
# Notes:
#   - Analysis restricted to TC samples only
#   - Samples without a dominant cell state are EXCLUDED
#   - Per-sample null expectation: Tfrac = 0.5
#   - Depth-weighted allele fraction per cell state is computed as:
#         depth_weighted_Tfrac = sum(T) / sum(T + C)
# ============================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tibble)
})

cat("\n============================================================\n")
cat("ATAC rs7090445 — TC ALLELE IMBALANCE BY CELL STATE (CLEAN + WEIGHTED FIX)\n")
cat("============================================================\n\n")

# ------------------------------------------------------------
# 0 — Sanity checks
# ------------------------------------------------------------
cat("[CHECK] Required columns in ct_only:\n")
req_ct <- c("Sample","C","T","ct_state")
cat("  • present? ", paste(req_ct %in% colnames(ct_only), collapse = ", "), "\n", sep = "")
stopifnot(all(req_ct %in% colnames(ct_only)))

cat("[CHECK] Required columns in dominant_tbl_ATAC:\n")
req_dom <- c("sample","top_ct")
cat("  • present? ", paste(req_dom %in% colnames(dominant_tbl_ATAC), collapse = ", "), "\n\n", sep = "")
stopifnot(all(req_dom %in% colnames(dominant_tbl_ATAC)))

# ------------------------------------------------------------
# 1 — Restrict to TC and join dominant cell state
# ------------------------------------------------------------
cat("[STEP 1] Subsetting ct_only to TC and joining dominant cell state...\n")

tc_df_all <- ct_only %>%
    dplyr::filter(ct_state == "TC") %>%
    dplyr::left_join(
        dominant_tbl_ATAC %>%
            dplyr::select(sample, top_ct),
        by = c("Sample" = "sample")
    ) %>%
    dplyr::mutate(
        total_reads = T + C,
        Tfrac       = dplyr::if_else(total_reads > 0, T / total_reads, NA_real_)
    )

cat("[CHECK] Total TC samples (before excluding NA top_ct): ", nrow(tc_df_all), "\n", sep = "")
cat("[CHECK] TC samples with missing top_ct: ", sum(is.na(tc_df_all$top_ct)), "\n", sep = "")

if (sum(is.na(tc_df_all$top_ct)) > 0) {
    cat("[INFO] TC samples excluded due to missing cell-state assignment (not in dominant_tbl_ATAC):\n")
    print(tc_df_all %>% dplyr::filter(is.na(top_ct)) %>% dplyr::pull(Sample))
}
cat("\n")

# ------------------------------------------------------------
# 1.1 — EXCLUDE samples without dominant cell state
# ------------------------------------------------------------
tc_df <- tc_df_all %>%
    dplyr::filter(!is.na(top_ct))

cat("[CHECK] TC samples retained AFTER exclusion: ", nrow(tc_df), "\n", sep = "")
cat("[CHECK] Cell-state distribution (TC only; valid states):\n")
print(sort(table(tc_df$top_ct), decreasing = TRUE))
cat("\n")

cat("[QC] Total reads (T+C) per TC sample — summary:\n")
print(summary(tc_df$total_reads))
cat("\n")

cat("[QC] Per-sample Tfrac summary in TC (null ~0.5 if no imbalance):\n")
print(summary(tc_df$Tfrac))
cat("\n")

# ------------------------------------------------------------
# 2 — Per–cell-type summaries (FIXED weighted fraction)
# ------------------------------------------------------------
cat("[STEP 2] Computing per–cell-type summaries (TC only; valid states)...\n")
cat("         depth_weighted_Tfrac = sum(T) / sum(T + C)\n\n")

tc_summary_ct <- tc_df %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        n_samples            = dplyr::n(),
        sum_T                = sum(T, na.rm = TRUE),
        sum_C                = sum(C, na.rm = TRUE),
        sum_total_reads      = sum(total_reads, na.rm = TRUE),
        mean_total_reads     = mean(total_reads, na.rm = TRUE),
        median_total_reads   = median(total_reads, na.rm = TRUE),
        mean_Tfrac           = mean(Tfrac, na.rm = TRUE),
        median_Tfrac         = median(Tfrac, na.rm = TRUE),
        depth_weighted_Tfrac = dplyr::if_else(sum_total_reads > 0, sum_T / sum_total_reads, NA_real_),
        .groups = "drop"
    ) %>%
    dplyr::arrange(dplyr::desc(depth_weighted_Tfrac))

cat("[RESULT] Per–cell-type allele balance summary (TC only; CLEAN):\n")
print(tc_summary_ct)
cat("\n")

cat("[RESULT] Same summary as MARKDOWN (easy to paste to client):\n")
if (requireNamespace("knitr", quietly = TRUE)) {
    cat(knitr::kable(tc_summary_ct, format = "markdown", digits = 4))
    cat("\n\n")
} else {
    cat("  (knitr not available; printing tibble above instead.)\n\n")
}

# ------------------------------------------------------------
# 3 — Cell-type–specific statistical tests + read-count context
# ------------------------------------------------------------
cat("[STEP 3] Cell-type–specific tests + read-count context...\n")
cat("         • Wilcoxon on per-sample Tfrac: H0 median(Tfrac)=0.5 (n>=5 only)\n")
cat("         • Binomial on aggregated reads: H0 p(T)=0.5 (informative but read-level)\n\n")

tc_tests_ct <- tc_df %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        n_samples            = dplyr::n(),
        sum_T                = sum(T, na.rm = TRUE),
        sum_C                = sum(C, na.rm = TRUE),
        sum_total_reads      = sum(T + C, na.rm = TRUE),
        depth_weighted_Tfrac = dplyr::if_else(sum_total_reads > 0, sum_T / sum_total_reads, NA_real_),
        wilcox_p             = if (dplyr::n() >= 5)
            stats::wilcox.test(Tfrac, mu = 0.5, exact = FALSE)$p.value
        else
            NA_real_,
        binom_p              = if (sum_total_reads > 0)
            stats::binom.test(x = sum_T, n = sum_total_reads, p = 0.5, alternative = "two.sided")$p.value
        else
            NA_real_,
        .groups = "drop"
    ) %>%
    dplyr::arrange(dplyr::desc(depth_weighted_Tfrac))

cat("[STATS] Tests per cell state (TC only; CLEAN):\n")
print(tc_tests_ct)
cat("\n")

cat("[STATS] Same test table as MARKDOWN (easy to paste to client):\n")
if (requireNamespace("knitr", quietly = TRUE)) {
    cat(knitr::kable(tc_tests_ct, format = "markdown", digits = 6))
    cat("\n\n")
} else {
    cat("  (knitr not available; printing tibble above instead.)\n\n")
}

cat("============================================================\n")
cat("[DONE] NA cell states excluded; depth-weighted Tfrac fixed; tests include read counts.\n")
cat("============================================================\n\n")

```



## What is the overlap of samples called proB cells between Ilarias and Savics? How consistent is the sample being called a 'ProB' accross all of them. prepro and


```{r}

```




CLP from Savics overlapping with early lymphoid from Ilarias
