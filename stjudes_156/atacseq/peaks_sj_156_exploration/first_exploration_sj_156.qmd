# 1 Setup and global options
## 1.1 Load libraries
```{r}
## 1.1 Load libraries and global parameters -------------------------------
suppressPackageStartupMessages({
  library(dplyr)
  library(ggplot2)
  library(tidyr)
  library(DESeq2)
  library(matrixStats)
  library(GenomicRanges)
  library(GenomeInfoDb)
  library(ChIPseeker)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(org.Hs.eg.db)
})

half_batches <- read.csv("../../half_batches_3_156sj.csv")
second_batches <- read.csv("snp_summary_with_flags_all_batches.csv")

# Remove the 'X' column from half_batches
half_batches_clean <- half_batches[, !(colnames(half_batches) %in% "X")]

# Row-bind the cleaned half_batches with second_batches
combined_batches <- rbind(half_batches_clean, second_batches)

# Check the result
head(combined_batches)

## Global parameters for PCA filters
MIN_READS_PCA   <- 10L     # min counts per peak
MIN_SAMPLES_PCA <- 5L      # min samples with counts >= MIN_READS_PCA
N_TOP_VAR_PCA   <- 50000L  # max number of most-variable peaks

## Color palettes used throughout
allele_cols <- c(T = "#E4007C", C = "#D3AF37")             # T (pink), C (gold)
geno_cols   <- c(TT = "#E4007C", TC = "#4F6D7A", CC = "#D3AF37")  # genotype colors


```

# 2. SNP C/T profiles and genotype metadata
## 2.1 Load SNP summary tables and merge

```{r}
## 2.1 Load SNP summary tables and merge ---------------------------------

half_batches <- read.csv("../../half_batches_3_156sj.csv")
second_batches <- read.csv("snp_summary_with_flags_all_batches.csv")

## Remove the generic 'X' column (row index) if present
half_batches_clean <- half_batches %>%
  dplyr::select(-any_of("X"))

## Sanity check: column sets should match before binding
stopifnot(
  identical(
    sort(colnames(half_batches_clean)),
    sort(colnames(second_batches))
  )
)

## Safer row-bind (respects column names)
combined_batches <- dplyr::bind_rows(half_batches_clean, second_batches)

## Rename ALT.% column once to a safer name
combined_batches <- combined_batches %>%
  dplyr::rename(ALT_pct = `ALT.`)

## Quick look
head(combined_batches)

```


## 2.2 Derive C/T-based coverage state and T fraction

```{r}
## 2.2 Derive C/T-based coverage state and T fraction --------------------

ct_only <- combined_batches %>%
  transmute(
    Sample,
    C,
    T,
    ct_state = case_when(
      T > 0 & C == 0 ~ "TT",
      T > 0 & C > 0  ~ "TC",
      C > 0 & T == 0 ~ "CC",
      TRUE           ~ "NoCov"     # no coverage / weird combinations
    ),
    Tfrac = if_else(C + T > 0, T / (C + T), NA_real_)
  )

## Order: TT -> TC -> CC -> NoCov, and within each by decreasing Tfrac
sample_levels <- ct_only %>%
  arrange(
    factor(ct_state, levels = c("TT", "TC", "CC", "NoCov")),
    desc(Tfrac)
  ) %>%
  pull(Sample)

```

## 2.3 Define genotype from ALT percentage and QC vs C/T-based state

```{r}
## 2.3 Define genotype from ALT% and QC vs C/T-based state ---------------

combined_batches <- combined_batches %>%
  mutate(
    genotype = case_when(
      ALT_pct == 100 ~ "TT",
      ALT_pct == 0   ~ "CC",
      between(ALT_pct, 1, 99) ~ "TC",
      TRUE ~ NA_character_
    )
  )

## Join C/T state and genotype to check consistency
geno_qc <- ct_only %>%
  left_join(combined_batches %>% dplyr::select(Sample, genotype),
            by = "Sample")

## Cross-tabulation for QC (optional: inspect in console)
geno_qc_table <- table(geno_qc$ct_state, geno_qc$genotype, useNA = "ifany")
geno_qc_table

```

## 2.4 Barplot of C vs T counts per sample (ordered by genotype & Tfrac)
```{r}
## 2.4 Barplot of C vs T counts per sample -------------------------------

snp_long <- ct_only %>%
  dplyr::select(Sample, C, T) %>%
  pivot_longer(cols = c(C, T),
               names_to = "Base",
               values_to = "Count") %>%
  mutate(
    Sample = factor(Sample, levels = sample_levels),
    Base   = factor(Base, levels = c("T", "C"))  # T on top of C in stacks
  )

ggplot(snp_long, aes(x = Sample, y = Count, fill = Base)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = allele_cols) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(
      angle = 90, hjust = 1, vjust = 0.5, size = 12
    ),
    axis.text.y   = element_text(size = 12),
    axis.title.x  = element_text(size = 16),
    axis.title.y  = element_text(size = 16),
    legend.title  = element_text(size = 14),
    legend.text   = element_text(size = 12),
    plot.title    = element_text(size = 18, face = "bold"),
    panel.grid.major.x = element_blank()
  ) +
  labs(
    title = "C vs T counts per sample (ordered by C/T state and T fraction)",
    x = "Sample",
    y = "Read count",
    fill = "Allele"
  )

```


# 3. ATAC consensus peak matrix and genomic annotation
## 3.1 Load featureCounts output and build counts matrix

```{r}
## 3.1 Load featureCounts matrix -----------------------------------------

fc <- read.delim(
  "consensus_peaks.mLb.clN.featureCounts.txt",
  header       = TRUE,
  comment.char = "#",
  check.names  = FALSE   # keep original sample names
)

## Split annotation vs counts
anno   <- fc[, 1:6]
counts <- as.matrix(fc[, -(1:6)])

rownames(counts) <- anno$Geneid
storage.mode(counts) <- "integer"

## Clean column names: strip full paths and reduce to "ATAC_XX_REP1"
colnames(counts) <- basename(colnames(counts))
colnames(counts) <- sub("^(ATAC_\\d+_REP1).*", "\\1", colnames(counts))

## Sanity: Length should equal (End - Start + 1); hard stop if not
stopifnot(all(anno$Length == (anno$End - anno$Start + 1)))

```


## 3.2 Build GRanges object and keep standard chromosomes

```{r}
## 3.2 Build GRanges and keep standard chromosomes -----------------------

gr <- GRanges(
  seqnames = anno$Chr,
  ranges   = IRanges(start = anno$Start, end = anno$End),
  strand   = ifelse(anno$Strand %in% c("+", "-"), anno$Strand, "*")
)
names(gr) <- anno$Geneid

## Harmonize chromosome naming style with TxDb (UCSC style: chr1, chr2, ...)
seqlevelsStyle(gr) <- "UCSC"

## Restrict to canonical chromosomes; drop chrM and unused levels
gr <- keepStandardChromosomes(gr, pruning.mode = "coarse")   # chr1–22, chrX, chrY, chrM
gr <- keepSeqlevels(gr, setdiff(seqlevels(gr), "chrM"), pruning.mode = "coarse")
gr <- keepSeqlevels(gr, seqlevelsInUse(gr), pruning.mode = "coarse")

## Align counts rows to GRanges after chromosome filtering
common_ids <- intersect(rownames(counts), names(gr))
stopifnot(length(common_ids) > 0)

counts <- counts[common_ids, , drop = FALSE]
gr     <- gr[common_ids]

```


## 3.3 Annotate peaks with ChIPseeker (±1 kb around TSS)

```{r}
## 3.3 Annotate peaks with ChIPseeker (±1 kb TSS) ------------------------

txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

peakAnno <- annotatePeak(
  gr,
  TxDb      = txdb,
  tssRegion = c(-1000, 1000),   # promoter window; report this in Methods
  annoDb    = "org.Hs.eg.db",
  level     = "gene"
)

anno_df <- as.data.frame(peakAnno)

## Attach peak IDs as a stable key
stopifnot(nrow(anno_df) == length(gr))
anno_df$peak_id <- names(gr)

## Minimal gene-centric annotation you'll reuse downstream
gene_anno_min <- anno_df[, c("peak_id", "SYMBOL", "geneId", "annotation", "distanceToTSS")]

```


# 4. PCA of ATAC peaks by genotype (pre-subtype)
## 4.1 Build ATAC metadata from SNP genotypes

```{r}
## 4.1 Build ATAC metadata from SNP genotypes -----------------------------

## Start from combined_batches (which already has ALT_pct and genotype)
meta <- combined_batches %>%
  dplyr::select(Sample, genotype, ALT_pct) %>%
  dplyr::mutate(
    Sample   = as.character(Sample),
    genotype = factor(genotype, levels = c("TT", "TC", "CC"))
  ) %>%
  dplyr::distinct(Sample, .keep_all = TRUE)

## Align metadata to counts columns
samples_in_counts <- intersect(colnames(counts), meta$Sample)
stopifnot(length(samples_in_counts) > 0)

meta_sub <- meta %>%
  dplyr::filter(Sample %in% samples_in_counts) %>%
  dplyr::arrange(match(Sample, colnames(counts)))

## Optional: report samples present in counts but missing in meta
missing_meta <- setdiff(colnames(counts), meta_sub$Sample)
if (length(missing_meta) > 0) {
  message("Samples in counts without metadata (will be dropped): ",
          paste(missing_meta, collapse = ", "))
}

## Subset counts to samples with metadata and enforce same order
counts_sub <- counts[, meta_sub$Sample, drop = FALSE]

```

## 4.2 PCA of all peaks by genotype

```{r}
## 4.2 PCA of all peaks by genotype --------------------------------------

## Filter peaks for PCA stability
keep <- rowSums(counts_sub >= MIN_READS_PCA) >= MIN_SAMPLES_PCA
counts_filt <- counts_sub[keep, , drop = FALSE]

## Restrict to top-N most variable peaks
if (nrow(counts_filt) > N_TOP_VAR_PCA) {
  v <- matrixStats::rowVars(as.matrix(counts_filt))
  o <- order(v, decreasing = TRUE)[seq_len(N_TOP_VAR_PCA)]
  counts_filt <- counts_filt[o, , drop = FALSE]
}
cat("Peaks retained for PCA (all peaks):", nrow(counts_filt), "\n")

## VST transform with DESeq2 (blind = TRUE for exploratory PCA)
dds <- DESeqDataSetFromMatrix(
  countData = counts_filt,
  colData   = as.data.frame(meta_sub),
  design    = ~ 1
)
dds <- estimateSizeFactors(dds)
vsd <- vst(dds, blind = TRUE)
mat <- assay(vsd)   # peaks x samples

## PCA on samples
pca <- prcomp(t(mat), center = TRUE, scale. = FALSE)
var_expl <- (pca$sdev^2) / sum(pca$sdev^2) * 100

pca_df <- data.frame(
  Sample   = meta_sub$Sample,
  genotype = meta_sub$genotype,
  ALT_pct  = meta_sub$ALT_pct,
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  PC3 = pca$x[, 3],
  stringsAsFactors = FALSE
)

ggplot(pca_df, aes(x = PC1, y = PC2, color = genotype)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = geno_cols, drop = FALSE) +
  labs(
    title = "PCA of VST-transformed ATAC peak counts (all peaks)",
    x     = paste0("PC1 (", round(var_expl[1], 1), "%)"),
    y     = paste0("PC2 (", round(var_expl[2], 1), "%)"),
    color = "Genotype"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title   = element_text(face = "bold"),
    legend.title = element_text(size = 12),
    legend.text  = element_text(size = 11)
  )
# + ggrepel::geom_text_repel(aes(label = Sample), max.overlaps = 50, size = 3)

## (Optional) export PCA scores
# write.table(pca_df, "PCA_scores_ATAC_all_peaks.tsv",
#             sep = "\t", quote = FALSE, row.names = FALSE)

```


## 4.3 PCA of promoter peaks only (pre-subtype)
```{r}
## 4.3 PCA of promoter peaks only (pre-subtype) --------------------------

## Select promoter peaks via ChIPseeker annotation
## ChIPseeker uses labels like "Promoter (<=1kb)"; strip the detail part
base_cat <- sub(" \\(.*\\)$", "", anno_df$annotation)
promoter_ids <- anno_df$peak_id[base_cat == "Promoter"]

## Intersect with available peaks in counts_sub
promoter_ids <- intersect(promoter_ids, rownames(counts_sub))
if (length(promoter_ids) == 0) {
  stop("No promoter peaks found after intersection with counts.")
}

counts_prom <- counts_sub[promoter_ids, , drop = FALSE]

## Filter promoter peaks for PCA stability
keep_prom <- rowSums(counts_prom >= MIN_READS_PCA) >= MIN_SAMPLES_PCA
counts_prom <- counts_prom[keep_prom, , drop = FALSE]
if (nrow(counts_prom) < 500) {
  message("Warning: <500 promoter peaks retained; consider relaxing filters.")
}

## Restrict to top-N most variable promoter peaks
if (nrow(counts_prom) > N_TOP_VAR_PCA) {
  v_prom <- matrixStats::rowVars(as.matrix(counts_prom))
  o_prom <- order(v_prom, decreasing = TRUE)[seq_len(N_TOP_VAR_PCA)]
  counts_prom <- counts_prom[o_prom, , drop = FALSE]
}
cat("Promoter peaks retained for PCA:", nrow(counts_prom), "\n")

## VST transform and PCA
dds_prom <- DESeqDataSetFromMatrix(
  countData = counts_prom,
  colData   = as.data.frame(meta_sub),
  design    = ~ 1
)
dds_prom <- estimateSizeFactors(dds_prom)
vsd_prom <- vst(dds_prom, blind = TRUE)
mat_prom <- assay(vsd_prom)

pca_prom <- prcomp(t(mat_prom), center = TRUE, scale. = FALSE)
var_expl_prom <- (pca_prom$sdev^2) / sum(pca_prom$sdev^2) * 100

pca_prom_df <- data.frame(
  Sample   = meta_sub$Sample,
  genotype = meta_sub$genotype,
  ALT_pct  = meta_sub$ALT_pct,
  PC1 = pca_prom$x[, 1],
  PC2 = pca_prom$x[, 2],
  stringsAsFactors = FALSE
)

ggplot(pca_prom_df, aes(x = PC1, y = PC2, color = genotype)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = geno_cols, drop = FALSE) +
  labs(
    title = "PCA of VST-transformed ATAC counts (promoter peaks only)",
    x     = paste0("PC1 (", round(var_expl_prom[1], 1), "%)"),
    y     = paste0("PC2 (", round(var_expl_prom[2], 1), "%)"),
    color = "Genotype"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title   = element_text(face = "bold"),
    legend.title = element_text(size = 12),
    legend.text  = element_text(size = 11)
  )

## (Optional) export promoter PCA scores
# write.table(pca_prom_df, "PCA_scores_ATAC_promoters.tsv",
#             sep = "\t", quote = FALSE, row.names = FALSE)

```



# 5. Integration of St. Jude molecular subtypes into PCA
## 5.1 Load subtype table and merge with ATAC metadata
```{r}
## 5.1 Load St. Jude subtype table and merge with ATAC meta --------------

suppressPackageStartupMessages(library(readxl))

## This assumes `meta` already exists from Section 4.1
## and contains columns: Sample, genotype, ALT_pct

sj_subtypes <- readxl::read_xlsx("mmc3 (2).xlsx")

## Harmonise sample IDs: ATAC_123_REP1 → ATAC_sample_123
meta_sj <- meta %>%
  dplyr::mutate(
    Sample_ID = gsub("ATAC_(\\d+)_REP1", "ATAC_sample_\\1", Sample)
  ) %>%
  dplyr::left_join(
    sj_subtypes %>% dplyr::select(Sample_ID, Subtype),
    by = "Sample_ID"
  )

## Optional: check how many samples got a subtype
table(is.na(meta_sj$Subtype))

```

## 5.2 Helper: PCA with genotype + subtype labels

```{r}
## 5.2 Helper to run PCA with genotype + subtype labels ------------------

run_atac_pca_with_subtype <- function(counts,
                                      meta_sj,
                                      peak_ids = NULL,
                                      title   = "PCA of VST-transformed ATAC counts") {
  stopifnot(is.matrix(counts))
  stopifnot(all(c("Sample", "genotype", "ALT_pct", "Subtype") %in% names(meta_sj)))

  ## 1) Align metadata to count matrix columns
  meta_sub <- meta_sj %>%
    dplyr::select(Sample, genotype, ALT_pct, Subtype) %>%
    dplyr::mutate(
      Sample   = as.character(Sample),
      genotype = factor(genotype, levels = c("TT", "TC", "CC"))
    ) %>%
    dplyr::distinct(Sample, .keep_all = TRUE)

  samples_in_counts <- intersect(colnames(counts), meta_sub$Sample)
  stopifnot(length(samples_in_counts) > 0)

  meta_sub <- meta_sub %>%
    dplyr::filter(Sample %in% samples_in_counts) %>%
    dplyr::arrange(match(Sample, colnames(counts)))

  counts_sub <- counts[, meta_sub$Sample, drop = FALSE]

  ## 2) Optional: restrict to given peak subset (e.g., promoters)
  if (!is.null(peak_ids)) {
    peak_ids <- intersect(peak_ids, rownames(counts_sub))
    if (length(peak_ids) == 0L) {
      stop("No peaks remain after intersecting `peak_ids` with count matrix rownames.")
    }
    counts_sub <- counts_sub[peak_ids, , drop = FALSE]
  }

  ## 3) Peak filtering for stable PCA
  keep <- rowSums(counts_sub >= MIN_READS_PCA) >= MIN_SAMPLES_PCA
  counts_filt <- counts_sub[keep, , drop = FALSE]

  if (nrow(counts_filt) == 0L) {
    stop("All peaks were filtered out; relax MIN_READS_PCA / MIN_SAMPLES_PCA.")
  }

  ## Restrict to top-N most variable peaks
  if (nrow(counts_filt) > N_TOP_VAR_PCA) {
    v <- matrixStats::rowVars(as.matrix(counts_filt))
    o <- order(v, decreasing = TRUE)[seq_len(N_TOP_VAR_PCA)]
    counts_filt <- counts_filt[o, , drop = FALSE]
  }

  cat("Peaks retained for PCA (",
      if (is.null(peak_ids)) "all" else "subset",
      "): ", nrow(counts_filt), "\n", sep = "")

  ## 4) VST and PCA
  dds <- DESeqDataSetFromMatrix(
    countData = counts_filt,
    colData   = as.data.frame(meta_sub),
    design    = ~ 1
  )
  dds <- estimateSizeFactors(dds)
  vsd <- vst(dds, blind = TRUE)
  mat <- assay(vsd)

  pca <- stats::prcomp(t(mat), center = TRUE, scale. = FALSE)
  var_expl <- (pca$sdev^2) / sum(pca$sdev^2) * 100

  pca_df <- data.frame(
    Sample   = meta_sub$Sample,
    genotype = meta_sub$genotype,
    ALT_pct  = meta_sub$ALT_pct,
    Subtype  = meta_sub$Subtype,
    PC1      = pca$x[, 1],
    PC2      = pca$x[, 2],
    stringsAsFactors = FALSE
  )

  p <- ggplot(pca_df, aes(PC1, PC2, color = genotype)) +
    geom_point(size = 3, alpha = 0.9) +
    ggrepel::geom_text_repel(
      aes(label = Subtype),
      size             = 4,
      max.overlaps     = Inf,
      min.segment.length = 0,
      box.padding      = 0.3,
      point.padding    = 0.2
    ) +
    scale_color_manual(values = geno_cols, drop = FALSE) +
    labs(
      title = title,
      x     = paste0("PC1 (", round(var_expl[1], 1), "%)"),
      y     = paste0("PC2 (", round(var_expl[2], 1), "%)"),
      color = "Genotype"
    ) +
    theme_bw(base_size = 14) +
    theme(
      plot.title   = element_text(face = "bold"),
      legend.title = element_text(size = 12),
      legend.text  = element_text(size = 11)
    )

  invisible(list(
    pca_df   = pca_df,
    var_expl = var_expl,
    plot     = p
  ))
}
```

## 5.3 PCA – all peaks with genotype + subtype labels
```{r}
## 5.3 PCA of all peaks with genotype + subtype --------------------------

res_pca_all_subtype <- run_atac_pca_with_subtype(
  counts  = counts,
  meta_sj = meta_sj,
  peak_ids = NULL,
  title   = "PCA of VST-transformed ATAC peak counts (ALL peaks, genotype + subtype)"
)

## To display the plot in an interactive session:
res_pca_all_subtype$plot

## Optional: export PCA scores
# write.table(res_pca_all_subtype$pca_df,
#             "PCA_scores_all_peaks_with_subtype.tsv",
#             sep = "\t", quote = FALSE, row.names = FALSE)

```

## 5.4 PCA – promoter peaks only with genotype + subtype labels

```{r}
## 5.4 PCA of promoter peaks only with genotype + subtype ----------------

## Select promoter peaks from ChIPseeker annotation
base_cat <- sub(" \\(.*\\)$", "", anno_df$annotation)   # strip "(<=1kb)" etc.
promoter_ids <- anno_df$peak_id[base_cat == "Promoter"]

if (length(promoter_ids) == 0L) {
  stop("No peaks are annotated as 'Promoter' in anno_df.")
}

res_pca_prom_subtype <- run_atac_pca_with_subtype(
  counts   = counts,
  meta_sj  = meta_sj,
  peak_ids = promoter_ids,
  title    = "PCA of VST-transformed ATAC counts (Promoter peaks only, genotype + subtype)"
)

## To display the plot:
# res_pca_prom_subtype$plot

## Optional: export promoter PCA scores
# write.table(res_pca_prom_subtype$pca_df,
#             "PCA_scores_promoters_with_subtype.tsv",
#             sep = "\t", quote = FALSE, row.names = FALSE)

```


# 6. Lineage module scores using Iacobucci panel (“Ilaria’s 700 genes”)
## 6.1 Load Iacobucci panel and reshape wide → long

* This chunk defines the lineage gene sets: for each B-cell stage, which genes belong to that “module”. Everything later (SJ/Spain modules, integration, etc.) is built on panel_long.

```{r}
## 6.1 Load Iacobucci panel and reshape wide → long ----------------------

suppressPackageStartupMessages({
  library(edgeR)
  library(pheatmap)
  library(stringr)
})

## Lineage order and colors (Iacobucci-like B-cell trajectory)
ct_levels <- c("HSCMPP", "GMP", "pDC", "EarlyLymphoid", "ProB", "PreB", "B")

cell_type_colors <- c(
  HSCMPP        = "#fb8072",
  GMP           = "#bebada",
  pDC           = "#ffd92f",
  EarlyLymphoid = "#f781bf",
  ProB          = "#ff33ff",
  PreB          = "#00e5c0",
  B             = "#00bfff"
)

margin_colors <- c(
  "Q1 (lowest)"  = "#c7e9c0",
  "Q2"           = "#a1d99b",
  "Q3"           = "#74c476",
  "Q4 (highest)" = "#238b45"
)

## Read pre-cleaned Iacobucci “700 genes” panel
panel_path <- "~/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/clean_ilarias_700_genes.csv"

panel_wide <- read.csv(panel_path, check.names = FALSE)

## Trim whitespace from all entries
panel_wide <- panel_wide %>%
  dplyr::mutate(dplyr::across(dplyr::everything(), ~ trimws(as.character(.)))) %>%
  { 
    ## If column names match ct_levels, reorder to that canonical order
    if (all(sort(names(.)) == sort(ct_levels))) {
      .[, ct_levels, drop = FALSE]
    } else {
      .
    }
  }

## Wide (columns = lineages) → long: (cell_type, gene)
panel_long <- panel_wide %>%
  tidyr::pivot_longer(
    cols      = dplyr::everything(),
    names_to  = "cell_type",
    values_to = "gene"
  ) %>%
  dplyr::filter(!is.na(gene), gene != "") %>%
  dplyr::mutate(cell_type = factor(cell_type, levels = ct_levels))

```


## 6.2 Align counts + annotation; helper to build module matrix



```{r}
## 6.2 Align counts rows to anno_df and define module helper --------------

## REQUIRE: `counts` (peaks x samples), `anno_df` with peak_id, SYMBOL, annotation
stopifnot(all(c("peak_id", "SYMBOL", "annotation") %in% names(anno_df)))

peaks_in_counts <- nrow(counts)
peaks_in_anno   <- length(unique(anno_df$peak_id))
common_peaks    <- intersect(rownames(counts), anno_df$peak_id)

cat("Peaks in counts: ",  peaks_in_counts, "\n",
    "Peaks in anno_df:", peaks_in_anno,   "\n",
    "Intersection:    ", length(common_peaks), "\n",
    "Dropped (counts - anno): ",
    peaks_in_counts - length(common_peaks), "\n", sep = "")

stopifnot(length(common_peaks) > 0L)

## Keep only peaks that have an annotation
counts_annot <- counts[common_peaks, , drop = FALSE]

## Helper to compute lineage module scores and heatmap --------------------
build_modules_from_atac <- function(count_mat,
                                    anno_tbl,
                                    panel_long,
                                    use_subset = c("all_gene_assigned", "promoter_only"),
                                    min_reads = 10,
                                    min_samples = 5,
                                    aggregator = c("max", "mean"),
                                    clip_z = 2) {
  use_subset <- match.arg(use_subset)
  aggregator <- match.arg(aggregator)

  ## 1) Restrict to annotated peaks (SYMBOL) and optionally to promoters
  anno_use <- anno_tbl %>%
    dplyr::filter(!is.na(SYMBOL), SYMBOL != "")

  if (use_subset == "promoter_only") {
    base_cat <- sub(" \\(.*\\)$", "", anno_use$annotation)
    anno_use <- anno_use[base_cat == "Promoter", , drop = FALSE]
  }

  peak_ids <- intersect(anno_use$peak_id, rownames(count_mat))
  if (length(peak_ids) == 0L) {
    stop("No peaks found for the chosen subset (", use_subset, ").")
  }

  ## 2) Basic peak filtering
  x <- count_mat[peak_ids, , drop = FALSE]
  keep <- rowSums(x >= min_reads) >= min_samples
  x <- x[keep, , drop = FALSE]
  if (nrow(x) == 0L) {
    stop("All peaks filtered out; relax min_reads / min_samples.")
  }

  ## 3) Library-size normalization → logCPM
  logcpm <- edgeR::cpm(x, log = TRUE, prior.count = 1)

  ## 4) Collapse peaks → genes using SYMBOL and chosen aggregator
  symb  <- anno_use$SYMBOL[match(rownames(logcpm), anno_use$peak_id)]
  logdf <- data.frame(SYMBOL = symb, as.data.frame(logcpm), check.names = FALSE)

  if (aggregator == "max") {
    gene_mat <- logdf %>%
      dplyr::group_by(SYMBOL) %>%
      dplyr::summarise(
        dplyr::across(where(is.numeric), ~ max(., na.rm = TRUE)),
        .groups = "drop"
      )
  } else {
    gene_mat <- logdf %>%
      dplyr::group_by(SYMBOL) %>%
      dplyr::summarise(
        dplyr::across(where(is.numeric), ~ mean(., na.rm = TRUE)),
        .groups = "drop"
      )
  }

  gene_mat <- as.data.frame(gene_mat)
  rownames(gene_mat) <- gene_mat$SYMBOL
  gene_mat$SYMBOL <- NULL
  gene_mat <- as.matrix(gene_mat)

  ## 5) Row z-score (genes) across samples; remove zero-variance; clip
  zero_var <- matrixStats::rowVars(gene_mat) == 0
  if (any(zero_var)) gene_mat <- gene_mat[!zero_var, , drop = FALSE]
  if (nrow(gene_mat) == 0L) {
    stop("No genes left after zero-variance filter.")
  }

  z_gene <- t(scale(t(gene_mat)))
  z_gene[is.na(z_gene)] <- 0
  if (!is.null(clip_z)) {
    z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
  }

  ## 6) Average z-score per lineage (panel gene sets)
  z_genes <- rownames(z_gene)
  avg_list <- lapply(levels(panel_long$cell_type), function(ct) {
    g_ct <- panel_long$gene[panel_long$cell_type == ct]
    g_ct <- intersect(unique(g_ct), z_genes)
    if (length(g_ct) == 0L) {
      rep(NA_real_, ncol(z_gene))
    } else {
      colMeans(z_gene[g_ct, , drop = FALSE])
    }
  })

  avg_z_by_ct <- do.call(rbind, avg_list)
  rownames(avg_z_by_ct) <- levels(panel_long$cell_type)
  colnames(avg_z_by_ct) <- colnames(z_gene)

  ## Drop lineages with no genes present
  all_na <- apply(avg_z_by_ct, 1, function(r) all(is.na(r)))
  if (any(all_na)) {
    message("Dropping lineages with no genes present in ATAC data: ",
            paste(rownames(avg_z_by_ct)[all_na], collapse = ", "))
    avg_z_by_ct <- avg_z_by_ct[!all_na, , drop = FALSE]
  }

  ## 7) Determine "winner" lineage per sample and ordering
  top_idx    <- apply(avg_z_by_ct, 2, which.max)
  second_idx <- apply(avg_z_by_ct, 2, function(v) order(v, decreasing = TRUE)[2])

  top_ct       <- rownames(avg_z_by_ct)[top_idx]
  second_ct    <- rownames(avg_z_by_ct)[second_idx]
  top_score    <- mapply(function(j, i)  avg_z_by_ct[i,  j], seq_along(top_idx),    top_idx)
  second_score <- mapply(function(j, i2) avg_z_by_ct[i2, j], seq_along(second_idx), second_idx)
  margin       <- top_score - second_score

  winner_order <- factor(
    top_ct,
    levels = c(
      intersect(ct_levels, rownames(avg_z_by_ct)),
      setdiff(rownames(avg_z_by_ct), ct_levels)
    )
  )

  col_order <- order(winner_order, -margin, -top_score)
  avg_z_by_ct_ord <- avg_z_by_ct[, col_order, drop = FALSE]

  ## 8) Margin quantiles for annotation
  margin_bins <- cut(
    margin[col_order],
    breaks = stats::quantile(margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
  )

  ann_col <- data.frame(
    top_ct = factor(top_ct[col_order], levels = rownames(avg_z_by_ct)),
    margin = margin_bins,
    row.names = colnames(avg_z_by_ct_ord)
  )

  r <- rle(as.character(ann_col$top_ct))
  gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL

  ## 9) Plot heatmap
  pheatmap::pheatmap(
    avg_z_by_ct_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    show_rownames  = TRUE,
    show_colnames  = FALSE,
    annotation_col = ann_col,
    annotation_colors = list(
      top_ct = cell_type_colors[names(cell_type_colors) %in% rownames(avg_z_by_ct_ord)],
      margin = margin_colors
    ),
    gaps_col    = gaps_col,
    gaps_row    = if (nrow(avg_z_by_ct_ord) > 1L) seq_len(nrow(avg_z_by_ct_ord) - 1L) else NULL,
    border_color = NA,
    main = paste0(
      "ATAC module scores — ",
      if (use_subset == "promoter_only") "Promoters only" else "All gene-assigned peaks",
      " (aggregator = ", aggregator, ")"
    )
  )

  invisible(list(
    avg_z_by_ct     = avg_z_by_ct,
    avg_z_by_ct_ord = avg_z_by_ct_ord,
    ann_col         = ann_col,
    z_gene          = z_gene
  ))
}

```

## 6.3 Run module analysis: ALL peaks vs PROMOTER-only

```{r}
## 6.3 Run module analysis: ALL peaks vs PROMOTER-only --------------------

mods_all <- build_modules_from_atac(
  count_mat  = counts_annot,
  anno_tbl   = anno_df,
  panel_long = panel_long,
  use_subset = "all_gene_assigned",
  min_reads  = 10,
  min_samples = 5,
  aggregator = "max",
  clip_z     = 2
)
avg_z_by_ct_ord_all <- mods_all$avg_z_by_ct_ord
ann_col_all         <- mods_all$ann_col

cat("\nHead of avg_z_by_ct_ord_all:\n")
print(utils::head(avg_z_by_ct_ord_all, 2))

mods_prom <- build_modules_from_atac(
  count_mat  = counts_annot,
  anno_tbl   = anno_df,
  panel_long = panel_long,
  use_subset = "promoter_only",
  min_reads  = 10,
  min_samples = 5,
  aggregator = "max",
  clip_z     = 2
)
avg_z_by_ct_ord_prom <- mods_prom$avg_z_by_ct_ord
ann_col_prom         <- mods_prom$ann_col

cat("\nHead of avg_z_by_ct_ord_prom:\n")
print(utils::head(avg_z_by_ct_ord_prom, 2))

## Optional: export module matrices
# write.table(avg_z_by_ct_ord_all,  "ATAC_avgZ_byCT_ALL_ord.tsv",
#             sep = "\t", quote = FALSE)
# write.table(avg_z_by_ct_ord_prom, "ATAC_avgZ_byCT_PROM_ord.tsv",
#             sep = "\t", quote = FALSE)

```

## 6.4 Replot module heatmaps adding genotype annotation

```{r}
## 6.4 Replot module heatmaps with genotype annotation -------------------

geno_cols <- c(TT = "#E4007C", TC = "#4F6D7A", CC = "#D3AF37")

plot_modules_with_genotype <- function(mat_ord, ann_col, title) {
  stopifnot(is.matrix(mat_ord), is.data.frame(ann_col))
  stopifnot(exists("meta_sj"))

  geno_tbl <- meta_sj %>%
    dplyr::select(Sample, genotype) %>%
    dplyr::mutate(genotype = factor(genotype, levels = c("TT", "TC", "CC"))) %>%
    dplyr::distinct(Sample, .keep_all = TRUE)

  ann2 <- ann_col[colnames(mat_ord), , drop = FALSE]
  ann2$genotype <- geno_tbl$genotype[match(rownames(ann2), geno_tbl$Sample)]

  if (any(is.na(ann2$genotype))) {
    msg <- paste(rownames(ann2)[is.na(ann2$genotype)], collapse = ", ")
    message("Samples missing genotype (annotation shown as NA): ", msg)
  }

  r <- rle(as.character(ann2$top_ct))
  gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL

  pheatmap::pheatmap(
    mat_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    show_rownames  = TRUE,
    show_colnames  = FALSE,
    annotation_col = ann2,
    annotation_colors = list(
      top_ct   = cell_type_colors[names(cell_type_colors) %in% rownames(mat_ord)],
      margin   = margin_colors,
      genotype = geno_cols
    ),
    gaps_col    = gaps_col,
    gaps_row    = if (nrow(mat_ord) > 1L) seq_len(nrow(mat_ord) - 1L) else NULL,
    border_color = NA,
    main = title
  )
}

## ALL gene-assigned peaks + genotype
plot_modules_with_genotype(
  mat_ord = avg_z_by_ct_ord_all,
  ann_col = ann_col_all,
  title   = "ATAC module scores — ALL peaks (with genotype)"
)

## PROMOTER-only peaks + genotype
plot_modules_with_genotype(
  mat_ord = avg_z_by_ct_ord_prom,
  ann_col = ann_col_prom,
  title   = "ATAC module scores — Promoters only (with genotype)"
)

```

## 6.5 Replot module heatmaps adding genotype + subtype annotations

```{r}
## 6.5 Replot module heatmaps with genotype + subtype --------------------

suppressPackageStartupMessages(library(RColorBrewer))

## Automatic subtype color palette
make_subtype_colors <- function(subtypes) {
  subs <- sort(unique(stats::na.omit(subtypes)))
  n    <- length(subs)
  base <- RColorBrewer::brewer.pal(12, "Set3")
  pal  <- if (n <= 12L) base[seq_len(n)] else grDevices::colorRampPalette(base)(n)
  stats::setNames(pal, subs)
}

plot_modules_with_genotype_subtype <- function(mat_ord, ann_col, title) {
  stopifnot(is.matrix(mat_ord), is.data.frame(ann_col))
  stopifnot(exists("meta_sj"))

  meta_min <- meta_sj %>%
    dplyr::select(Sample, genotype, Subtype) %>%
    dplyr::mutate(genotype = factor(genotype, levels = c("TT", "TC", "CC"))) %>%
    dplyr::distinct(Sample, .keep_all = TRUE)

  ann2 <- ann_col[colnames(mat_ord), , drop = FALSE]
  ann2$genotype <- meta_min$genotype[match(rownames(ann2), meta_min$Sample)]
  ann2$Subtype  <- meta_min$Subtype[match(rownames(ann2), meta_min$Sample)]

  if (any(is.na(ann2$genotype))) {
    message("Samples missing genotype: ",
            paste(rownames(ann2)[is.na(ann2$genotype)], collapse = ", "))
  }
  if (any(is.na(ann2$Subtype))) {
    message("Samples missing Subtype: ",
            paste(rownames(ann2)[is.na(ann2$Subtype)], collapse = ", "))
  }

  sub_cols <- make_subtype_colors(ann2$Subtype)

  r <- rle(as.character(ann2$top_ct))
  gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL

  pheatmap::pheatmap(
    mat_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    show_rownames  = TRUE,
    show_colnames  = FALSE,
    annotation_col = ann2,
    annotation_colors = list(
      top_ct   = cell_type_colors[names(cell_type_colors) %in% rownames(mat_ord)],
      margin   = margin_colors,
      genotype = geno_cols,
      Subtype  = sub_cols
    ),
    gaps_col    = gaps_col,
    gaps_row    = if (nrow(mat_ord) > 1L) seq_len(nrow(mat_ord) - 1L) else NULL,
    border_color = NA,
    main = title
  )
}

## ALL peaks: genotype + subtype
plot_modules_with_genotype_subtype(
  mat_ord = avg_z_by_ct_ord_all,
  ann_col = ann_col_all,
  title   = "ATAC module scores — ALL peaks (with genotype + subtype)"
)

## PROMOTER-only: genotype + subtype
plot_modules_with_genotype_subtype(
  mat_ord = avg_z_by_ct_ord_prom,
  ann_col = ann_col_prom,
  title   = "ATAC module scores — Promoters only (with genotype + subtype)"
)

```
# 7 Spain lineage modules

```{r}
# =====================================================================
# 7. Spain-specific lineage modules (PROMOTER vs ENHANCER markers)
#    Same ATAC "openness" scoring pipeline as Section 6,
#    but with Spain marker genes and explicit HSC → CLP → ProB → PreB → Immature-B ordering
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(readr)
})


spain_prom_path <- "~/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/spain_group/atacseq/100_M_reads/promoter_markers_by_celltype_marker_genes_wide.csv"
spain_enh_path  <- "~/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/spain_group/atacseq/100_M_reads/enhancer_markers_by_celltype_marker_genes_wide.csv"

## Canonical Spain lineage order for the heatmaps
ct_spain_order <- c("HSC", "CLP", "ProB", "PreB", "Immature-B")

load_spain_panel_long <- function(path, ct_order) {
    wide <- read.csv(path, check.names = FALSE)
    
    wide <- wide %>%
        mutate(across(everything(), ~ trimws(as.character(.))))
    
    ## If columns are exactly the cell types, reorder to canonical order
    if (all(sort(colnames(wide)) == sort(ct_order))) {
        wide <- wide[, ct_order, drop = FALSE]
    }
    
    wide %>%
        pivot_longer(
            cols      = everything(),
            names_to  = "cell_type",
            values_to = "gene"
        ) %>%
        filter(!is.na(gene), gene != "") %>%
        mutate(cell_type = factor(cell_type, levels = ct_order))
}

panel_spain_prom_long <- load_spain_panel_long(spain_prom_path, ct_spain_order)
panel_spain_enh_long  <- load_spain_panel_long(spain_enh_path,  ct_spain_order)


# =====================================================================
# New, plotting-free build_modules_from_atac()
# Works for BOTH Ilaria and Spain marker panels
# =====================================================================
build_modules_from_atac <- function(count_mat,
                                    anno_tbl,
                                    panel_long,
                                    use_subset  = c("all_gene_assigned", "promoter_only"),
                                    min_reads   = 10,
                                    min_samples = 5,
                                    aggregator = c("max", "sum", "mean"),
                                    clip_z      = 2) {
  stopifnot(is.matrix(count_mat),
            is.data.frame(anno_tbl),
            is.data.frame(panel_long))
  stopifnot("peak_id" %in% colnames(anno_tbl),
            "SYMBOL"  %in% colnames(anno_tbl),
            "annotation" %in% colnames(anno_tbl))

  use_subset <- match.arg(use_subset)
  aggregator <- match.arg(aggregator)

  # Align annotation to count_mat rows
  anno_sub <- anno_tbl[match(rownames(count_mat), anno_tbl$peak_id), ]
  stopifnot(identical(anno_sub$peak_id, rownames(count_mat)))

  # Strip " (1-2kb)" etc from annotation
  base_cat <- sub(" \\(.*\\)$", "", anno_sub$annotation)

  has_gene <- !is.na(anno_sub$SYMBOL) & anno_sub$SYMBOL != ""

  if (use_subset == "promoter_only") {
    keep_peaks <- (base_cat == "Promoter") & has_gene
  } else {
    # all_gene_assigned = any peak with a SYMBOL
    keep_peaks <- has_gene
  }

  count_sub <- count_mat[keep_peaks, , drop = FALSE]
  anno_sub  <- anno_sub[keep_peaks, , drop = FALSE]

  if (nrow(count_sub) == 0L) {
    stop("No peaks left after filtering for subset = ", use_subset,
         " and having a valid gene symbol.")
  }

  # Peak-level filtering by read support
  keep_peaks2 <- rowSums(count_sub >= min_reads) >= min_samples
  count_sub   <- count_sub[keep_peaks2, , drop = FALSE]
  anno_sub    <- anno_sub[keep_peaks2, , drop = FALSE]

  if (nrow(count_sub) == 0L) {
    stop("No peaks left after min_reads/min_samples filters.")
  }

  # ------------------------------------------------------------
  # Gene-level counts: aggregate peaks per gene
  # ------------------------------------------------------------
  gene2peak <- split(rownames(count_sub), anno_sub$SYMBOL)

  agg_fun <- switch(
    aggregator,
    max  = function(x) apply(x, 2, max),
    sum  = function(x) colSums(x),
    mean = function(x) colMeans(x)
  )

  gene_counts <- vapply(
    gene2peak,
    function(peaks) agg_fun(count_sub[peaks, , drop = FALSE]),
    FUN.VALUE = numeric(ncol(count_sub))
  )
  gene_counts <- t(gene_counts)
  colnames(gene_counts) <- colnames(count_sub)

  # Optional: gene-level filter for stability
  keep_genes <- rowSums(gene_counts >= min_reads) >= min_samples
  gene_counts <- gene_counts[keep_genes, , drop = FALSE]

  if (nrow(gene_counts) == 0L) {
    stop("No genes left after gene-level min_reads/min_samples filters.")
  }

  # ------------------------------------------------------------
  # logCPM + per-gene z-scores
  # ------------------------------------------------------------
  logcpm <- edgeR::cpm(gene_counts, log = TRUE, prior.count = 1)

  z_gene <- t(scale(t(logcpm)))
  z_gene[is.na(z_gene)] <- 0
  if (!is.null(clip_z)) {
    z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
  }

  # ------------------------------------------------------------
  # Average z-score per lineage (module matrix)
  # ------------------------------------------------------------
  ct_levels_local <- sort(unique(as.character(panel_long$cell_type)))

  avg_list <- lapply(ct_levels_local, function(ct) {
    g_ct <- panel_long$gene[panel_long$cell_type == ct]
    g_ct <- intersect(unique(as.character(g_ct)), rownames(z_gene))
    if (length(g_ct) == 0L) {
      rep(NA_real_, ncol(z_gene))
    } else {
      colMeans(z_gene[g_ct, , drop = FALSE])
    }
  })

  avg_z_by_ct <- do.call(rbind, avg_list)
  rownames(avg_z_by_ct) <- ct_levels_local
  colnames(avg_z_by_ct) <- colnames(z_gene)

  # Return ONLY data; all plotting happens in dedicated functions
  invisible(list(
    avg_z_by_ct = avg_z_by_ct,
    z_gene      = z_gene,
    gene_counts = gene_counts,
    panel_long  = panel_long,
    subset      = use_subset
  ))
}


## NOTE: uses build_modules_from_atac() defined above (no changes).

mods_spain_prom <- build_modules_from_atac(
    count_mat   = counts_annot,
    anno_tbl    = anno_df,
    panel_long  = panel_spain_prom_long,
    use_subset  = "promoter_only",       # like "Promoters only" in Ilaria section
    min_reads   = 10,
    min_samples = 5,
    aggregator  = "max",
    clip_z      = 2
)

mods_spain_enh <- build_modules_from_atac(
    count_mat   = counts_annot,
    anno_tbl    = anno_df,
    panel_long  = panel_spain_enh_long,
    use_subset  = "all_gene_assigned",   # enhancer markers can use all annotated peaks
    min_reads   = 10,
    min_samples = 5,
    aggregator  = "max",
    clip_z      = 2
)

cat("\nHead of raw Spain PROMOTER avg_z_by_ct:\n")
print(utils::head(mods_spain_prom$avg_z_by_ct, 2))
cat("\nHead of raw Spain ENHANCER avg_z_by_ct:\n")
print(utils::head(mods_spain_enh$avg_z_by_ct, 2))

##     HSC-max samples are leftmost, then CLP, then ProB, then PreB, then Immature-B
##     within each group, samples with the "reddest" (highest) module score appear first

prep_spain_modules <- function(mods_obj, ct_order) {
    mat0 <- mods_obj$avg_z_by_ct          # lineages x samples, unsorted
    
    ## Keep only Spain cell types and put them in canonical order (rows)
    ct_present <- intersect(ct_order, rownames(mat0))
    mat0 <- mat0[ct_present, , drop = FALSE]
    
    ## For each sample, identify top and second-best lineage and their scores
    top_idx     <- apply(mat0, 2, which.max)
    top_ct      <- rownames(mat0)[top_idx]
    top_score   <- mat0[cbind(top_idx, seq_along(top_idx))]
    
    second_idx  <- apply(mat0, 2, function(v) order(v, decreasing = TRUE)[2])
    second_score <- mat0[cbind(second_idx, seq_along(second_idx))]
    margin      <- top_score - second_score
    
    ## Ordering: first by top_ct (HSC → CLP → ProB → PreB → Immature-B),
    ## then by descending margin (how clearly that lineage "wins"),
    ## then by descending top_score (reddest first).
    winner_factor <- factor(top_ct, levels = ct_order)
    col_order <- order(winner_factor, -margin, -top_score)
    
    mat_ord <- mat0[, col_order, drop = FALSE]
    
    ## Quantile bins of margin, same labels as Section 6
    margin_bins <- cut(
        margin[col_order],
        breaks = stats::quantile(margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
        include.lowest = TRUE,
        labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
    )
    
    ann_col <- data.frame(
        top_ct = factor(top_ct[col_order], levels = ct_present),
        margin = margin_bins,
        row.names = colnames(mat_ord)
    )
    
    invisible(list(
        mat_ord  = mat_ord,
        ann_col  = ann_col
    ))
}

spain_prom_prepped <- prep_spain_modules(mods_spain_prom, ct_spain_order)
spain_enh_prepped  <- prep_spain_modules(mods_spain_enh,  ct_spain_order)

avg_z_spain_prom_ord   <- spain_prom_prepped$mat_ord
ann_col_spain_prom     <- spain_prom_prepped$ann_col

avg_z_spain_enh_ord    <- spain_enh_prepped$mat_ord
ann_col_spain_enh      <- spain_enh_prepped$ann_col

cat("\nHead of Spain PROMOTER modules (ordered):\n")
print(utils::head(avg_z_spain_prom_ord, 2))
cat("\nHead of Spain ENHANCER modules (ordered):\n")
print(utils::head(avg_z_spain_enh_ord, 2))

##    (same idea as plot_modules_with_genotype_subtype(), but with Spain
##     cell-type colors and our explicit HSC → CLP → ProB → PreB → Immature-B ordering)

plot_spain_modules <- function(mat_ord, ann_col, title) {
    stopifnot(is.matrix(mat_ord), is.data.frame(ann_col))
    stopifnot(exists("meta_sj"))
    
    # Minimal metadata
    meta_min <- meta_sj %>%
        dplyr::select(Sample, genotype, Subtype) %>%
        dplyr::mutate(genotype = factor(genotype, levels = c("TT", "TC", "CC"))) %>%
        dplyr::distinct(Sample, .keep_all = TRUE)
    
    ann2 <- ann_col[colnames(mat_ord), , drop = FALSE]
    ann2$genotype <- meta_min$genotype[match(rownames(ann2), meta_min$Sample)]
    ann2$Subtype  <- meta_min$Subtype[match(rownames(ann2), meta_min$Sample)]
    
    if (any(is.na(ann2$genotype))) {
        message("Samples missing genotype: ",
                paste(rownames(ann2)[is.na(ann2$genotype)], collapse = ", "))
    }
    if (any(is.na(ann2$Subtype))) {
        message("Samples missing Subtype: ",
                paste(rownames(ann2)[is.na(ann2$Subtype)], collapse = ", "))
    }
    
    ## Spain-specific top_ct colors (you can tweak these if you want)
    cell_type_colors_spain <- c(
        HSC         = "#fb8072",
        CLP         = "#bebada",
        ProB        = "#ff33ff",
        PreB        = "#00e5c0",
        `Immature-B` = "#00bfff"
    )
    
    sub_cols <- make_subtype_colors(ann2$Subtype)
    
    ## Column gaps between top_ct blocks (HSC, CLP, ProB, PreB, Immature-B)
    r <- rle(as.character(ann2$top_ct))
    gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL
    
    pheatmap::pheatmap(
        mat_ord,
        cluster_rows   = FALSE,
        cluster_cols   = FALSE,
        show_rownames  = TRUE,
        show_colnames  = FALSE,
        annotation_col = ann2,
        annotation_colors = list(
            top_ct   = cell_type_colors_spain[names(cell_type_colors_spain) %in% rownames(mat_ord)],
            margin   = margin_colors,
            genotype = geno_cols,
            Subtype  = sub_cols
        ),
        gaps_col    = gaps_col,
        gaps_row    = if (nrow(mat_ord) > 1L) seq_len(nrow(mat_ord) - 1L) else NULL,
        border_color = NA,
        main = title
    )
}

plot_spain_modules(
    mat_ord = avg_z_spain_prom_ord,
    ann_col = ann_col_spain_prom,
    title   = "ATAC module scores — Spain PROMOTER markers (Promoters only, ATAC openness)"
)

## 7.4.2 Spain ENHANCER markers: all gene-assigned peaks
plot_spain_modules(
    mat_ord = avg_z_spain_enh_ord,
    ann_col = ann_col_spain_enh,
    title   = "ATAC module scores — Spain ENHANCER markers (All gene-assigned peaks, ATAC openness)"
)


# write.table(avg_z_spain_prom_ord,
#             "ATAC_avgZ_Spain_PROM_markers_ord.tsv",
#             sep = "\t", quote = FALSE)
#
# write.table(avg_z_spain_enh_ord,
#             "ATAC_avgZ_Spain_ENH_markers_ord.tsv",
#             sep = "\t", quote = FALSE)

```


# 8. Diagnostics and QC of Ilaria vs Spain Modules


```{r}
# =============================================================
# Diagnostics: Ilaria vs Spain modules
# =============================================================

## 0. Basic SNP/genotype and metadata objects ------------------

cat("\n[0.1] combined_batches (SNP summary)\n")
print(dim(combined_batches))
print(head(combined_batches, 3))

cat("\n[0.2] ct_only (C/T-based state)\n")
print(dim(ct_only))
print(head(ct_only, 3))
cat("ct_state counts:\n")
print(table(ct_only$ct_state, useNA = "ifany"))

cat("\n[0.3] geno_qc_table (C/T vs ALT% genotype)\n")
print(geno_qc_table)

cat("\n[0.4] meta (ATAC metadata: Sample, genotype, ALT_pct)\n")
print(dim(meta))
print(head(meta, 5))
cat("Genotype distribution in meta:\n")
print(table(meta$genotype, useNA = "ifany"))

cat("\n[0.5] meta_sj (ATAC metadata + St Jude subtype)\n")
print(dim(meta_sj))
print(head(meta_sj, 5))
cat("Genotype distribution in meta_sj:\n")
print(table(meta_sj$genotype, useNA = "ifany"))
cat("Subtype distribution in meta_sj:\n")
print(table(meta_sj$Subtype, useNA = "ifany"))

## 1. ATAC counts and annotation --------------------------------

cat("\n[1.1] counts (raw consensus counts matrix)\n")
print(dim(counts))
cat("First 3 rows, first 5 samples:\n")
print(counts[1:3, 1:5])

cat("\n[1.2] anno_df (ChIPseeker annotation)\n")
print(dim(anno_df))
print(head(anno_df[, c("peak_id", "SYMBOL", "annotation", "distanceToTSS")], 5))

cat("\n[1.3] counts_annot (counts restricted to annotated peaks)\n")
print(dim(counts_annot))
cat("Row names example (1:5):\n")
print(rownames(counts_annot)[1:5])

## 2. Ilaria panel and modules ----------------------------------

cat("\n[2.1] panel_long (Ilaria 700 genes, long format)\n")
print(dim(panel_long))
cat("Cell type counts (Ilaria):\n")
print(table(panel_long$cell_type, useNA = "ifany"))
cat("Total unique genes in Ilaria panel:\n")
print(length(unique(panel_long$gene)))

cat("\n[2.2] Ilaria modules: mods_all$avg_z_by_ct\n")
print(dim(mods_all$avg_z_by_ct))
cat("Row (lineage) names:\n")
print(rownames(mods_all$avg_z_by_ct))
cat("Per-lineage value ranges:\n")
print(apply(mods_all$avg_z_by_ct, 1, range, na.rm = TRUE))

cat("\n[2.3] Ilaria modules: mods_prom$avg_z_by_ct (promoters only)\n")
print(dim(mods_prom$avg_z_by_ct))
cat("Row (lineage) names:\n")
print(rownames(mods_prom$avg_z_by_ct))
cat("Per-lineage value ranges:\n")
print(apply(mods_prom$avg_z_by_ct, 1, range, na.rm = TRUE))

cat("\n[2.4] Ordered Ilaria matrices\n")
cat("avg_z_by_ct_ord_all (all peaks) dim:\n")
print(dim(avg_z_by_ct_ord_all))
cat("avg_z_by_ct_ord_prom (promoter-only) dim:\n")
print(dim(avg_z_by_ct_ord_prom))

cat("\n[2.5] Ilaria top_ct distributions\n")
cat("ALL peaks top_ct:\n")
print(table(ann_col_all$top_ct, useNA = "ifany"))
cat("PROMOTER-only top_ct:\n")
print(table(ann_col_prom$top_ct, useNA = "ifany"))

## 3. Spain marker panels ---------------------------------------

cat("\n[3.1] panel_spain_prom_long (Spain PROMOTER markers, long)\n")
print(dim(panel_spain_prom_long))
cat("Cell type counts (Spain PROM):\n")
print(table(panel_spain_prom_long$cell_type, useNA = "ifany"))
cat("Unique PROMOTER marker genes:\n")
print(length(unique(panel_spain_prom_long$gene)))

cat("\n[3.2] panel_spain_enh_long (Spain ENHANCER markers, long)\n")
print(dim(panel_spain_enh_long))
cat("Cell type counts (Spain ENH):\n")
print(table(panel_spain_enh_long$cell_type, useNA = "ifany"))
cat("Unique ENHANCER marker genes:\n")
print(length(unique(panel_spain_enh_long$gene)))

## Overlap with ATAC genes (Ilaria vs Spain) --------------------

cat("\n[3.3] Overlap of gene sets with ATAC gene universe\n")
ilaria_genes      <- unique(panel_long$gene)
spain_prom_genes  <- unique(panel_spain_prom_long$gene)
spain_enh_genes   <- unique(panel_spain_enh_long$gene)

## Use Ilaria ALL z_gene as proxy for ATAC gene space
atac_genes_all <- rownames(mods_all$z_gene)

cat("Total ATAC genes (mods_all$z_gene):", length(atac_genes_all), "\n")
cat("Ilaria genes present in ATAC:", length(intersect(ilaria_genes, atac_genes_all)), "\n")
cat("Spain PROM genes present in ATAC:", length(intersect(spain_prom_genes, atac_genes_all)), "\n")
cat("Spain ENH genes present in ATAC:", length(intersect(spain_enh_genes, atac_genes_all)), "\n")

cat("Shared genes: Ilaria ∩ Spain PROM:", length(intersect(ilaria_genes, spain_prom_genes)), "\n")
cat("Shared genes: Ilaria ∩ Spain ENH:", length(intersect(ilaria_genes, spain_enh_genes)), "\n")
cat("Shared genes: Spain PROM ∩ Spain ENH:", length(intersect(spain_prom_genes, spain_enh_genes)), "\n")

## 4. Spain modules (PROMOTER vs ENHANCER) -----------------------

cat("\n[4.1] Spain PROMOTER modules: mods_spain_prom$avg_z_by_ct\n")
print(dim(mods_spain_prom$avg_z_by_ct))
cat("Row (lineage) names:\n")
print(rownames(mods_spain_prom$avg_z_by_ct))
cat("Per-lineage value ranges:\n")
print(apply(mods_spain_prom$avg_z_by_ct, 1, range, na.rm = TRUE))

cat("\n[4.2] Spain ENHANCER modules: mods_spain_enh$avg_z_by_ct\n")
print(dim(mods_spain_enh$avg_z_by_ct))
cat("Row (lineage) names:\n")
print(rownames(mods_spain_enh$avg_z_by_ct))
cat("Per-lineage value ranges:\n")
print(apply(mods_spain_enh$avg_z_by_ct, 1, range, na.rm = TRUE))

cat("\n[4.3] Ordered Spain matrices (after prep_spain_modules)\n")
cat("avg_z_spain_prom_ord dim:\n")
print(dim(avg_z_spain_prom_ord))
cat("avg_z_spain_enh_ord dim:\n")
print(dim(avg_z_spain_enh_ord))

cat("\n[4.4] Spain top_ct distributions\n")
cat("Spain PROM top_ct:\n")
print(table(ann_col_spain_prom$top_ct, useNA = "ifany"))
cat("Spain ENH top_ct:\n")
print(table(ann_col_spain_enh$top_ct, useNA = "ifany"))

## 5. Quick summary of value ranges across all module matrices -----------

cat("\n[5.1] Global ranges of module scores (all matrices)\n")
ranges_list <- list(
    Ilaria_ALL      = mods_all$avg_z_by_ct,
    Ilaria_PROM     = mods_prom$avg_z_by_ct,
    Spain_PROM      = mods_spain_prom$avg_z_by_ct,
    Spain_ENH       = mods_spain_enh$avg_z_by_ct
)

for (nm in names(ranges_list)) {
    mat <- ranges_list[[nm]]
    cat("\n", nm, ":\n", sep = "")
    cat("  dim =", paste(dim(mat), collapse = " x "), "\n")
    cat("  overall range =", paste(range(mat, na.rm = TRUE), collapse = " to "), "\n")
}

```

# 9. Saving Core State Objects (SJ156 + Spain)

## 9.1 Saving SJ156 state (only SJ156)

```{r}
# =====================================================================
# 9. Saving Core State Objects (SJ156 ONLY) — UPDATED
#   - Adds gene_counts_sj_prom / gene_counts_sj_enh
#   - Adds global_peak_df_sj (peak-level DF)
# =====================================================================

# suppressPackageStartupMessages({
#     library(dplyr)
# })
# 
# # ---------------------------------------------------------------------
# # 0) Output directory
# # ---------------------------------------------------------------------
# combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"
# 
# if (!dir.exists(combined_dir)) {
#     dir.create(combined_dir, recursive = TRUE)
# }
# 
# # ---------------------------------------------------------------------
# # 1) Build peak-level SJ156 matrices (GLOBAL / PROMOTER / ENHANCER)
# # ---------------------------------------------------------------------
# stopifnot(exists("counts_annot"), exists("anno_df"))
# 
# peak_counts_sj <- counts_annot
# 
# ## Annotation aligned to peak order
# peak_anno <- anno_df %>%
#     dplyr::filter(peak_id %in% rownames(peak_counts_sj)) %>%
#     dplyr::arrange(match(peak_id, rownames(peak_counts_sj)))
# 
# stopifnot(identical(peak_anno$peak_id, rownames(peak_counts_sj)))
# 
# ## Promoter vs non-promoter categories
# base_cat <- sub(" \\(.*\\)$", "", peak_anno$annotation)
# 
# promoter_ids <- peak_anno$peak_id[base_cat == "Promoter"]
# enhancer_ids <- peak_anno$peak_id[base_cat != "Promoter"]
# 
# promoter_counts_sj <- peak_counts_sj[promoter_ids, , drop = FALSE]
# enhancer_counts_sj <- peak_counts_sj[enhancer_ids, , drop = FALSE]
# 
# cat("[SJ156] Peak-level matrices built:\n")
# cat("  • peak_counts_sj     :", paste(dim(peak_counts_sj),    collapse = " × "), "\n")
# cat("  • promoter_counts_sj :", paste(dim(promoter_counts_sj), collapse = " × "), "\n")
# cat("  • enhancer_counts_sj :", paste(dim(enhancer_counts_sj), collapse = " × "), "\n")
# 
# # ---------------------------------------------------------------------
# # 2) Build gene-level SJ156 matrices:
# #    - gene_counts_sj      (ALL peaks per gene)
# #    - gene_counts_sj_prom (PROMOTER-only peaks per gene)
# #    - gene_counts_sj_enh  (ENHANCER-only peaks per gene)
# # ---------------------------------------------------------------------
# stopifnot(exists("gene_anno_min"))
# 
# ## Gene ↔ peak mapping using all annotated peaks
# gene2peak_sj <- gene_anno_min %>%
#     dplyr::filter(!is.na(SYMBOL), SYMBOL != "") %>%
#     dplyr::distinct(SYMBOL, peak_id) %>%
#     dplyr::filter(peak_id %in% rownames(peak_counts_sj))
# 
# peaks_by_gene_sj <- split(gene2peak_sj$peak_id, gene2peak_sj$SYMBOL)
# 
# ## Helper: collapse peaks → gene-level counts by summing across peaks
# build_gene_counts <- function(peaks_by_gene, counts_mat, label) {
#     if (length(peaks_by_gene) == 0L) {
#         stop("[SJ156] ", label, ": no genes with assigned peaks.")
#     }
#     mat <- purrr::map_dfc(
#         peaks_by_gene,
#         ~ colSums(counts_mat[.x, , drop = FALSE])
#     )
#     mat <- t(as.matrix(mat))
#     rownames(mat) <- names(peaks_by_gene)
#     cat("[SJ156] ", label, " built. dim = ",
#         paste(dim(mat), collapse = " × "), "\n", sep = "")
#     mat
# }
# 
# ## (2.1) ALL peaks per gene
# gene_counts_sj <- build_gene_counts(
#     peaks_by_gene = peaks_by_gene_sj,
#     counts_mat    = peak_counts_sj,
#     label         = "gene_counts_sj (ALL peaks)"
# )
# 
# ## (2.2) PROMOTER-only peaks per gene
# promoter_peaks <- rownames(promoter_counts_sj)
# peaks_by_gene_prom <- lapply(peaks_by_gene_sj, function(pk) intersect(pk, promoter_peaks))
# peaks_by_gene_prom <- peaks_by_gene_prom[lengths(peaks_by_gene_prom) > 0]
# 
# gene_counts_sj_prom <- build_gene_counts(
#     peaks_by_gene = peaks_by_gene_prom,
#     counts_mat    = peak_counts_sj,  # counts_annot is equivalent here
#     label         = "gene_counts_sj_prom (PROMOTER-only)"
# )
# 
# ## (2.3) ENHANCER-only peaks per gene
# enhancer_peaks <- rownames(enhancer_counts_sj)
# peaks_by_gene_enh <- lapply(peaks_by_gene_sj, function(pk) intersect(pk, enhancer_peaks))
# peaks_by_gene_enh <- peaks_by_gene_enh[lengths(peaks_by_gene_enh) > 0]
# 
# gene_counts_sj_enh <- build_gene_counts(
#     peaks_by_gene = peaks_by_gene_enh,
#     counts_mat    = peak_counts_sj,
#     label         = "gene_counts_sj_enh (ENHANCER-only)"
# )
# 
# # ---------------------------------------------------------------------
# # 3) Global peak-level DF for SJ156
# # ---------------------------------------------------------------------
# global_peak_df_sj <- peak_anno
# cat("[SJ156] global_peak_df_sj dim: ",
#     paste(dim(global_peak_df_sj), collapse = " × "), "\n")
# 
# # ---------------------------------------------------------------------
# # 4) Bundle ALL SJ156 objects into RDS-safe state list
# # ---------------------------------------------------------------------
# sj156_state <- list(
#     
#     # ---- GENOTYPE / SNP ----
#     combined_batches = combined_batches,
#     ct_only          = ct_only,
#     geno_qc_table    = geno_qc_table,
#     meta             = meta,
#     meta_sj          = meta_sj,
#     allele_cols      = allele_cols,
#     geno_cols        = geno_cols,
#     
#     # ---- ATAC PEAK LEVEL ----
#     counts        = counts,
#     counts_annot  = counts_annot,
#     anno          = anno,
#     anno_df       = anno_df,
#     gr            = gr,
#     gene_anno_min = gene_anno_min,
#     
#     peak_counts_sj     = peak_counts_sj,
#     promoter_counts_sj = promoter_counts_sj,
#     enhancer_counts_sj = enhancer_counts_sj,
#     peak_anno          = peak_anno,
#     global_peak_df_sj  = global_peak_df_sj,
#     
#     # ---- PCA / PARAMETERS ----
#     MIN_READS_PCA   = MIN_READS_PCA,
#     MIN_SAMPLES_PCA = MIN_SAMPLES_PCA,
#     N_TOP_VAR_PCA   = N_TOP_VAR_PCA,
#     
#     # ---- ILARIA PANEL ----
#     panel_long       = panel_long,
#     ct_levels        = ct_levels,
#     cell_type_colors = cell_type_colors,
#     margin_colors    = margin_colors,
#     
#     mods_all             = mods_all,
#     mods_prom            = mods_prom,
#     avg_z_by_ct_ord_all  = avg_z_by_ct_ord_all,
#     ann_col_all          = ann_col_all,
#     avg_z_by_ct_ord_prom = avg_z_by_ct_ord_prom,
#     ann_col_prom         = ann_col_prom,
#     
#     # ---- GENE LEVEL ----
#     gene_counts_sj      = gene_counts_sj,       # ALL peaks per gene
#     gene_counts_sj_prom = gene_counts_sj_prom,  # PROMOTER-only per gene
#     gene_counts_sj_enh  = gene_counts_sj_enh    # ENHANCER-only per gene
# )
# 
# # ---------------------------------------------------------------------
# # 5) SAVE
# # ---------------------------------------------------------------------
# saveRDS(
#     sj156_state,
#     file = file.path(combined_dir, "sj156_atac_core_state.rds")
# )
# 
# cat("\n[SAVED] sj156_atac_core_state.rds stored at:\n",
#     file.path(combined_dir, "sj156_atac_core_state.rds"), "\n\n")

```

# 10. Integrating SJ156 and Spain (Ilaria modules)
## 10.1 Minimal annotation heatmap SJ156 + Spain

```{r}
# ================================================================
# 10. Integrating SJ156 and Spain (Ilaria modules)
# 10.1 Minimal annotation heatmap (cohort + margin + top_ct)
# ================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(edgeR)
    library(pheatmap)
    library(RColorBrewer)
})

# ---------------------------------------------------------------
# 1) Load core states
# ---------------------------------------------------------------
combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"

sj156_state  <- readRDS(file.path(combined_dir, "sj156_atac_core_state.rds"))
spain_state  <- readRDS(file.path(combined_dir, "spain_atac_core_state.rds"))

# Extract Ilaria module definitions
panel_long       <- sj156_state$panel_long
ct_levels        <- sj156_state$ct_levels
cell_type_colors <- sj156_state$cell_type_colors
margin_colors    <- sj156_state$margin_colors

avg_z_sj_all <- sj156_state$mods_all$avg_z_by_ct  # lineages × samples
panel_long$cell_type <- factor(panel_long$cell_type, levels = ct_levels)

# ---------------------------------------------------------------
# 2) Helper: compute modules from gene-level counts
# ---------------------------------------------------------------
build_modules_from_gene_counts <- function(gene_counts,
                                           panel_long,
                                           ct_levels,
                                           min_counts  = 10,
                                           min_samples = 5,
                                           clip_z      = 2) {
    
    keep <- rowSums(gene_counts >= min_counts) >= min_samples
    gene_counts_filt <- gene_counts[keep, , drop = FALSE]
    
    logcpm <- edgeR::cpm(gene_counts_filt, log = TRUE, prior.count = 1)
    
    z_gene <- t(scale(t(logcpm)))
    z_gene[is.na(z_gene)] <- 0
    if (!is.null(clip_z)) {
        z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
    }
    
    avg_list <- lapply(ct_levels, function(ct) {
        g_ct <- panel_long$gene[panel_long$cell_type == ct]
        g_ct <- intersect(unique(g_ct), rownames(z_gene))
        if (length(g_ct) == 0L) rep(NA_real_, ncol(z_gene))
        else colMeans(z_gene[g_ct, , drop = FALSE])
    })
    
    avg_z_by_ct <- do.call(rbind, avg_list)
    rownames(avg_z_by_ct) <- ct_levels
    colnames(avg_z_by_ct) <- colnames(z_gene)
    
    list(avg_z_by_ct = avg_z_by_ct, z_gene = z_gene)
}

# ---------------------------------------------------------------
# 3) Spain — gene-level modules
# ---------------------------------------------------------------
gene_counts_spain <- spain_state$gene_counts_spain_prom  # solo promotores
meta_spain        <- spain_state$meta_spain_coding %>%
    transmute(
        Sample    = as.character(Sample),
        genotype  = factor(genotype, levels = c("TT", "TC", "CC")),
        cell_type = as.character(cell_type)
    )

# Align samples
samples_spain <- intersect(colnames(gene_counts_spain), meta_spain$Sample)
gene_counts_spain <- gene_counts_spain[, samples_spain, drop = FALSE]
meta_spain        <- meta_spain %>% filter(Sample %in% samples_spain)
gene_counts_spain <- gene_counts_spain[, meta_spain$Sample, drop = FALSE]

mods_spain      <- build_modules_from_gene_counts(
    gene_counts = gene_counts_spain,
    panel_long  = panel_long,
    ct_levels   = ct_levels,
    min_counts  = 10,
    min_samples = 3,
    clip_z      = 2
)
avg_z_spain_all <- mods_spain$avg_z_by_ct

# ---------------------------------------------------------------
# 4) Combine SJ156 + Spain
# ---------------------------------------------------------------
common_ct <- intersect(ct_levels, rownames(avg_z_sj_all))

avg_z_sj_all    <- avg_z_sj_all[common_ct, , drop = FALSE]
avg_z_spain_all <- avg_z_spain_all[common_ct, , drop = FALSE]

mat_combined <- cbind(avg_z_sj_all, avg_z_spain_all)

# ---------------------------------------------------------------
# 5) Build annotation: cohort + top_ct + margin score
# ---------------------------------------------------------------
samples_sj    <- colnames(avg_z_sj_all)
samples_spain <- colnames(avg_z_spain_all)

ann_all <- data.frame(
    Sample = c(samples_sj, samples_spain),
    cohort = c(rep("SJ156", length(samples_sj)),
               rep("Spain", length(samples_spain))),
    stringsAsFactors = FALSE
)
rownames(ann_all) <- ann_all$Sample
ann_all <- ann_all[colnames(mat_combined), , drop = FALSE]

# ---- Compute top lineage and numerical margin ----
top_idx <- apply(mat_combined, 2, which.max)
top_ct  <- rownames(mat_combined)[top_idx]

second_idx <- apply(mat_combined, 2, function(v) order(v, decreasing = TRUE)[2])

margin_numeric <- mat_combined[cbind(top_idx, seq_along(top_idx))] -
    mat_combined[cbind(second_idx, seq_along(second_idx))]

ann_all$top_ct <- factor(top_ct, levels = common_ct)

# ---- Use labels EXACTLY matching names(margin_colors) ----
ann_all$margin <- cut(
    margin_numeric,
    breaks = quantile(margin_numeric, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = names(margin_colors)   # <── SOLUCIÓN CLAVE
)

# ---------------------------------------------------------------
# 6) Column ordering (winner lineage, then by margin)
# ---------------------------------------------------------------
winner_factor <- factor(top_ct, levels = common_ct)
col_order <- order(winner_factor, -margin_numeric)

mat_ord  <- mat_combined[, col_order, drop = FALSE]
ann_all  <- ann_all[colnames(mat_ord), , drop = FALSE]

# ---------------------------------------------------------------
# 7) Colors: only cohort + margin + top_ct
# ---------------------------------------------------------------
annotation_colors <- list(
    cohort = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
    margin = margin_colors,
    top_ct = cell_type_colors[names(cell_type_colors) %in% common_ct]
)

gaps_row <- if (length(common_ct) > 1) seq_len(length(common_ct) - 1)

# ---------------------------------------------------------------
# 8) Clean Heatmap
# ---------------------------------------------------------------
pheatmap(
    mat_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    annotation_col = ann_all,
    annotation_colors = annotation_colors,
    gaps_row       = gaps_row,
    show_colnames  = FALSE,
    show_rownames  = TRUE,
    border_color   = NA,
    main = "SJ156 + Spain — Ilaria lineage module heatmap (clean)"
)




```
## 10.2 Integration Heatmap (SJ→Spain ordering inside each lineage)

```{r}
# 8) Integration of SJ156 and Spain Ilaria modules
# ================================================================
# Assumes sj156_state and spain_state are already in the environment
# from previous chunks (no readRDS here).

suppressPackageStartupMessages({
  library(dplyr)
  library(edgeR)
  library(pheatmap)
  library(RColorBrewer)
})

# ------------------------------------------------
# 1) Extract core objects from existing state
# ------------------------------------------------
panel_long       <- sj156_state$panel_long
ct_levels        <- sj156_state$ct_levels
cell_type_colors <- sj156_state$cell_type_colors

# SJ156 lineage modules (already computed upstream)
avg_z_sj_all <- sj156_state$mods_all$avg_z_by_ct   # lineages × SJ156 samples

panel_long$cell_type <- factor(panel_long$cell_type, levels = ct_levels)

# ------------------------------------------------
# 2) Build modules-from-genes for Spain (reuse function if defined)
# ------------------------------------------------
if (!exists("build_modules_from_gene_counts")) {
  build_modules_from_gene_counts <- function(gene_counts,
                                             panel_long,
                                             ct_levels,
                                             min_counts   = 10,
                                             min_samples  = 5,
                                             clip_z       = 2) {

    keep <- rowSums(gene_counts >= min_counts) >= min_samples
    gene_counts_filt <- gene_counts[keep, , drop = FALSE]

    logcpm <- edgeR::cpm(gene_counts_filt, log = TRUE, prior.count = 1)

    z_gene <- t(scale(t(logcpm)))
    z_gene[is.na(z_gene)] <- 0
    if (!is.null(clip_z)) {
      z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
    }

    avg_list <- lapply(ct_levels, function(ct) {
      g_ct <- panel_long$gene[panel_long$cell_type == ct]
      g_ct <- intersect(unique(g_ct), rownames(z_gene))
      if (length(g_ct) == 0L) {
        rep(NA_real_, ncol(z_gene))
      } else {
        colMeans(z_gene[g_ct, , drop = FALSE])
      }
    })

    avg_z_by_ct <- do.call(rbind, avg_list)
    rownames(avg_z_by_ct) <- ct_levels
    colnames(avg_z_by_ct) <- colnames(z_gene)

    list(avg_z_by_ct = avg_z_by_ct, z_gene = z_gene)
  }
}

# Spain gene-level counts and metadata from spain_state
gene_counts_spain <- spain_state$gene_counts_spain
meta_spain_coding <- spain_state$meta_spain_coding

spain_meta <- meta_spain_coding %>%
  transmute(
    Sample    = as.character(Sample),
    genotype  = factor(genotype, levels = c("TT", "TC", "CC")),
    cell_type = as.character(cell_type)
  )

samples_spain <- intersect(colnames(gene_counts_spain), spain_meta$Sample)
gene_counts_spain <- gene_counts_spain[, samples_spain, drop = FALSE]
spain_meta <- spain_meta %>% filter(Sample %in% samples_spain)

gene_counts_spain <- gene_counts_spain[, spain_meta$Sample, drop = FALSE]

mods_spain <- build_modules_from_gene_counts(
  gene_counts = gene_counts_spain,
  panel_long  = panel_long,
  ct_levels   = ct_levels,
  min_counts  = 10,
  min_samples = 3,
  clip_z      = 2
)

avg_z_spain_all <- mods_spain$avg_z_by_ct   # lineages × Spain samples

# ------------------------------------------------
# 3) Harmonize lineages and combine cohorts
# ------------------------------------------------
common_ct <- intersect(ct_levels,
                       intersect(rownames(avg_z_sj_all), rownames(avg_z_spain_all)))

avg_z_sj_all    <- avg_z_sj_all[common_ct, , drop = FALSE]
avg_z_spain_all <- avg_z_spain_all[common_ct, , drop = FALSE]

mat_combined <- cbind(avg_z_sj_all, avg_z_spain_all)

# ------------------------------------------------
# 4) Annotation: ONLY cohort + top_ct
# ------------------------------------------------
samples_sj    <- colnames(avg_z_sj_all)
samples_spain <- colnames(avg_z_spain_all)

ann_all <- data.frame(
  cohort = c(rep("SJ156", length(samples_sj)),
             rep("Spain", length(samples_spain))),
  stringsAsFactors = FALSE
)
rownames(ann_all) <- c(samples_sj, samples_spain)
ann_all <- ann_all[colnames(mat_combined), , drop = FALSE]

ann_all$cohort <- factor(ann_all$cohort, levels = c("SJ156", "Spain"))

# Top Ilaria lineage per sample
top_idx <- apply(mat_combined, 2, which.max)
top_ct  <- rownames(mat_combined)[top_idx]
ann_all$top_ct <- factor(top_ct, levels = common_ct)

# ------------------------------------------------
# 5) Custom column ordering:
#    within each lineage: SJ156 samples first, then Spain samples
# ------------------------------------------------
col_order <- character(0)
for (ct in common_ct) {
  cols_ct_sj <- rownames(ann_all)[ann_all$top_ct == ct & ann_all$cohort == "SJ156"]
  cols_ct_spain <- rownames(ann_all)[ann_all$top_ct == ct & ann_all$cohort == "Spain"]
  col_order <- c(col_order, cols_ct_sj, cols_ct_spain)
}
# keep only columns that actually exist
col_order <- col_order[col_order %in% colnames(mat_combined)]

mat_ord <- mat_combined[, col_order, drop = FALSE]
ann_all <- ann_all[col_order, , drop = FALSE]

# Column gaps between lineage blocks (for vertical separators)
r <- rle(as.character(ann_all$top_ct))
gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL

# Row gaps between Ilaria lineages
gaps_row <- if (length(common_ct) > 1L) seq_len(length(common_ct) - 1L) else NULL

# ------------------------------------------------
# 6) Annotation colors — ONLY cohort + top_ct
# ------------------------------------------------
annotation_colors <- list(
  cohort = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
  top_ct = cell_type_colors[names(cell_type_colors) %in% common_ct]
)

# ------------------------------------------------
# 7) Plot clean heatmap
# ------------------------------------------------
pheatmap(
  mat_ord,
  cluster_rows   = FALSE,
  cluster_cols   = FALSE,
  annotation_col = ann_all,
  annotation_colors = annotation_colors,
  gaps_row       = gaps_row,
  gaps_col       = gaps_col,
  show_colnames  = FALSE,
  show_rownames  = TRUE,
  border_color   = NA,
  main = "SJ156 + Spain — Ilaria lineage module heatmap (SJ→Spain within each lineage)"
)


```


# 11. Task 1 — Using Ilaria’s markers + Spain TRUE cell types
### 11.1 Add Spain TRUE cell-type annotation

```{r}
# ------------------------------------------------------------------
# 5c) Add Spain TRUE cell-type annotation (from Spain metadata)
# ------------------------------------------------------------------
ann_all$spain_cell_type <- NA_character_

# We expect metadata in spain_state$meta_spain with cols: Sample, cell_type
meta_spain <- NULL
if (!is.null(spain_state$meta_spain)) {
    meta_spain <- spain_state$meta_spain
}

if (!is.null(meta_spain)) {
    if (!all(c("Sample", "cell_type") %in% colnames(meta_spain))) {
        warning("Spain metadata found but lacks 'Sample' and/or 'cell_type' columns; spain_cell_type will remain NA.")
    } else {
        meta_spain <- meta_spain %>%
            mutate(Sample = as.character(Sample)) %>%
            dplyr::select(Sample, cell_type)
        
        idx_spain <- ann_all$cohort == "Spain"
        
        ann_all$spain_cell_type[idx_spain] <- meta_spain$cell_type[
            match(rownames(ann_all)[idx_spain], meta_spain$Sample)
        ]
        
        # Ensure factor levels are exactly the distinct Spain cell types
        spain_ct_levels <- sort(unique(na.omit(as.character(ann_all$spain_cell_type))))
        ann_all$spain_cell_type <- factor(ann_all$spain_cell_type,
                                          levels = spain_ct_levels)
        
        cat("[5c] Spain cell-type annotation added for ",
            sum(idx_spain & !is.na(ann_all$spain_cell_type)),
            " Spain samples.\n", sep = "")
        cat("     Table of spain_cell_type by cohort:\n")
        print(table(ann_all$spain_cell_type, ann_all$cohort, useNA = "ifany"))
    }
} else {
    warning("No Spain sample metadata (meta_spain) found in spain_state; spain_cell_type annotation will be NA.")
}

# ------------------------------------------------------------------
# 6) Heatmap: build annotation_colors with proper Spain colors
# ------------------------------------------------------------------
annotation_colors <- list(
    cohort = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
    # Ilaria lineage colors (SJ156 panel)
    top_ct = cell_type_colors[names(cell_type_colors) %in% common_ct]
)

# Add colors for Spain true cell-type (use spain_state$cell_type_colors if available)
if ("spain_cell_type" %in% colnames(ann_all)) {
    spain_ct_levels <- levels(ann_all$spain_cell_type)
    
    if (length(spain_ct_levels) > 0L) {
        
        spain_colors <- NULL
        if (!is.null(spain_state$cell_type_colors)) {
            spain_colors <- spain_state$cell_type_colors
        }
        
        if (!is.null(spain_colors)) {
            # If some Spain levels are missing in the color vector, create new colors
            missing_spain <- setdiff(spain_ct_levels, names(spain_colors))
            if (length(missing_spain) > 0L) {
                warning("Spain cell types missing from spain_state$cell_type_colors: ",
                        paste(missing_spain, collapse = ", "),
                        "\nAssigning new colors for these.")
                extra_cols <- setNames(
                    grDevices::hcl.colors(length(missing_spain), "Set2"),
                    missing_spain
                )
                spain_colors <- c(spain_colors, extra_cols)
            }
            
            # Final color vector must have one color per factor level
            annotation_colors$spain_cell_type <- spain_colors[spain_ct_levels]
        } else {
            # Fallback: create a palette from scratch
            annotation_colors$spain_cell_type <- setNames(
                grDevices::hcl.colors(length(spain_ct_levels), "Set2"),
                spain_ct_levels
            )
        }
    }
}

pheatmap::pheatmap(
    mat_ord,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    annotation_col = ann_all,
    annotation_colors = annotation_colors,
    gaps_row       = gaps_row,
    gaps_col       = gaps_col,
    show_colnames  = FALSE,
    show_rownames  = TRUE,
    border_color   = NA,
    main = "Ilaria lineage modules — SJ156 + Spain (gene-level)"
)

```

### 11.2 Rank samples within each lineage (Spain + SJ156)
#### Within each Ilaria lineage block (HSCMPP, GMP, pDC, EarlyLymphoid, ProB, PreB, B), take only the samples whose top_ct is that lineage and then rank those columns from highest to lowest based on that lineage’s module score (the row value for that lineage), so that, for example, the ProB block shows samples ordered from “most ProB-like” to “least ProB-like,” regardless of cohort, while still keeping the same row structure and Spain TRUE cell-type annotation.

```{r}
# ================================================================
# 11.2 – Ilaria PROMOTER modules for SJ156 + Spain (margin Q4→Q1)
#       All samples, one heatmap, using Ilaria markers (PROM-only)
#       NOTE: chunk-specific objects: mat_ord_11_2, ann_all_11_2, ...
# ================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(edgeR)
    library(pheatmap)
})

# ------------------------------------------------
# 1) Load SJ156 + Spain state objects
# ------------------------------------------------
combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"

if (!exists("sj156_state") || !exists("spain_state")) {
    cat("[1] Loading sj156_state and spain_state from:\n   ", combined_dir, "\n")
    sj156_state <- readRDS(file.path(combined_dir, "sj156_atac_core_state.rds"))
    spain_state <- readRDS(file.path(combined_dir, "spain_atac_core_state.rds"))
} else {
    cat("[1] Using sj156_state and spain_state already in memory.\n")
}

# ------------------------------------------------
# 2) Ilaria definitions + PROM modules for SJ156
# ------------------------------------------------
panel_long_11_2       <- sj156_state$panel_long
ct_levels_11_2        <- sj156_state$ct_levels
cell_type_colors_11_2 <- sj156_state$cell_type_colors
margin_colors_11_2    <- sj156_state$margin_colors

# Ilaria PROM-only modules for SJ156 (lineages × SJ samples)
avg_z_sj_prom_11_2 <- sj156_state$mods_prom$avg_z_by_ct

cat("\n[2] SJ156 Ilaria PROM modules (avg_z_sj_prom_11_2):\n")
cat("    dim =", paste(dim(avg_z_sj_prom_11_2), collapse = " × "), "\n")
cat("    lineages:", paste(rownames(avg_z_sj_prom_11_2), collapse = ", "), "\n")

panel_long_11_2$cell_type <- factor(panel_long_11_2$cell_type,
                                    levels = ct_levels_11_2)

# ------------------------------------------------
# 3) Ilaria PROM modules for Spain (gene_counts_spain_prom)
# ------------------------------------------------
gene_counts_spain_prom_11_2 <- spain_state$gene_counts_spain_prom
meta_spain_coding_11_2      <- spain_state$meta_spain_coding

cat("\n[3] gene_counts_spain_prom_11_2 (PROM-only):\n")
cat("    dim =", paste(dim(gene_counts_spain_prom_11_2), collapse = " × "), "\n")

meta_spain_11_2 <- meta_spain_coding_11_2 %>%
    transmute(
        Sample    = as.character(Sample),
        genotype  = factor(genotype, levels = c("TT", "TC", "CC")),
        cell_type = as.character(cell_type)
    )

# Align Spain samples between counts and metadata
samples_spain_11_2 <- intersect(colnames(gene_counts_spain_prom_11_2),
                                meta_spain_11_2$Sample)

gene_counts_spain_prom_11_2 <- gene_counts_spain_prom_11_2[, samples_spain_11_2,
                                                           drop = FALSE]
meta_spain_11_2 <- meta_spain_11_2 %>%
    filter(Sample %in% samples_spain_11_2)

# Reorder counts to match metadata
gene_counts_spain_prom_11_2 <- gene_counts_spain_prom_11_2[, meta_spain_11_2$Sample,
                                                           drop = FALSE]

cat("    Spain samples aligned:", ncol(gene_counts_spain_prom_11_2), "\n")

# Helper (defined once globally; safe to reuse)
if (!exists("build_modules_from_gene_counts")) {
    cat("[3b] Defining build_modules_from_gene_counts()...\n")
    build_modules_from_gene_counts <- function(gene_counts,
                                               panel_long,
                                               ct_levels,
                                               min_counts  = 10,
                                               min_samples = 5,
                                               clip_z      = 2) {
        stopifnot(is.matrix(gene_counts))
        
        keep <- rowSums(gene_counts >= min_counts) >= min_samples
        gene_counts_filt <- gene_counts[keep, , drop = FALSE]
        cat("    - build_modules: keeping", nrow(gene_counts_filt),
            "genes after min_counts/min_samples\n")
        
        logcpm <- edgeR::cpm(gene_counts_filt, log = TRUE, prior.count = 1)
        
        z_gene <- t(scale(t(logcpm)))
        z_gene[is.na(z_gene)] <- 0
        if (!is.null(clip_z)) {
            z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
        }
        
        avg_list <- lapply(ct_levels, function(ct) {
            g_ct <- panel_long$gene[panel_long$cell_type == ct]
            g_ct <- intersect(unique(g_ct), rownames(z_gene))
            if (length(g_ct) == 0L) {
                rep(NA_real_, ncol(z_gene))
            } else {
                colMeans(z_gene[g_ct, , drop = FALSE])
            }
        })
        
        avg_z_by_ct <- do.call(rbind, avg_list)
        rownames(avg_z_by_ct) <- ct_levels
        colnames(avg_z_by_ct) <- colnames(z_gene)
        
        invisible(list(avg_z_by_ct = avg_z_by_ct, z_gene = z_gene))
    }
} else {
    cat("[3b] Reusing existing build_modules_from_gene_counts().\n")
}

mods_spain_prom_ilaria_11_2 <- build_modules_from_gene_counts(
    gene_counts = gene_counts_spain_prom_11_2,
    panel_long  = panel_long_11_2,
    ct_levels   = ct_levels_11_2,
    min_counts  = 10,
    min_samples = 3,
    clip_z      = 2
)
avg_z_spain_prom_11_2 <- mods_spain_prom_ilaria_11_2$avg_z_by_ct

cat("\n[3c] Spain Ilaria PROM modules (avg_z_spain_prom_11_2):\n")
cat("    dim =", paste(dim(avg_z_spain_prom_11_2), collapse = " × "), "\n")
cat("    lineages:", paste(rownames(avg_z_spain_prom_11_2), collapse = ", "), "\n")

# ------------------------------------------------
# 4) Combine SJ156 + Spain (PROM), using only common lineages
# ------------------------------------------------
common_ct_11_2 <- intersect(rownames(avg_z_sj_prom_11_2),
                            rownames(avg_z_spain_prom_11_2))

avg_z_sj_prom_11_2    <- avg_z_sj_prom_11_2[common_ct_11_2, , drop = FALSE]
avg_z_spain_prom_11_2 <- avg_z_spain_prom_11_2[common_ct_11_2, , drop = FALSE]

mat_combined_prom_11_2 <- cbind(avg_z_sj_prom_11_2, avg_z_spain_prom_11_2)

cat("\n[4] Combined PROM matrix (SJ156 + Spain):\n")
cat("    dim =", paste(dim(mat_combined_prom_11_2), collapse = " × "), "\n")
cat("    common lineages:", paste(common_ct_11_2, collapse = ", "), "\n")
cat("    global range =", paste(range(mat_combined_prom_11_2, na.rm = TRUE),
                                collapse = " to "), "\n")

# ------------------------------------------------
# 5) Annotation: cohort + top_ct + margin (Q4→Q1)
# ------------------------------------------------
samples_sj_11_2    <- colnames(avg_z_sj_prom_11_2)
samples_spain_11_2 <- colnames(avg_z_spain_prom_11_2)

ann_all_11_2 <- data.frame(
    Sample = c(samples_sj_11_2, samples_spain_11_2),
    cohort = c(rep("SJ156", length(samples_sj_11_2)),
               rep("Spain", length(samples_spain_11_2))),
    stringsAsFactors = FALSE
)
rownames(ann_all_11_2) <- ann_all_11_2$Sample
ann_all_11_2 <- ann_all_11_2[colnames(mat_combined_prom_11_2), , drop = FALSE]

# Top lineage (Ilaria) per sample
top_idx_11_2 <- apply(mat_combined_prom_11_2, 2, which.max)
top_ct_11_2  <- rownames(mat_combined_prom_11_2)[top_idx_11_2]
ann_all_11_2$top_ct <- factor(top_ct_11_2, levels = common_ct_11_2)

# Second-best lineage + numeric margin
second_idx_11_2 <- apply(mat_combined_prom_11_2, 2,
                         function(v) order(v, decreasing = TRUE)[2])

margin_numeric_11_2 <- mat_combined_prom_11_2[cbind(top_idx_11_2,
                                                    seq_along(top_idx_11_2))] -
    mat_combined_prom_11_2[cbind(second_idx_11_2,
                                 seq_along(second_idx_11_2))]

# Quartile labels (logical order Q1<Q2<Q3<Q4)
margin_labels_11_2 <- c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")

ann_all_11_2$margin <- cut(
    margin_numeric_11_2,
    breaks = quantile(margin_numeric_11_2,
                      probs = seq(0, 1, 0.25),
                      na.rm = TRUE),
    include.lowest = TRUE,
    labels = margin_labels_11_2
)

# Relevel so that in the HEATMAP order is Q4 → Q3 → Q2 → Q1
ann_all_11_2$margin <- factor(
    ann_all_11_2$margin,
    levels = rev(margin_labels_11_2)  # Q4, Q3, Q2, Q1
)

cat("\n[5] top_ct and margin (visual order Q4→Q1):\n")
print(table(ann_all_11_2$top_ct, ann_all_11_2$cohort, useNA = "ifany"))
cat("\n    summary(margin_numeric_11_2):\n")
print(summary(margin_numeric_11_2))
cat("\n    margin level counts:\n")
print(table(ann_all_11_2$margin, useNA = "ifany"))

# ------------------------------------------------
# 6) Column ordering:
#    1) by top_ct,
#    2) then margin (Q4→Q1, Q4 left),
#    3) within each, by descending top_ct score
# ------------------------------------------------
top_score_11_2 <- mat_combined_prom_11_2[cbind(top_idx_11_2,
                                               seq_along(top_idx_11_2))]

col_order_11_2 <- order(
    ann_all_11_2$top_ct,   # lineages
    ann_all_11_2$margin,   # Q4 → Q3 → Q2 → Q1
    -top_score_11_2        # strongest first
)

mat_ord_11_2  <- mat_combined_prom_11_2[, col_order_11_2, drop = FALSE]
ann_all_11_2  <- ann_all_11_2[col_order_11_2, , drop = FALSE]

# Gaps between lineage blocks (columns) and between rows
r_11_2 <- rle(as.character(ann_all_11_2$top_ct))
gaps_col_11_2 <- if (length(r_11_2$lengths) > 1L)
    cumsum(r_11_2$lengths)[-length(r_11_2$lengths)] else NULL
gaps_row_11_2 <- if (length(common_ct_11_2) > 1L)
    seq_len(length(common_ct_11_2) - 1L) else NULL

cat("\n[6] Final column order by top_ct, margin (Q4→Q1) and score:\n")
print(table(ann_all_11_2$top_ct, ann_all_11_2$cohort, useNA = "ifany"))

# ------------------------------------------------
# 7) Annotation colors (chunk-specific)
# ------------------------------------------------
annotation_colors_11_2 <- list(
    cohort = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
    top_ct = cell_type_colors_11_2[names(cell_type_colors_11_2) %in% common_ct_11_2],
    margin = margin_colors_11_2
)

# ------------------------------------------------
# 8) Final pheatmap
# ------------------------------------------------
pheatmap::pheatmap(
    mat_ord_11_2,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    annotation_col = ann_all_11_2,
    annotation_colors = annotation_colors_11_2,
    gaps_row       = gaps_row_11_2,
    gaps_col       = gaps_col_11_2,
    show_colnames  = FALSE,
    show_rownames  = TRUE,
    border_color   = NA,
    main = "11.2 – Ilaria PROM modules — SJ156 + Spain (PROM-only, margin Q4→Q1; Q4 most separated first)"
)




```

## 11.3 doing top ct per cell type

```{r}
# ================================================================
# 11.3 (DIAG) – Ilaria PROM modules (SJ156 + Spain)
#                Lineage-specific margin quartiles (within-top_ct Q1–Q4)
#                + heavy diagnostics (all dplyr:: prefixed)
# ================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(pheatmap)
})

# ------------------------------------------------
# 1) Guardrails & base matrix
# ------------------------------------------------
stopifnot(exists("mat_combined_prom_11_2"))
stopifnot(exists("ann_all_11_2"))

mat_combined_prom_11_3 <- mat_combined_prom_11_2
common_ct_11_3         <- rownames(mat_combined_prom_11_3)

cat("\n[11.3/1] Base matrix (PROM, SJ156 + Spain)\n")
cat("  dim:", paste(dim(mat_combined_prom_11_3), collapse = " × "), "\n")
cat("  lineages (rows):", paste(common_ct_11_3, collapse = ", "), "\n")
cat("  global range:", paste(range(mat_combined_prom_11_3, na.rm = TRUE), collapse = " to "), "\n\n")

# ------------------------------------------------
# 2) Winner, runner-up, top_score, margin (numeric)
# ------------------------------------------------
top_idx_11_3    <- apply(mat_combined_prom_11_3, 2, which.max)
top_ct_11_3     <- rownames(mat_combined_prom_11_3)[top_idx_11_3]

second_idx_11_3 <- apply(
    mat_combined_prom_11_3, 2,
    function(v) order(v, decreasing = TRUE)[2]
)

top_score_11_3 <- mat_combined_prom_11_3[
    cbind(top_idx_11_3, seq_along(top_idx_11_3))
]

margin_numeric_11_3 <- mat_combined_prom_11_3[
    cbind(top_idx_11_3,   seq_along(top_idx_11_3))
] -
    mat_combined_prom_11_3[
        cbind(second_idx_11_3, seq_along(second_idx_11_3))
    ]

cat("[11.3/2] Winner & margin diagnostics (ALL samples)\n")
cat("  top_score range:", paste(range(top_score_11_3), collapse = " to "), "\n")
cat("  margin range   :", paste(range(margin_numeric_11_3), collapse = " to "), "\n")
cat("  correlation(top_score, margin):",
    round(cor(top_score_11_3, margin_numeric_11_3), 3), "\n\n")

# ------------------------------------------------
# 3) Build per-sample diagnostic data.frame
# ------------------------------------------------
df_margin_11_3 <- data.frame(
    Sample              = colnames(mat_combined_prom_11_3),
    top_ct              = factor(top_ct_11_3, levels = common_ct_11_3),
    top_score_11_3      = top_score_11_3,
    margin_numeric_11_3 = margin_numeric_11_3,
    stringsAsFactors    = FALSE
)

cat("[11.3/3] Per-lineage summaries (before binning)\n")
df_summary_global_11_3 <- df_margin_11_3 %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        n              = dplyr::n(),
        top_min        = min(top_score_11_3),
        top_med        = stats::median(top_score_11_3),
        top_max        = max(top_score_11_3),
        margin_min     = min(margin_numeric_11_3),
        margin_med     = stats::median(margin_numeric_11_3),
        margin_max     = max(margin_numeric_11_3),
        cor_top_margin = stats::cor(top_score_11_3, margin_numeric_11_3),
        .groups        = "drop"
    )
print(df_summary_global_11_3)
cat("\n")

# ------------------------------------------------
# 4) Lineage-specific margin quartiles (within top_ct)
#    Q1 = lowest margins for that lineage, Q4 = highest
# ------------------------------------------------
margin_labels_11_3 <- c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")

df_margin_11_3 <- df_margin_11_3 %>%
    dplyr::group_by(top_ct) %>%
    dplyr::mutate(
        margin_ct_bin_11_3 = cut(
            margin_numeric_11_3,
            breaks = stats::quantile(
                margin_numeric_11_3,
                probs = seq(0, 1, 0.25),
                na.rm = TRUE
            ),
            include.lowest = TRUE,
            labels = margin_labels_11_3
        )
    ) %>%
    dplyr::ungroup()

cat("[11.3/4] Counts by top_ct × local margin quartile (within lineage)\n")
print(table(df_margin_11_3$top_ct, df_margin_11_3$margin_ct_bin_11_3))
cat("\n")

# Quantiles per lineage (to see exact cutpoints)
cat("[11.3/4b] Margin quantiles within each lineage\n")
df_margin_quant_11_3 <- df_margin_11_3 %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        q0    = min(margin_numeric_11_3),
        q25   = stats::quantile(margin_numeric_11_3, 0.25),
        q50   = stats::quantile(margin_numeric_11_3, 0.50),
        q75   = stats::quantile(margin_numeric_11_3, 0.75),
        q100  = max(margin_numeric_11_3),
        .groups = "drop"
    )
print(df_margin_quant_11_3)
cat("\n")

# ------------------------------------------------
# 5) Are some Q3 samples "redder" (higher top_score) than Q4?
#    This is the key diagnostic you care about.
# ------------------------------------------------
cat("[11.3/5] Cross-over check: max(top_score in Q3) vs min(top_score in Q4)\n")
df_crossover_11_3 <- df_margin_11_3 %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        max_top_Q3 = if (any(margin_ct_bin_11_3 == "Q3"))
            max(top_score_11_3[margin_ct_bin_11_3 == "Q3"]) else NA_real_,
        min_top_Q4 = if (any(margin_ct_bin_11_3 == "Q4 (highest)"))
            min(top_score_11_3[margin_ct_bin_11_3 == "Q4 (highest)"]) else NA_real_,
        Q3_higher_than_Q4 = (max_top_Q3 > min_top_Q4),
        .groups = "drop"
    )
print(df_crossover_11_3)
cat("\n")

# Example: inspect lineage B ordered as in the heatmap
cat("[11.3/5b] Example rows for lineage B (ordered: margin_ct Q4→Q1, top_score desc)\n")
df_B_11_3 <- df_margin_11_3 %>%
    dplyr::filter(top_ct == "B") %>%
    dplyr::arrange(
        factor(margin_ct_bin_11_3,
               levels = c("Q4 (highest)", "Q3", "Q2", "Q1 (lowest)")),
        dplyr::desc(top_score_11_3)
    ) %>%
    dplyr::select(
        Sample,
        top_ct,
        top_score_11_3,
        margin_numeric_11_3,
        margin_ct_bin_11_3
    )

print(utils::head(df_B_11_3, 25))
cat("\n")

# ------------------------------------------------
# 6) Build annotation data.frame for the heatmap
# ------------------------------------------------
ann_all_11_3 <- data.frame(
    Sample           = colnames(mat_combined_prom_11_3),
    stringsAsFactors = FALSE
)
rownames(ann_all_11_3) <- ann_all_11_3$Sample

# Reuse cohort from 11.2 (do NOT overwrite that object)
ann_all_11_3$cohort <- ann_all_11_2[ann_all_11_3$Sample, "cohort"]

# Attach lineage and lineage-specific margin bins
ann_all_11_3$top_ct <- df_margin_11_3$top_ct[
    match(ann_all_11_3$Sample, df_margin_11_3$Sample)
]

ann_all_11_3$margin_ct <- factor(
    df_margin_11_3$margin_ct_bin_11_3[
        match(ann_all_11_3$Sample, df_margin_11_3$Sample)
    ],
    levels = c("Q4 (highest)", "Q3", "Q2", "Q1 (lowest)")  # display order
)

cat("[11.3/6] Annotation head (after matching to samples)\n")
print(utils::head(ann_all_11_3))
cat("\nMargin_ct level counts:\n")
print(table(ann_all_11_3$margin_ct, useNA = "ifany"))
cat("\n")

# ------------------------------------------------
# 7) Column order:
#    1) by top_ct (HSCMPP→…→B),
#    2) within each lineage: margin_ct Q4→Q1,
#    3) within each bin: descending top_score_11_3
# ------------------------------------------------
col_order_11_3 <- order(
    ann_all_11_3$top_ct,
    ann_all_11_3$margin_ct,
    -df_margin_11_3$top_score_11_3[
        match(ann_all_11_3$Sample, df_margin_11_3$Sample)
    ]
)

mat_ord_11_3 <- mat_combined_prom_11_3[, col_order_11_3, drop = FALSE]
ann_all_11_3 <- ann_all_11_3[col_order_11_3, , drop = FALSE]

# Gaps for pheatmap
r_11_3 <- rle(as.character(ann_all_11_3$top_ct))
gaps_col_11_3 <- if (length(r_11_3$lengths) > 1L)
    cumsum(r_11_3$lengths)[-length(r_11_3$lengths)] else NULL
gaps_row_11_3 <- if (length(common_ct_11_3) > 1L)
    seq_len(length(common_ct_11_3) - 1L) else NULL

cat("[11.3/7] Final column counts by top_ct × cohort\n")
print(table(ann_all_11_3$top_ct, ann_all_11_3$cohort))
cat("\nGaps between lineage blocks (column indices):\n")
print(gaps_col_11_3)
cat("\n")

# ------------------------------------------------
# 8) Annotation colors (reuse palettes from 11.2)
# ------------------------------------------------
stopifnot(exists("cell_type_colors_11_2"), exists("margin_colors_11_2"))

annotation_colors_11_3 <- list(
    cohort    = c(SJ156 = "#1f78b4", Spain = "#33a02c"),
    top_ct    = cell_type_colors_11_2[
        names(cell_type_colors_11_2) %in% common_ct_11_3
    ],
    margin_ct = margin_colors_11_2
)

# ------------------------------------------------
# 9) Heatmap
# ------------------------------------------------
cat("[11.3/9] Drawing heatmap (lineage-specific margins Q4→Q1, DIAG)\n\n")

pheatmap::pheatmap(
    mat_ord_11_3,
    cluster_rows   = FALSE,
    cluster_cols   = FALSE,
    annotation_col = ann_all_11_3,
    annotation_colors = annotation_colors_11_3,
    gaps_row       = gaps_row_11_3,
    gaps_col       = gaps_col_11_3,
    show_colnames  = FALSE,
    show_rownames  = TRUE,
    border_color   = NA,
    main = "11.3 – Ilaria PROM modules — SJ156 + Spain\nLineage-specific margin quartiles (within-top_ct Q4→Q1; DIAG)"
)

```


## 11.4 without healthy
####11.4.1 preparation
```{r}
cat("\n================= FIX SJ GENE-LEVEL COLNAMES =================\n")

# Shortcuts
counts_sj         <- sj156_state$counts
gene_counts_sj    <- sj156_state$gene_counts_sj
gene_counts_sj_prom <- sj156_state$gene_counts_sj_prom
gene_counts_sj_enh  <- sj156_state$gene_counts_sj_enh

# 1. Safety: check column numbers match
stopifnot(
    ncol(counts_sj)         == ncol(gene_counts_sj),
    ncol(counts_sj)         == ncol(gene_counts_sj_prom),
    ncol(counts_sj)         == ncol(gene_counts_sj_enh)
)

cat("  • ncol(counts_sj) =", ncol(counts_sj), "\n")
cat("  • Column counts match across all SJ matrices ✔\n")

# 2. Copy colnames from counts_sj into all gene-level matrices
colnames(gene_counts_sj)      <- colnames(counts_sj)
colnames(gene_counts_sj_prom) <- colnames(counts_sj)
colnames(gene_counts_sj_enh)  <- colnames(counts_sj)

# 3. Write back into sj156_state to keep list and globals in sync
sj156_state$gene_counts_sj      <- gene_counts_sj
sj156_state$gene_counts_sj_prom <- gene_counts_sj_prom
sj156_state$gene_counts_sj_enh  <- gene_counts_sj_enh

# 4. Optional: quick sanity print
cat("\n[POST-FIX] Example colnames after repair:\n")
print(head(colnames(gene_counts_sj)))
print(head(colnames(gene_counts_sj_prom)))
print(head(colnames(gene_counts_sj_enh)))

cat("\n================= END FIX SJ GENE-LEVEL COLNAMES =================\n")

```

```{r}
# ================================================================
# 11.4 – Ilaria PROM modules — SJ156 only
#        Global margin quartiles (SJ-only, 11.2 / Tian-style)
#        Clean: NO Sample annotation, NO cohort
# ================================================================
# ================================================================
# TASK 2 — Spain-derived PROMOTER / ENHANCER markers on SJ156 + Healthy
# Using the markers you generated from the Spanish Data (promoter/enhancer)
# to plot the Spanish (Healthy) and SJ156 samples
# ================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(edgeR)
    library(pheatmap)
})

# ------------------------------------------------
# 1) Load core states (SJ156 + Healthy/Spain)
# ------------------------------------------------
combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"

if (!exists("sj156_state") || !exists("spain_state")) {
    cat("[1] Loading sj156_state and spain_state from:\n  ", combined_dir, "\n")
    
    if (!file.exists(file.path(combined_dir, "sj156_atac_core_state.rds"))) {
        stop("sj156_atac_core_state.rds not found in combined_dir.\n",
             "  → Please run the SJ156 saving chunk that creates sj156_atac_core_state.rds.")
    }
    if (!file.exists(file.path(combined_dir, "spain_atac_core_state.rds"))) {
        stop("spain_atac_core_state.rds not found in combined_dir.\n",
             "  → Please run the Spain saving chunk that creates spain_atac_core_state.rds.")
    }
    
    sj156_state <- readRDS(file.path(combined_dir, "sj156_atac_core_state.rds"))
    spain_state <- readRDS(file.path(combined_dir, "spain_atac_core_state.rds"))
} else {
    cat("[1] Using existing sj156_state and spain_state in memory.\n")
}

# ------------------------------------------------
# 2) Extract Spain-derived marker panels + gene-level counts
# ------------------------------------------------
panel_spain_prom_long <- spain_state$panel_spain_prom_long
panel_spain_enh_long  <- spain_state$panel_spain_enh_long
ct_spain_order        <- spain_state$ct_spain_order

if (is.null(panel_spain_prom_long) || is.null(panel_spain_enh_long)) {
    stop("panel_spain_prom_long or panel_spain_enh_long not found in spain_state.\n",
         "  → Make sure Spain marker panels are stored in spain_atac_core_state.rds.")
}

# Gene-level counts
gene_counts_sj      <- sj156_state$gene_counts_sj
gene_counts_healthy <- spain_state$gene_counts_spain

if (is.null(gene_counts_sj) || is.null(gene_counts_healthy)) {
    stop("gene_counts_sj or gene_counts_spain is NULL.\n",
         "  → Make sure both RDS files contain gene-level matrices.")
}

gene_counts_sj      <- as.matrix(gene_counts_sj)
gene_counts_healthy <- as.matrix(gene_counts_healthy)

cat("\n[2] Spain-derived marker panels (long format):\n")
cat("    ct_spain_order:", paste(ct_spain_order, collapse = " → "), "\n")
cat("    PROMOTER rows:", nrow(panel_spain_prom_long),
    " | unique genes:", length(unique(panel_spain_prom_long$gene)), "\n")
cat("    ENHANCER rows:", nrow(panel_spain_enh_long),
    " | unique genes:", length(unique(panel_spain_enh_long$gene)), "\n")

cat("\n[2b] Gene-level counts dimensions (genes × samples):\n")
cat("    SJ156  : ", paste(dim(gene_counts_sj),      collapse = " × "), "\n", sep = "")
cat("    Healthy: ", paste(dim(gene_counts_healthy), collapse = " × "), "\n", sep = "")

if (is.null(rownames(gene_counts_sj)) || is.null(rownames(gene_counts_healthy))) {
    stop("gene_counts_sj or gene_counts_healthy lack rownames (gene IDs). Please fix before proceeding.")
}

cat("\n[2c] Example gene IDs:\n")
cat("    SJ156 genes   :", paste(utils::head(rownames(gene_counts_sj), 10),      collapse = ", "), "\n")
cat("    Healthy genes :", paste(utils::head(rownames(gene_counts_healthy), 10), collapse = ", "), "\n")

# Asegurar niveles ordenados de cell_type
panel_spain_prom_long$cell_type <- factor(panel_spain_prom_long$cell_type,
                                          levels = ct_spain_order)
panel_spain_enh_long$cell_type  <- factor(panel_spain_enh_long$cell_type,
                                          levels = ct_spain_order)

# ------------------------------------------------
# 3) Diagnóstico de umbral en Healthy (España)
# ------------------------------------------------

check_threshold <- function(panel_long,
                            gene_counts_mat,
                            min_counts,
                            min_samples,
                            panel_label = "PANEL") {
    stopifnot(is.matrix(gene_counts_mat))
    
    cat("\n=== [check_threshold] ", panel_label,
        " | min_counts =", min_counts,
        " / min_samples =", min_samples, " ===\n", sep = "")
    
    ct_vals <- unique(panel_long$cell_type)
    
    for (ct in ct_vals) {
        g_ct <- unique(panel_long$gene[panel_long$cell_type == ct])
        g_ct <- intersect(g_ct, rownames(gene_counts_mat))
        
        if (length(g_ct) == 0L) {
            cat("  -", as.character(ct), ": panel=0 (ningún gen presente en counts)\n")
            next
        }
        
        expr   <- gene_counts_mat[g_ct, , drop = FALSE]
        keep   <- rowSums(expr >= min_counts) >= min_samples
        n_all  <- length(g_ct)
        n_keep <- sum(keep)
        
        cat("  -", as.character(ct), ": panel =", n_all,
            " | retenidos =", n_keep,
            sprintf(" (%.1f%%)", 100 * n_keep / n_all), "\n")
    }
}

# Lanza algunos thresholds para ver qué tan agresivo es 10/3
check_threshold(
    panel_long      = panel_spain_prom_long,
    gene_counts_mat = gene_counts_healthy,
    min_counts      = 5,
    min_samples     = 3,
    panel_label     = "PROMOTER"
)

check_threshold(
    panel_long      = panel_spain_prom_long,
    gene_counts_mat = gene_counts_healthy,
    min_counts      = 10,
    min_samples     = 3,
    panel_label     = "PROMOTER"
)

check_threshold(
    panel_long      = panel_spain_enh_long,
    gene_counts_mat = gene_counts_healthy,
    min_counts      = 5,
    min_samples     = 3,
    panel_label     = "ENHANCER"
)

check_threshold(
    panel_long      = panel_spain_enh_long,
    gene_counts_mat = gene_counts_healthy,
    min_counts      = 10,
    min_samples     = 3,
    panel_label     = "ENHANCER"
)

# Aquí decides, viendo las salidas, si 10/3 es razonable
# (que cada linaje conserve un número decente de genes, no 2–3).
# Por ahora seguimos con 10/3 como default, pero AJÚSTALO si ves algo raro.

# ------------------------------------------------
# 4) Congelar marcadores Spain en Healthy (Opción B)
# ------------------------------------------------

freeze_spain_markers <- function(panel_long,
                                 gene_counts_healthy,
                                 ct_levels,
                                 min_counts  = 10,
                                 min_samples = 3) {
    stopifnot(is.matrix(gene_counts_healthy))
    
    cat("\n[3] Congelando marcadores Spain en Healthy con umbrales:\n",
        "    min_counts  =", min_counts, "\n",
        "    min_samples =", min_samples, "\n")
    
    marker_list_raw <- split(panel_long$gene, panel_long$cell_type)
    marker_list_raw <- lapply(marker_list_raw, unique)
    
    marker_list_frozen <- list()
    
    for (ct in ct_levels) {
        g_ct <- marker_list_raw[[ct]]
        if (is.null(g_ct)) {
            cat("  [freeze] WARNING: no hay genes listados para", ct, "en panel_long\n")
            next
        }
        
        g_in_counts <- intersect(g_ct, rownames(gene_counts_healthy))
        if (length(g_in_counts) == 0L) {
            cat("  [freeze] WARNING:", ct, "sin genes presentes en gene_counts_healthy\n")
            next
        }
        
        expr <- gene_counts_healthy[g_in_counts, , drop = FALSE]
        keep <- rowSums(expr >= min_counts) >= min_samples
        g_keep <- g_in_counts[keep]
        
        cat("  [freeze] ", ct, ": panel =", length(g_ct),
            " | en_counts =", length(g_in_counts),
            " | retenidos =", length(g_keep), "\n", sep = "")
        
        if (length(g_keep) > 0L) {
            marker_list_frozen[[ct]] <- g_keep
        }
    }
    
    nonempty_ct <- intersect(ct_levels, names(marker_list_frozen))
    marker_list_frozen <- marker_list_frozen[nonempty_ct]
    
    cat("  [freeze] Lineajes finales con ≥1 gen marcador:\n      ",
        paste(names(marker_list_frozen), collapse = ", "), "\n")
    
    invisible(marker_list_frozen)
}

# Usa 10/3 por defecto, pero cámbialo si el diagnóstico te dice que es muy agresivo
frozen_prom_markers <- freeze_spain_markers(
    panel_long          = panel_spain_prom_long,
    gene_counts_healthy = gene_counts_healthy,
    ct_levels           = ct_spain_order,
    min_counts          = 10,
    min_samples         = 3
)

frozen_enh_markers <- freeze_spain_markers(
    panel_long          = panel_spain_enh_long,
    gene_counts_healthy = gene_counts_healthy,
    ct_levels           = ct_spain_order,
    min_counts          = 10,
    min_samples         = 3
)

# ------------------------------------------------
# 5) Construir módulos usando marcadores congelados
# ------------------------------------------------

build_modules_with_frozen_markers <- function(gene_counts,
                                              frozen_markers,
                                              clip_z = 2) {
    stopifnot(is.matrix(gene_counts))
    
    cat("  [modules_frozen] Input dim (genes × samples):",
        paste(dim(gene_counts), collapse = " × "), "\n")
    
    all_marker_genes <- unique(unlist(frozen_markers))
    genes_use <- intersect(all_marker_genes, rownames(gene_counts))
    if (length(genes_use) == 0L) {
        stop("  [modules_frozen] Ningún gen marcador congelado se encontró en gene_counts.")
    }
    
    gene_counts_sub <- gene_counts[genes_use, , drop = FALSE]
    cat("  [modules_frozen] Genes presentes de marcadores congelados:",
        nrow(gene_counts_sub), "\n")
    
    keep_nonzero <- rowSums(gene_counts_sub) > 0
    gene_counts_sub <- gene_counts_sub[keep_nonzero, , drop = FALSE]
    cat("  [modules_frozen] Tras quitar genes todo-cero:",
        nrow(gene_counts_sub), "genes.\n")
    
    logcpm <- edgeR::cpm(gene_counts_sub, log = TRUE, prior.count = 1)
    
    z_gene <- t(scale(t(logcpm)))
    z_gene[is.na(z_gene)] <- 0
    if (!is.null(clip_z)) {
        z_gene <- pmin(pmax(z_gene, -clip_z), clip_z)
    }
    
    ct_levels <- names(frozen_markers)
    avg_list <- lapply(ct_levels, function(ct) {
        g_ct <- intersect(frozen_markers[[ct]], rownames(z_gene))
        if (length(g_ct) == 0L) {
            cat("    [modules_frozen] WARNING:", ct,
                "tiene 0 genes presentes en este cohorte → fila NA.\n")
            return(rep(NA_real_, ncol(z_gene)))
        } else {
            return(colMeans(z_gene[g_ct, , drop = FALSE]))
        }
    })
    
    avg_z_by_ct <- do.call(rbind, avg_list)
    rownames(avg_z_by_ct) <- ct_levels
    colnames(avg_z_by_ct) <- colnames(z_gene)
    
    cat("  [modules_frozen] avg_z_by_ct dim (lineajes × muestras):",
        paste(dim(avg_z_by_ct), collapse = " × "), "\n")
    
    invisible(list(avg_z_by_ct = avg_z_by_ct, z_gene = z_gene))
}

# ------------------------------------------------
# 6) Heatmap conjunto SJ156 + Healthy con marcadores congelados
# ------------------------------------------------

cell_type_colors_spain <- c(
    HSC          = "#fb8072",
    CLP          = "#bebada",
    ProB         = "#ff33ff",
    PreB         = "#00e5c0",
    `Immature-B` = "#00bfff"
)

build_spain_joint_heatmap_frozen <- function(frozen_markers,
                                             marker_label = c("PROMOTER", "ENHANCER")) {
    marker_label <- match.arg(marker_label)
    cat("\n[4] Joint heatmap con MARCADORES CONGELADOS Spain (",
        marker_label, ") en SJ156 + Healthy...\n", sep = "")
    
    cat("    [4] Módulos en SJ156...\n")
    mods_sj <- build_modules_with_frozen_markers(
        gene_counts    = gene_counts_sj,
        frozen_markers = frozen_markers,
        clip_z         = 2
    )
    
    cat("    [4] Módulos en Healthy...\n")
    mods_healthy <- build_modules_with_frozen_markers(
        gene_counts    = gene_counts_healthy,
        frozen_markers = frozen_markers,
        clip_z         = 2
    )
    
    mat_sj      <- mods_sj$avg_z_by_ct
    mat_healthy <- mods_healthy$avg_z_by_ct
    
    common_ct <- intersect(rownames(mat_sj), rownames(mat_healthy))
    mat_sj      <- mat_sj[common_ct, , drop = FALSE]
    mat_healthy <- mat_healthy[common_ct, , drop = FALSE]
    
    mat_combined <- cbind(mat_sj, mat_healthy)
    
    cat("    [4] Matriz combinada dim (lineajes × muestras):",
        paste(dim(mat_combined), collapse = " × "), "\n")
    cat("    [4] Lineajes comunes:",
        paste(common_ct, collapse = ", "), "\n")
    
    samples_sj      <- colnames(mat_sj)
    samples_healthy <- colnames(mat_healthy)
    
    ann_all <- data.frame(
        cohort = factor(c(rep("SJ156",  length(samples_sj)),
                          rep("Healthy", length(samples_healthy))),
                        levels = c("SJ156", "Healthy")),
        row.names = c(samples_sj, samples_healthy)
    )
    ann_all <- ann_all[colnames(mat_combined), , drop = FALSE]
    
    top_idx <- apply(mat_combined, 2, function(v) {
        if (all(is.na(v))) return(NA_integer_)
        which.max(v)
    })
    top_ct <- ifelse(is.na(top_idx),
                     NA_character_,
                     rownames(mat_combined)[top_idx])
    ann_all$top_ct <- factor(top_ct, levels = common_ct)
    
    cat("    [4b] Distribución top_ct × cohorte (antes de ordenar):\n")
    print(table(ann_all$top_ct, ann_all$cohort, useNA = "ifany"))
    
    col_order <- character(0)
    for (ct in common_ct) {
        cols_ct_sj      <- rownames(ann_all)[ann_all$top_ct == ct & ann_all$cohort == "SJ156"]
        cols_ct_healthy <- rownames(ann_all)[ann_all$top_ct == ct & ann_all$cohort == "Healthy"]
        col_order       <- c(col_order, cols_ct_sj, cols_ct_healthy)
    }
    col_order <- col_order[col_order %in% colnames(mat_combined)]
    
    mat_ord <- mat_combined[, col_order, drop = FALSE]
    ann_all <- ann_all[col_order, , drop = FALSE]
    
    r <- rle(as.character(ann_all$top_ct))
    gaps_col <- if (length(r$lengths) > 1L) cumsum(r$lengths)[-length(r$lengths)] else NULL
    gaps_row <- if (length(common_ct) > 1L) seq_len(length(common_ct) - 1L) else NULL
    
    cat("    [4c] Final top_ct × cohorte (después de ordenar):\n")
    print(table(ann_all$top_ct, ann_all$cohort, useNA = "ifany"))
    cat("    [4c] gaps_row:",
        if (is.null(gaps_row)) "NONE" else paste(gaps_row, collapse = ", "),
        "\n")
    cat("    [4c] gaps_col:",
        if (is.null(gaps_col)) "NONE" else paste(gaps_col, collapse = ", "),
        "\n")
    
    annotation_colors <- list(
        cohort = c(SJ156 = "#1f78b4", Healthy = "#33a02c"),
        top_ct = cell_type_colors_spain[names(cell_type_colors_spain) %in% common_ct]
    )
    
    pheatmap::pheatmap(
        mat_ord,
        cluster_rows   = FALSE,
        cluster_cols   = FALSE,
        annotation_col = ann_all,
        annotation_colors = annotation_colors,
        gaps_row       = gaps_row,
        gaps_col       = gaps_col,
        show_colnames  = FALSE,
        show_rownames  = TRUE,
        border_color   = NA,
        main = paste0(
            "Frozen Spain-derived ", marker_label,
            " markers — SJ156 + Healthy (gene-level modules)"
        )
    )
}

# ------------------------------------------------
# 7) Ejecutar para PROMOTER y ENHANCER
# ------------------------------------------------
build_spain_joint_heatmap_frozen(frozen_prom_markers, marker_label = "PROMOTER")
build_spain_joint_heatmap_frozen(frozen_enh_markers,  marker_label = "ENHANCER")

```


# 12  UMAP

```{r}
# ================================================================
# X. UMAP of promoter accessibility (SJ156 + Healthy, gene-level)
#    One embedding, all samples, features = promoter genes
#    NOW WITH ComBat batch correction (batch = cohort)
# ================================================================
suppressPackageStartupMessages({
    library(dplyr)
    library(DESeq2)
    library(matrixStats)
    library(uwot)
    library(ggplot2)
    library(sva)      # <- ComBat
})

# ------------------------------
# 1) Load core states if needed
# ------------------------------
combined_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/stjudes_156/atacseq/peaks_sj_156_exploration/combined_sj156_spain"

if (!exists("sj156_state") || !exists("healthy_state")) {
    cat("[1] Loading sj156_state and healthy_state from:\n   ", combined_dir, "\n")
    sj156_state    <- readRDS(file.path(combined_dir, "sj156_atac_core_state.rds"))
    healthy_state  <- readRDS(file.path(combined_dir, "spain_atac_core_state.rds"))  # ORIGINAL FILE NAME
} else {
    cat("[1] Using sj156_state and healthy_state already in memory.\n")
}

# -------------------------------------------------
# 2) Build / obtain GENE-LEVEL promoter counts
# -------------------------------------------------

## 2a. SJ156
promoter_counts_sj <- sj156_state$promoter_counts_sj
peak_anno_sj       <- sj156_state$peak_anno

cat("\n[2a] SJ156 promoter_counts_sj dim: ",
    paste(dim(promoter_counts_sj), collapse = " × "), "\n", sep = "")
cat("[2a] SJ156 peak_anno_sj rows: ", nrow(peak_anno_sj), "\n", sep = "")

prom_anno <- peak_anno_sj[match(rownames(promoter_counts_sj),
                                peak_anno_sj$peak_id), ]

if (any(is.na(prom_anno$peak_id))) {
    missing <- rownames(promoter_counts_sj)[is.na(prom_anno$peak_id)]
    print(head(missing))
    stop("Fix peak_anno_sj / promoter_counts_sj alignment before continuing.")
}
stopifnot(identical(rownames(promoter_counts_sj), prom_anno$peak_id))

valid_gene <- !is.na(prom_anno$SYMBOL) & prom_anno$SYMBOL != ""
prom_anno_use      <- prom_anno[valid_gene, , drop = FALSE]
prom_counts_sj_use <- promoter_counts_sj[valid_gene, , drop = FALSE]

cat("[2a] promoter_counts_sj_use dim: ",
    paste(dim(prom_counts_sj_use), collapse = " × "), "\n", sep = "")

gene2peaks_sj <- split(prom_anno_use$peak_id, prom_anno_use$SYMBOL)

gene_counts_sj_prom <- vapply(
    gene2peaks_sj,
    function(peaks) colSums(prom_counts_sj_use[peaks, , drop = FALSE]),
    FUN.VALUE = numeric(ncol(prom_counts_sj_use))
)
gene_counts_sj_prom <- t(gene_counts_sj_prom)
colnames(gene_counts_sj_prom) <- colnames(prom_counts_sj_use)

cat("[2a] gene_counts_sj_prom dim: ",
    paste(dim(gene_counts_sj_prom), collapse = " × "), "\n", sep = "")

## 2b. Healthy
if (!is.null(healthy_state$gene_counts_spain_prom)) {
    gene_counts_healthy_prom <- as.matrix(healthy_state$gene_counts_spain_prom)
    cat("\n[2b] gene_counts_healthy_prom dim: ",
        paste(dim(gene_counts_healthy_prom), collapse = " × "), "\n", sep = "")
} else {
    stop("[2b] healthy_state$gene_counts_spain_prom is NULL.")
}

# -------------------------------------------------
# 3) Combine cohorts
# -------------------------------------------------
common_genes <- intersect(rownames(gene_counts_sj_prom),
                          rownames(gene_counts_healthy_prom))
cat("\n[3] Common promoter genes SJ156 ∩ Healthy: ",
    length(common_genes), "\n", sep = "")

gene_counts_sj_prom       <- gene_counts_sj_prom[common_genes, , drop = FALSE]
gene_counts_healthy_prom  <- gene_counts_healthy_prom[common_genes, , drop = FALSE]

prom_mat <- cbind(gene_counts_sj_prom, gene_counts_healthy_prom)

cat("[3] Combined promoter gene matrix dim: ",
    paste(dim(prom_mat), collapse = " × "), "\n", sep = "")

# -------------------------------------------------
# 4) Filter genes
# -------------------------------------------------
MIN_READS_UMAP   <- 5L
MIN_SAMPLES_UMAP <- 3L
N_TOP_VAR_UMAP   <- 5000L

keep <- rowSums(prom_mat >= MIN_READS_UMAP) >= MIN_SAMPLES_UMAP
prom_mat_filt <- prom_mat[keep, , drop = FALSE]

cat("\n[4] Genes passing min thresholds: ",
    nrow(prom_mat_filt), "\n", sep = "")

if (nrow(prom_mat_filt) > N_TOP_VAR_UMAP) {
    v <- matrixStats::rowVars(prom_mat_filt)
    o <- order(v, decreasing = TRUE)[seq_len(N_TOP_VAR_UMAP)]
    prom_mat_filt <- prom_mat_filt[o, , drop = FALSE]
    cat("[4] Restricted to top ", N_TOP_VAR_UMAP, " variable genes.\n", sep = "")
}

# -------------------------------------------------
# 5) VST transform
# -------------------------------------------------
n_sj      <- ncol(gene_counts_sj_prom)
n_healthy <- ncol(gene_counts_healthy_prom)

cat("\n[5] Samples — SJ156:", n_sj, "| Healthy:", n_healthy, "\n")

col_data_umap <- data.frame(
    Sample = colnames(prom_mat_filt),
    cohort = factor(c(rep("SJ156",  n_sj),
                      rep("Healthy", n_healthy)),
                    levels = c("SJ156", "Healthy"))
)

dds_umap <- DESeqDataSetFromMatrix(
    countData = prom_mat_filt,
    colData   = col_data_umap,
    design    = ~ 1
)
dds_umap <- estimateSizeFactors(dds_umap)
vsd_umap <- vst(dds_umap, blind = TRUE)
mat_vst  <- assay(vsd_umap)

# -------------------------------------------------
# 6) ComBat correction
# -------------------------------------------------
cat("\n[6] Running ComBat batch correction (batch = cohort)...\n")

batch <- col_data_umap$cohort
mod   <- model.matrix(~1, data = col_data_umap)

mat_vst_cb <- ComBat(
    dat   = as.matrix(mat_vst),
    batch = batch,
    mod   = mod,
    par.prior   = TRUE,
    prior.plots = FALSE
)

# -------------------------------------------------
# 7) UMAP embedding
# -------------------------------------------------
set.seed(123)

n_neighbors <- min(15L, ncol(mat_vst_cb) - 1L)

umap_coords <- uwot::umap(
    X           = t(mat_vst_cb),
    n_neighbors = n_neighbors,
    min_dist    = 0.3,
    metric      = "euclidean"
)

umap_df <- data.frame(
    Sample = colnames(mat_vst_cb),
    UMAP1  = umap_coords[, 1],
    UMAP2  = umap_coords[, 2],
    cohort = col_data_umap$cohort,
    stringsAsFactors = FALSE
)

# -------------------------------------------------
# 8) Metadata join (Healthy instead of Spain)
# -------------------------------------------------
meta_sj <- sj156_state$meta_sj %>%
    dplyr::select(Sample, genotype, Subtype) %>%
    mutate(cohort = "SJ156")

meta_healthy <- healthy_state$meta_spain %>%   # original name
    dplyr::select(Sample, genotype, cell_type) %>%
    mutate(cohort = "Healthy")

meta_all <- bind_rows(meta_sj, meta_healthy) %>%
    mutate(
        Sample   = as.character(Sample),
        cohort   = factor(cohort, levels = c("SJ156", "Healthy")),
        genotype = factor(genotype, levels = c("TT", "TC", "CC"))
    )

umap_df <- umap_df %>%
    left_join(meta_all, by = c("Sample", "cohort"))

# -------------------------------------------------
# 9) UMAP plots
# -------------------------------------------------
geno_cols <- sj156_state$geno_cols

## 9a — Genotype / Cohort
ggplot(umap_df, aes(UMAP1, UMAP2, color = genotype, shape = cohort)) +
    geom_point(size = 3, alpha = 0.9) +
    scale_color_manual(values = geno_cols) +
    theme_bw(14) +
    labs(
        title = "UMAP of promoter accessibility (SJ156 + Healthy, ComBat-corrected)",
        subtitle = "Features = promoter genes (VST + ComBat)",
        color = "Genotype",
        shape = "Cohort"
    )

## 9b — SJ subtype vs Healthy true cell type
ggplot(umap_df, aes(UMAP1, UMAP2)) +
    geom_point(aes(color = Subtype),
               data = subset(umap_df, cohort == "SJ156"),
               size = 3, alpha = 0.9) +
    geom_point(aes(color = cell_type),
               data = subset(umap_df, cohort == "Healthy"),
               size = 3, alpha = 0.9, shape = 17) +
    theme_bw(14) +
    labs(
        title = "UMAP promoter space: SJ156 subtypes vs Healthy cell types",
        subtitle = "Circles = SJ156, triangles = Healthy",
        x = "UMAP1", y = "UMAP2"
    )

```
# 13 Confusion matrix
```{r}
# ================================================================
# CONFUSION MATRIX — Naive CD5± removed + Transitional-B removed
# Dev order updated accordingly
# ================================================================
suppressPackageStartupMessages({
    library(ggplot2)
    library(FNN)
    library(dplyr)
    library(tidyr)
})

cat("\n=== CONFUSION MATRIX (FULL VERSION) — Naive CD5± + Transitional-B removed ===\n")

# -------------------------------------------------------------
# 0) Define developmental order (Transitional-B REMOVED)
# -------------------------------------------------------------
dev_order <- c("HSC", "CLP", "ProB", "PreB", "Immature-B")

# -------------------------------------------------------------
# 1) Healthy reference (remove Naives + Transitional-B)
# -------------------------------------------------------------
healthy_ref <- umap_df %>%
    dplyr::filter(cohort == "Healthy", !is.na(cell_type)) %>%
    dplyr::filter(!(cell_type %in% c("Naive-CD5-", "Naive-CD5--", "Transitional-B")))

cat("[CHECK] Healthy_ref n=", nrow(healthy_ref), "\n", sep = "")
cat("[CHECK] Healthy_ref cell_type counts:\n")
print(sort(table(healthy_ref$cell_type), decreasing = TRUE))

if (nrow(healthy_ref) == 0L) stop("No Healthy samples with valid cell_type after filtering.")

healthy_centroids <- healthy_ref %>%
    dplyr::group_by(cell_type) %>%
    dplyr::summarize(
        CX = mean(UMAP1),
        CY = mean(UMAP2),
        n  = dplyr::n(),
        .groups = "drop"
    ) %>%
    dplyr::mutate(cell_type = factor(cell_type, levels = dev_order)) %>%
    dplyr::arrange(cell_type)

cat("\n[1] Healthy centroids (filtered):\n")
print(healthy_centroids)

# -------------------------------------------------------------
# 2) Classify SJ156 by nearest centroid + compute confidence
# -------------------------------------------------------------
sj_samples_umap <- umap_df %>%
    dplyr::filter(cohort == "SJ156") %>%
    dplyr::select(Sample, UMAP1, UMAP2)

centroid_mat <- as.matrix(healthy_centroids[, c("CX", "CY")])
sj_mat       <- as.matrix(sj_samples_umap[, c("UMAP1", "UMAP2")])

nearest_idx <- FNN::knnx.index(
    data  = centroid_mat,
    query = sj_mat,
    k     = 1
)

all_dist <- FNN::knnx.dist(
    data  = centroid_mat,
    query = sj_mat,
    k     = nrow(centroid_mat)
)

closest        <- all_dist[, 1]
second_closest <- all_dist[, 2]
confidence_ratio <- closest / second_closest  # closer to 0 => more confident

sj_samples_umap <- sj_samples_umap %>%
    dplyr::mutate(
        inferred_lineage  = as.character(healthy_centroids$cell_type[nearest_idx]),
        confidence_ratio  = confidence_ratio
    )

# -------------------------------------------------------------
# 3) Build confusion matrix (WITH dev order)
# -------------------------------------------------------------
sj_meta <- sj156_state$meta_sj %>% dplyr::select(Sample, Subtype)

conf_df <- sj_samples_umap %>%
    dplyr::left_join(sj_meta, by = "Sample") %>%
    dplyr::mutate(
        inferred_lineage = factor(inferred_lineage, levels = dev_order),
        Subtype          = factor(Subtype)
    )

conf_mat <- table(conf_df$Subtype, conf_df$inferred_lineage)

cat("\n[2] Confusion matrix with developmental ordering (filtered refs):\n")
print(conf_mat)

# -------------------------------------------------------------
# 4) Heatmap
# -------------------------------------------------------------
conf_df_plot <- as.data.frame(conf_mat)
colnames(conf_df_plot) <- c("SJ_Subtype", "Inferred_Lineage", "Count")

ggplot(conf_df_plot,
       aes(x = Inferred_Lineage, y = SJ_Subtype, fill = Count)) +
    geom_tile(color = "white") +
    geom_text(aes(label = Count), size = 4) +
    scale_fill_gradient(low = "#e0f3db", high = "#43a2ca") +
    theme_bw(base_size = 14) +
    labs(
        title    = "Confusion Matrix: SJ156 Subtypes vs Healthy Lineages",
        subtitle = "Nearest-centroid classifier (ComBat-corrected); Naive CD5± + Transitional-B removed",
        x = "Inferred lineage (Healthy reference)",
        y = "SJ156 subtype"
    )

# -------------------------------------------------------------
# 5) Subtype-specific stacked barplots (%)
# -------------------------------------------------------------
stack_df <- conf_df %>%
    dplyr::count(Subtype, inferred_lineage) %>%
    dplyr::group_by(Subtype) %>%
    dplyr::mutate(percent = 100 * n / sum(n)) %>%
    dplyr::ungroup()

ggplot(stack_df,
       aes(x = Subtype, y = percent, fill = inferred_lineage)) +
    geom_bar(stat = "identity", position = "stack") +
    scale_fill_brewer(palette = "Set2") +
    theme_bw(base_size = 14) +
    coord_flip() +
    labs(
        title = "Subtype-specific distribution of inferred lineages",
        subtitle = "Reference lineages exclude Naive CD5± and Transitional-B",
        y = "% of samples",
        x = "SJ156 subtype",
        fill = "Inferred lineage"
    )

# -------------------------------------------------------------
# 6) Confidence ratio histogram
# -------------------------------------------------------------
ggplot(conf_df, aes(x = confidence_ratio)) +
    geom_histogram(bins = 30, fill = "#1f78b4", color = "white", alpha = 0.8) +
    theme_bw(base_size = 14) +
    labs(
        title = "Classification confidence (distance ratio)",
        subtitle = "Closer to 0 = more confident classification",
        x = "Distance ratio (closest / second closest centroid)",
        y = "Count"
    )

cat("\n[CHECK] Assigned inferred_lineage counts (SJ156):\n")
print(conf_df %>% dplyr::count(inferred_lineage))

```
Ditch transitional B on both matrix and umap
 
# 14 Heatmap of sj156 using ilarias markers

```{r}
# =====================================================================
# ATAC — Ilaria dominance map with column-scaled module scores
#        (no sample should be "red for all lineages")
# =====================================================================
# Requires:
#   - counts_all_gene : matrix [genes × samples] (ATAC gene-level counts)
#   - meta_sj         : data.frame with columns Sample, genotype
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(readr)
    library(tibble)
    library(tidyr)
    library(pheatmap)
})

cat("\n[ILARIA-HEATMAP/ALL] =============================================\n")
cat("[ILARIA-HEATMAP/ALL] Starting heatmap generation for ALL PEAKS\n")

# ------------------------------------------------
# 0. Sanity: peak-level counts and annotation
# ------------------------------------------------
cat("[ILARIA-HEATMAP/ALL] Checking peak-level `counts` and `anno_df`...\n")
cat("  • counts class: ", paste(class(counts), collapse = ", "), "\n", sep = "")
cat("  • counts dim   : ", paste(dim(counts), collapse = " x "), "\n", sep = "")

if (is.null(rownames(counts)) || is.null(colnames(counts))) {
    stop("[ILARIA-HEATMAP/ALL] ERROR: `counts` must have both rownames (features) and colnames (samples).")
}

if (!exists("anno_df")) {
    stop("[ILARIA-HEATMAP/ALL] ERROR: `anno_df` not found. Run the annotatePeak chunk first.")
}

cat("  • anno_df dim  : ", paste(dim(anno_df), collapse = " x "), "\n", sep = "")
cat("  • anno_df cols : ", paste(colnames(anno_df), collapse = ", "), "\n", sep = "")

# anno_df must have peak_id + SYMBOL
stopifnot(all(c("peak_id", "SYMBOL") %in% colnames(anno_df)))

# ------------------------------------------------
# 0.1 Build peak → gene (SYMBOL) mapping
# ------------------------------------------------
cat("\n[ILARIA-HEATMAP/ALL] Building peak → gene mapping from anno_df...\n")

gene_map <- anno_df %>%
    dplyr::select(peak_id, SYMBOL) %>%
    filter(!is.na(SYMBOL), SYMBOL != "") %>%
    distinct()

cat("  • gene_map rows (peak_id with SYMBOL): ", nrow(gene_map), "\n", sep = "")
cat("  • unique SYMBOLs                     : ", length(unique(gene_map$SYMBOL)), "\n", sep = "")

# overlap between counts and gene_map
peaks_in_counts <- rownames(counts)
common_peaks    <- intersect(peaks_in_counts, gene_map$peak_id)

cat("  • peaks in counts          : ", length(peaks_in_counts), "\n", sep = "")
cat("  • peaks in gene_map        : ", length(unique(gene_map$peak_id)), "\n", sep = "")
cat("  • common peaks (used)      : ", length(common_peaks), "\n", sep = "")

if (length(common_peaks) == 0L) {
    stop("[ILARIA-HEATMAP/ALL] ERROR: No overlap between rownames(counts) and gene_map$peak_id.")
}

# ------------------------------------------------
# 0.2 Build gene-level ALL-PEAKS matrix (sum of peaks per SYMBOL)
# ------------------------------------------------
cat("\n[ILARIA-HEATMAP/ALL] Aggregating peak counts to gene-level (ALL PEAKS)...\n")

# Convert counts to data frame for easier join
counts_df <- as.data.frame(counts)
counts_df$peak_id <- rownames(counts_df)

# Restrict to common peaks and join SYMBOL
counts_gene_df <- gene_map %>%
    filter(peak_id %in% common_peaks) %>%
    left_join(counts_df, by = "peak_id")

cat("  • rows after join (peak x sample with SYMBOL): ",
    nrow(counts_gene_df), "\n", sep = "")

# Group by SYMBOL and sum across peaks for each gene
counts_gene_summarised <- counts_gene_df %>%
    dplyr::select(-peak_id) %>%
    group_by(SYMBOL) %>%
    summarise(across(.cols = where(is.numeric), .fns = sum), .groups = "drop")

cat("  • gene-level rows (SYMBOL): ",
    nrow(counts_gene_summarised), "\n", sep = "")

# Convert back to matrix
counts_all_gene <- counts_gene_summarised %>%
    as.data.frame()

rownames(counts_all_gene) <- counts_all_gene$SYMBOL
counts_all_gene$SYMBOL    <- NULL

counts_all_gene <- as.matrix(counts_all_gene)

cat("  • counts_all_gene dim (genes x samples): ",
    paste(dim(counts_all_gene), collapse = " x "), "\n", sep = "")
# ---------------------------------------------------------------------
# 1 — Load & clean Ilaria panel
# ---------------------------------------------------------------------
panel_path <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/clean_ilarias_700_genes.csv"

cat("[1] Loading curated Ilaria panel:\n    ", panel_path, "\n", sep = "")
df_raw <- readr::read_csv(panel_path, show_col_types = FALSE)

cat("[1] Raw panel dim (rows × cols): ",
    paste(dim(df_raw), collapse = " × "), "\n", sep = "")
cat("[1] Raw cell-type columns:\n")
print(colnames(df_raw))

df_updated <- df_raw %>%
    dplyr::mutate(
        dplyr::across(
            .cols = dplyr::everything(),
            .fns  = ~ {
                x <- as.character(.)
                x <- stringr::str_trim(x)
                dplyr::na_if(x, "")
            }
        )
    )

panel_long <- df_updated %>%
    tidyr::pivot_longer(
        cols      = dplyr::everything(),
        names_to  = "cell_type",
        values_to = "gene"
    ) %>%
    dplyr::filter(!is.na(gene), gene != "")

panel_genes <- unique(panel_long$gene)
ct_levels   <- colnames(df_updated)

cat("[1] Cleaned panel:\n")
cat("    • unique marker genes : ", length(panel_genes), "\n", sep = "")
cat("    • cell_type levels    : ", paste(ct_levels, collapse = " → "), "\n", sep = "")

markers_per_ct <- panel_long %>%
    dplyr::group_by(cell_type) %>%
    dplyr::summarise(n_markers = dplyr::n_distinct(gene), .groups = "drop")

cat("[1] Markers per cell type:\n")
print(markers_per_ct)

panel_dups <- panel_long %>%
    dplyr::group_by(gene) %>%
    dplyr::summarise(
        n_cell_types = dplyr::n_distinct(cell_type),
        .groups      = "drop"
    ) %>%
    dplyr::filter(n_cell_types > 1L)

cat("[1] Genes used in >1 lineage: ", nrow(panel_dups), "\n", sep = "")


# ---------------------------------------------------------------------
# 2 — Subset ATAC matrix to Ilaria genes
# ---------------------------------------------------------------------
cat("\n[2] Subsetting ATAC gene matrix to Ilaria genes...\n")

if (!exists("counts_all_gene")) {
    stop("[2] ERROR: `counts_all_gene` not found. Build gene-level matrix first.")
}

cat("[2] counts_all_gene dim (genes × samples): ",
    paste(dim(counts_all_gene), collapse = " × "), "\n", sep = "")

genes_in_atac <- intersect(rownames(counts_all_gene), panel_genes)
cat("[2] Overlap genes_in_atac: ", length(genes_in_atac), " / ",
    nrow(counts_all_gene), " genes\n", sep = "")

atac_mat <- counts_all_gene[genes_in_atac, , drop = FALSE]
cat("[2] atac_mat dim (subset): ",
    paste(dim(atac_mat), collapse = " × "), "\n", sep = "")


# ---------------------------------------------------------------------
# 3 — Per-gene z-score across samples
# ---------------------------------------------------------------------
cat("\n[3] Z-scoring per gene across samples...\n")

atac_z_gene <- t(scale(t(atac_mat)))
atac_z_gene[is.na(atac_z_gene)] <- 0

cat("[3] Sanity check — first 5 genes × 5 samples (z-scores):\n")
print(round(atac_z_gene[1:5, 1:5, drop = FALSE], 3))

col_means_z <- apply(atac_z_gene, 2, mean)
col_sds_z   <- apply(atac_z_gene, 2, sd)

cat("[3] Distribution of per-sample mean(z) across genes:\n")
print(summary(col_means_z))
cat("[3] Distribution of per-sample sd(z) across genes:\n")
print(summary(col_sds_z))


# ---------------------------------------------------------------------
# 4 — Expand to gene×cell-type rows (duplicate genes across lineages)
# ---------------------------------------------------------------------
cat("\n[4] Expanding to gene×cell-type rows...\n")

panel_expanded <- panel_long %>%
    dplyr::filter(gene %in% genes_in_atac) %>%
    dplyr::mutate(row_id = paste(gene, cell_type, sep = "|"))

cat("[4] panel_expanded rows: ", nrow(panel_expanded), "\n", sep = "")
cat("[4] unique row_id       : ", length(unique(panel_expanded$row_id)), "\n", sep = "")

atac_expanded <- panel_expanded %>%
    dplyr::select(row_id, gene, cell_type) %>%
    dplyr::left_join(
        atac_z_gene %>%
            as.data.frame() %>%
            tibble::rownames_to_column("gene"),
        by = "gene"
    )

cat("[4] atac_expanded rows after join: ", nrow(atac_expanded), "\n", sep = "")

mat_expanded <- atac_expanded %>%
    dplyr::select(-gene, -cell_type) %>%
    tibble::column_to_rownames("row_id") %>%
    as.matrix()

cat("[4] mat_expanded dim (gene×ct rows × samples): ",
    paste(dim(mat_expanded), collapse = " × "), "\n", sep = "")


# ---------------------------------------------------------------------
# 5 — Build raw module matrix: avg_z_by_ct_ATAC_raw
# ---------------------------------------------------------------------
cat("\n[5] Computing raw module activity matrix (avg_z_by_ct_ATAC_raw)...\n")

ct_for_row <- panel_expanded$cell_type
names(ct_for_row) <- panel_expanded$row_id
ct_for_row <- ct_for_row[rownames(mat_expanded)]

# check alignment
cat("[5] Alignment check — first 5 rows:\n")
print(head(cbind(ct_for_row = ct_for_row[1:5],
                 rowname   = names(ct_for_row)[1:5])))

avg_z_by_ct_ATAC_raw <- do.call(
    rbind,
    lapply(ct_levels, function(ct) {
        idx <- which(ct_for_row == ct)
        colMeans(mat_expanded[idx, , drop = FALSE], na.rm = TRUE)
    })
)
rownames(avg_z_by_ct_ATAC_raw) <- ct_levels

cat("[5] avg_z_by_ct_ATAC_raw dim (7 × samples): ",
    paste(dim(avg_z_by_ct_ATAC_raw), collapse = " × "), "\n", sep = "")

cat("[5] Example raw module scores (first 5 samples):\n")
print(round(avg_z_by_ct_ATAC_raw[, 1:5, drop = FALSE], 3))


# ---------------------------------------------------------------------
# 6 — Column-wise scaling (per-sample z across lineages)
# ---------------------------------------------------------------------
cat("\n[6] Column-wise scaling: z-score modules WITHIN each sample...\n")
cat("    (This enforces that, for each sample, some lineages are\n")
cat("     relatively high and others low — no all-red columns.)\n\n")

avg_z_by_ct_ATAC <- scale(avg_z_by_ct_ATAC_raw, center = TRUE, scale = TRUE)

cat("[6] Sanity — per-sample mean & sd across 7 lineages AFTER scaling:\n")
col_means_mod <- apply(avg_z_by_ct_ATAC, 2, mean)
col_sds_mod   <- apply(avg_z_by_ct_ATAC, 2, sd)
print(summary(col_means_mod))
print(summary(col_sds_mod))

# quick check: how many samples have all values > 0?
all_pos <- apply(avg_z_by_ct_ATAC, 2, function(v) all(v > 0))
cat("[6] Samples with ALL module scores > 0 (should be 0): ",
    sum(all_pos), "\n", sep = "")

cat("[6] Example scaled module scores (first 5 samples):\n")
print(round(avg_z_by_ct_ATAC[, 1:5, drop = FALSE], 3))


# ---------------------------------------------------------------------
# 7 — Dominant lineage + margins (using column-scaled matrix)
# ---------------------------------------------------------------------
cat("\n[7] Computing dominant lineage and Tian-style margins (scaled)...\n")

top_idx    <- apply(avg_z_by_ct_ATAC, 2, which.max)
second_idx <- apply(avg_z_by_ct_ATAC, 2, function(v) order(v, decreasing = TRUE)[2])

dominant_tbl_ATAC <- tibble::tibble(
    sample       = colnames(avg_z_by_ct_ATAC),
    top_ct       = ct_levels[top_idx],
    top_score    = avg_z_by_ct_ATAC[cbind(top_idx, seq_along(top_idx))],
    second_ct    = ct_levels[second_idx],
    second_score = avg_z_by_ct_ATAC[cbind(second_idx, seq_along(second_idx))]
) %>%
    dplyr::mutate(
        margin = top_score - second_score
    ) %>%
    dplyr::left_join(
        meta_sj %>% dplyr::select(Sample, genotype),
        by = c("sample" = "Sample")
    )

cat("[7] First 10 dominance calls:\n")
print(utils::head(dominant_tbl_ATAC, 10))

cat("\n[7] Frequency of top_ct assignments:\n")
print(sort(table(dominant_tbl_ATAC$top_ct), decreasing = TRUE))

cat("\n[7] Margin summary (larger = more confident):\n")
print(summary(dominant_tbl_ATAC$margin))


# ---------------------------------------------------------------------
# 8 — Order samples: top_ct → margin → top_score
# ---------------------------------------------------------------------
cat("\n[8] Ordering samples by (top_ct → margin → top_score)...\n")

col_order <- order(
    factor(dominant_tbl_ATAC$top_ct, levels = ct_levels),
    -dominant_tbl_ATAC$margin,
    -dominant_tbl_ATAC$top_score
)

avg_z_by_ct_ord  <- avg_z_by_ct_ATAC[, col_order, drop = FALSE]
dominant_tbl_ord <- dominant_tbl_ATAC[col_order, ]

cat("[8] Ordered module matrix dim: ",
    paste(dim(avg_z_by_ct_ord), collapse = " × "), "\n", sep = "")


# ---------------------------------------------------------------------
# 9 — Build annotations for pheatmap
# ---------------------------------------------------------------------
cat("\n[9] Building annotation_col for pheatmap...\n")

margin_bins <- cut(
    dominant_tbl_ord$margin,
    breaks = quantile(dominant_tbl_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

ann_col_ATAC <- data.frame(
    top_ct   = factor(dominant_tbl_ord$top_ct, levels = ct_levels),
    margin   = margin_bins,
    genotype = dominant_tbl_ord$genotype,
    row.names = dominant_tbl_ord$sample,
    stringsAsFactors = FALSE
)

cat("[9] Annotation table head:\n")
print(utils::head(ann_col_ATAC, 10))

cell_type_colors <- c(
    HSCMPP        = "#fb8072",
    GMP           = "#bebada",
    pDC           = "#ffd92f",
    EarlyLymphoid = "#f781bf",
    ProB          = "#ff33ff",
    PreB          = "#00e5c0",
    B             = "#00bfff"
)

margin_colors <- c(
    "Q1 (lowest)" = "#c7e9c0",
    "Q2"          = "#a1d99b",
    "Q3"          = "#74c476",
    "Q4 (highest)"= "#238b45"
)

genotype_colors <- c(
    TT = "#f65e0dff",
    TC = "#0c2e18ff",
    CC = "#d7a419ff"
)


# ---------------------------------------------------------------------
# 10 — Final pheatmap
# ---------------------------------------------------------------------
cat("\n[10] Drawing final ATAC dominance heatmap (column-scaled)...\n")

z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)

pheatmap::pheatmap(
    avg_z_by_ct_ord,
    color            = z_col_fun,
    cluster_rows     = FALSE,
    cluster_cols     = FALSE,
    show_rownames    = TRUE,
    show_colnames    = FALSE,
    annotation_col   = ann_col_ATAC,
    annotation_colors = list(
        top_ct   = cell_type_colors,
        margin   = margin_colors,
        genotype = genotype_colors
    ),
    border_color = NA,
    main = "ATAC module activity (Ilaria markers; column-scaled dominance)"
)

cat("\n[ATAC] DONE — no column should now be uniformly red; each sample\n")
cat("       is internally standardized across HSCMPP→B modules.\n")
cat("===============================================================\n\n")


```

### 14.1 Promoters only

```{r}
# =====================================================================
# ATAC — PROMOTER-ONLY ILARIA DOMINANCE MAP
#        (column-scaled module scores, Tian-style margins)
#
# Requires:
#   - counts   : matrix [peaks × samples] (ATAC peak-level counts)
#   - anno_df  : data.frame with peak_id, SYMBOL, annotation
#   - meta_sj  : data.frame with Sample, genotype
#
# Produces:
#   - prom_counts_all_gene          (promoter-only gene matrix)
#   - prom_avg_z_by_ct_ATAC_raw    (raw module scores)
#   - prom_avg_z_by_ct_ATAC        (column-scaled module scores)
#   - prom_dominant_tbl_ATAC       (winner + margin)
#   - prom_ann_col_ATAC            (pheatmap annotations)
#   - promoter-only dominance heatmap
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(readr)
    library(tibble)
    library(pheatmap)
    library(stringr)
})

cat("\n===============================================================\n")
cat("ATAC ILARIA PIPELINE — PROMOTER-ONLY, COLUMN-SCALED DOMINANCE\n")
cat("===============================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts")) {
    stop("[PROM-COL] ERROR: `counts` (peak × sample matrix) not found.")
}
if (!exists("anno_df")) {
    stop("[PROM-COL] ERROR: `anno_df` (ChIPseeker annotation) not found.")
}
if (!exists("meta_sj")) {
    stop("[PROM-COL] ERROR: `meta_sj` (Sample + genotype) not found.")
}

cat("[0] counts dim (peaks × samples): ",
    paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols): ",
    paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 1 — Load & clean Ilaria panel (if not already loaded)
# ---------------------------------------------------------------------
if (!exists("panel_long") || !exists("panel_genes") || !exists("ct_levels")) {
    
    cat("\n[1] Loading curated Ilaria panel (since objects not found)...\n")
    
    panel_path <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/clean_ilarias_700_genes.csv"
    cat("    • panel_path = ", panel_path, "\n", sep = "")
    
    df_raw <- readr::read_csv(panel_path, show_col_types = FALSE)
    
    df_updated <- df_raw %>%
        dplyr::mutate(
            dplyr::across(
                .cols = dplyr::everything(),
                .fns  = ~ {
                    x <- as.character(.)
                    x <- stringr::str_trim(x)
                    dplyr::na_if(x, "")
                }
            )
        )
    
    panel_long <- df_updated %>%
        tidyr::pivot_longer(
            cols      = dplyr::everything(),
            names_to  = "cell_type",
            values_to = "gene"
        ) %>%
        dplyr::filter(!is.na(gene), gene != "")
    
    panel_genes <- unique(panel_long$gene)
    ct_levels   <- colnames(df_updated)
    
    cat("[1] Panel loaded:\n")
    cat("    • unique marker genes : ", length(panel_genes), "\n", sep = "")
    cat("    • cell_type levels    : ", paste(ct_levels, collapse = " → "), "\n", sep = "")
}

# ---------------------------------------------------------------------
# 2 — Identify promoter peaks & build promoter-only gene matrix
# ---------------------------------------------------------------------
cat("\n[2] Identifying promoter peaks and aggregating to genes...\n")

prom_annot_summary <- anno_df %>%
    dplyr::count(annotation, sort = TRUE)
cat("[2] annotation (top 10):\n")
print(utils::head(prom_annot_summary, 10))

prom_anno_df <- anno_df %>%
    dplyr::filter(stringr::str_detect(annotation, "Promoter"))

cat("[2] prom_anno_df rows (Promoter*): ", nrow(prom_anno_df), "\n", sep = "")

if (nrow(prom_anno_df) == 0L) {
    stop("[2] ERROR: No promoter rows in anno_df$annotation.")
}

prom_gene_map <- prom_anno_df %>%
    dplyr::select(peak_id, SYMBOL) %>%
    dplyr::filter(!is.na(SYMBOL), SYMBOL != "") %>%
    dplyr::distinct()

cat("[2] prom_gene_map rows (promoter peaks with SYMBOL): ",
    nrow(prom_gene_map), "\n", sep = "")
cat("[2] unique SYMBOL in promoters: ",
    length(unique(prom_gene_map$SYMBOL)), "\n", sep = "")

prom_peaks_in_counts <- rownames(counts)
prom_common_peaks    <- intersect(prom_peaks_in_counts, prom_gene_map$peak_id)
cat("[2] promoter peaks overlapping counts rownames: ",
    length(prom_common_peaks), "\n", sep = "")

if (length(prom_common_peaks) == 0L) {
    stop("[2] ERROR: No overlap between promoter peak_ids and rownames(counts).")
}

prom_counts_df <- counts %>%
    as.data.frame()
prom_counts_df$peak_id <- rownames(prom_counts_df)

prom_counts_joined <- prom_gene_map %>%
    dplyr::filter(peak_id %in% prom_common_peaks) %>%
    dplyr::left_join(
        prom_counts_df,
        by = "peak_id",
        relationship = "many-to-many"
    )

cat("[2] rows after promoter join (promoter peak × sample): ",
    nrow(prom_counts_joined), "\n", sep = "")

prom_counts_gene_summarised <- prom_counts_joined %>%
    dplyr::select(-peak_id) %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::summarise(
        dplyr::across(.cols = dplyr::where(is.numeric), .fns = sum),
        .groups = "drop"
    )

cat("[2] promoter gene-level rows (SYMBOL): ",
    nrow(prom_counts_gene_summarised), "\n", sep = "")

prom_counts_all_gene <- prom_counts_gene_summarised %>%
    as.data.frame()
rownames(prom_counts_all_gene) <- prom_counts_all_gene$SYMBOL
prom_counts_all_gene$SYMBOL    <- NULL
prom_counts_all_gene <- as.matrix(prom_counts_all_gene)

cat("[2] prom_counts_all_gene dim (genes × samples): ",
    paste(dim(prom_counts_all_gene), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 3 — Subset promoter matrix to Ilaria genes & gene-level z-score
# ---------------------------------------------------------------------
cat("\n[3] Subsetting promoter matrix to Ilaria genes and z-scoring...\n")

prom_genes_in_atac <- intersect(rownames(prom_counts_all_gene), panel_genes)
cat("[3] genes in (promoters ∩ Ilaria): ",
    length(prom_genes_in_atac), "\n", sep = "")

if (length(prom_genes_in_atac) == 0L) {
    stop("[3] ERROR: No Ilaria genes among promoter-only genes.")
}

prom_atac_mat <- prom_counts_all_gene[prom_genes_in_atac, , drop = FALSE]
cat("[3] prom_atac_mat dim (Ilaria genes × samples): ",
    paste(dim(prom_atac_mat), collapse = " × "), "\n", sep = "")

prom_atac_z_gene <- t(scale(t(prom_atac_mat)))
prom_atac_z_gene[is.na(prom_atac_z_gene)] <- 0

cat("[3] Example promoter gene z-scores (5 genes × 5 samples):\n")
print(round(prom_atac_z_gene[1:5, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 4 — Expand to gene×cell-type rows
# ---------------------------------------------------------------------
cat("\n[4] Expanding promoter matrix to gene×cell-type rows...\n")

prom_panel_expanded <- panel_long %>%
    dplyr::filter(gene %in% prom_genes_in_atac) %>%
    dplyr::mutate(prom_row_id = paste(gene, cell_type, sep = "|"))

cat("[4] prom_panel_expanded rows: ",
    nrow(prom_panel_expanded), "\n", sep = "")
cat("[4] unique prom_row_id       : ",
    length(unique(prom_panel_expanded$prom_row_id)), "\n", sep = "")

prom_atac_expanded <- prom_panel_expanded %>%
    dplyr::select(prom_row_id, gene, cell_type) %>%
    dplyr::left_join(
        prom_atac_z_gene %>%
            as.data.frame() %>%
            tibble::rownames_to_column("gene"),
        by = "gene",
        relationship = "many-to-many"
    )

cat("[4] prom_atac_expanded rows after join: ",
    nrow(prom_atac_expanded), "\n", sep = "")

prom_mat_expanded <- prom_atac_expanded %>%
    dplyr::select(-gene, -cell_type) %>%
    tibble::column_to_rownames("prom_row_id") %>%
    as.matrix()

cat("[4] prom_mat_expanded dim (gene×ct rows × samples): ",
    paste(dim(prom_mat_expanded), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 5 — Raw promoter module matrix: prom_avg_z_by_ct_ATAC_raw
# ---------------------------------------------------------------------
cat("\n[5] Computing raw promoter module matrix (prom_avg_z_by_ct_ATAC_raw)...\n")

prom_ct_for_row <- prom_panel_expanded$cell_type
names(prom_ct_for_row) <- prom_panel_expanded$prom_row_id
prom_ct_for_row <- prom_ct_for_row[rownames(prom_mat_expanded)]

cat("[5] Alignment check — first 5 rows:\n")
print(
    head(
        cbind(
            prom_ct_for_row = prom_ct_for_row[1:5],
            rowname         = names(prom_ct_for_row)[1:5]
        )
    )
)

prom_avg_z_by_ct_ATAC_raw <- do.call(
    rbind,
    lapply(ct_levels, function(ct) {
        idx <- which(prom_ct_for_row == ct)
        if (length(idx) == 0L) {
            cat("[5] WARNING: no promoter markers for cell_type ", ct,
                "; filling with NA.\n", sep = "")
            return(rep(NA_real_, ncol(prom_mat_expanded)))
        } else {
            return(colMeans(prom_mat_expanded[idx, , drop = FALSE], na.rm = TRUE))
        }
    })
)
rownames(prom_avg_z_by_ct_ATAC_raw) <- ct_levels

cat("[5] prom_avg_z_by_ct_ATAC_raw dim (7 × samples): ",
    paste(dim(prom_avg_z_by_ct_ATAC_raw), collapse = " × "), "\n", sep = "")
cat("[5] Example RAW promoter module scores (first 5 samples):\n")
print(round(prom_avg_z_by_ct_ATAC_raw[, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 6 — Column-wise scaling across modules (CRUCIAL FIX)
# ---------------------------------------------------------------------
cat("\n[6] Column-wise scaling across the 7 lineages (promoter-only)...\n")
cat("    This enforces per-sample mean ~ 0 and sd ~ 1 across modules,\n")
cat("    preventing 'all-red' columns.\n\n")

prom_avg_z_by_ct_ATAC <- scale(prom_avg_z_by_ct_ATAC_raw,
                               center = TRUE, scale = TRUE)

col_means_mod_prom <- apply(prom_avg_z_by_ct_ATAC, 2, mean)
col_sds_mod_prom   <- apply(prom_avg_z_by_ct_ATAC, 2, sd)

cat("[6] Per-sample mean(z) across 7 lineages (after scaling):\n")
print(summary(col_means_mod_prom))
cat("[6] Per-sample sd(z) across 7 lineages (after scaling):\n")
print(summary(col_sds_mod_prom))

all_pos_prom <- apply(prom_avg_z_by_ct_ATAC, 2, function(v) all(v > 0))
cat("[6] Samples with ALL promoter module scores > 0 (should be 0): ",
    sum(all_pos_prom), "\n", sep = "")

cat("[6] Example SCALED promoter module scores (first 5 samples):\n")
print(round(prom_avg_z_by_ct_ATAC[, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 7 — Dominant lineage + margins (promoter-only, scaled)
# ---------------------------------------------------------------------
cat("\n[7] Computing dominant lineage & margins (promoter-only, scaled)...\n")

prom_top_idx    <- apply(prom_avg_z_by_ct_ATAC, 2, which.max)
prom_second_idx <- apply(prom_avg_z_by_ct_ATAC, 2, function(v) order(v, decreasing = TRUE)[2])

prom_dominant_tbl_ATAC <- tibble::tibble(
    sample       = colnames(prom_avg_z_by_ct_ATAC),
    top_ct       = ct_levels[prom_top_idx],
    top_score    = prom_avg_z_by_ct_ATAC[cbind(prom_top_idx, seq_along(prom_top_idx))],
    second_ct    = ct_levels[prom_second_idx],
    second_score = prom_avg_z_by_ct_ATAC[cbind(prom_second_idx, seq_along(prom_second_idx))]
) %>%
    dplyr::mutate(
        margin = top_score - second_score
    ) %>%
    dplyr::left_join(
        meta_sj %>% dplyr::select(Sample, genotype),
        by = c("sample" = "Sample")
    )

cat("[7] First 10 promoter dominance calls:\n")
print(utils::head(prom_dominant_tbl_ATAC, 10))

cat("\n[7] Frequency of promoter-based top_ct assignments:\n")
print(sort(table(prom_dominant_tbl_ATAC$top_ct), decreasing = TRUE))

cat("\n[7] Margin summary (promoter-only, scaled):\n")
print(summary(prom_dominant_tbl_ATAC$margin))

# ---------------------------------------------------------------------
# 8 — Order samples: top_ct → margin → top_score
# ---------------------------------------------------------------------
cat("\n[8] Ordering samples (top_ct → margin → top_score) [promoters]...\n")

prom_col_order <- order(
    factor(prom_dominant_tbl_ATAC$top_ct, levels = ct_levels),
    -prom_dominant_tbl_ATAC$margin,
    -prom_dominant_tbl_ATAC$top_score
)

prom_avg_z_by_ct_ord  <- prom_avg_z_by_ct_ATAC[, prom_col_order, drop = FALSE]
prom_dominant_tbl_ord <- prom_dominant_tbl_ATAC[prom_col_order, ]

cat("[8] prom_avg_z_by_ct_ord dim: ",
    paste(dim(prom_avg_z_by_ct_ord), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 9 — Build annotations for pheatmap
# ---------------------------------------------------------------------
cat("\n[9] Building prom_ann_col_ATAC for pheatmap...\n")

prom_margin_bins <- cut(
    prom_dominant_tbl_ord$margin,
    breaks = quantile(prom_dominant_tbl_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

prom_ann_col_ATAC <- data.frame(
    top_ct   = factor(prom_dominant_tbl_ord$top_ct, levels = ct_levels),
    margin   = prom_margin_bins,
    genotype = prom_dominant_tbl_ord$genotype,
    row.names = prom_dominant_tbl_ord$sample,
    stringsAsFactors = FALSE
)

cat("[9] prom_ann_col_ATAC head:\n")
print(utils::head(prom_ann_col_ATAC, 10))

# Reuse palettes from main pipeline, or define if missing
if (!exists("cell_type_colors")) {
    cell_type_colors <- c(
        HSCMPP        = "#fb8072",
        GMP           = "#bebada",
        pDC           = "#ffd92f",
        EarlyLymphoid = "#f781bf",
        ProB          = "#ff33ff",
        PreB          = "#00e5c0",
        B             = "#00bfff"
    )
}
if (!exists("margin_colors")) {
    margin_colors <- c(
        "Q1 (lowest)" = "#c7e9c0",
        "Q2"          = "#a1d99b",
        "Q3"          = "#74c476",
        "Q4 (highest)"= "#238b45"
    )
}
if (!exists("genotype_colors")) {
    genotype_colors <- c(
        TT = "#f65e0dff",
        TC = "#0c2e18ff",
        CC = "#d7a419ff"
    )
}

# ---------------------------------------------------------------------
# 10 — Final promoter-only dominance heatmap
# ---------------------------------------------------------------------
cat("\n[10] Drawing promoter-only ATAC dominance heatmap (column-scaled)...\n")

prom_z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)

pheatmap::pheatmap(
    prom_avg_z_by_ct_ord,
    color            = prom_z_col_fun,
    cluster_rows     = FALSE,
    cluster_cols     = FALSE,
    show_rownames    = TRUE,
    show_colnames    = FALSE,
    annotation_col   = prom_ann_col_ATAC,
    annotation_colors = list(
        top_ct   = cell_type_colors,
        margin   = margin_colors,
        genotype = genotype_colors
    ),
    border_color = NA,
    main = "ATAC module activity (PROMOTER PEAKS ONLY; column-scaled dominance)"
)

cat("\n[PROM-COL] DONE — promoter-only modules are now internally\n")
cat("           standardized per sample; no column should be uniformly red.\n")
cat("===============================================================\n\n")

```

### 14.2 Enhancers only
```{r}
# =====================================================================
# ATAC — ENHANCER-ONLY ILARIA DOMINANCE MAP
#        (column-scaled module scores, Tian-style margins)
#
# Enhancers = all non-promoter peaks with a SYMBOL in `anno_df`,
#             aggregated to genes, then to lineage modules using
#             Ilaria marker lists.
#
# Requires:
#   - counts   : matrix [peaks × samples] (ATAC peak-level counts)
#   - anno_df  : data.frame with peak_id, SYMBOL, annotation
#   - meta_sj  : data.frame with Sample, genotype
#   - panel_long / panel_genes / ct_levels
#
# Produces:
#   - enh_counts_all_gene          (enhancer-only gene matrix)
#   - enh_avg_z_by_ct_ATAC_raw    (raw module scores)
#   - enh_avg_z_by_ct_ATAC        (column-scaled module scores)
#   - enh_dominant_tbl_ATAC       (winner + margin)
#   - enh_ann_col_ATAC            (pheatmap annotations)
#   - enhancer-only dominance heatmap
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(readr)
    library(tibble)
    library(pheatmap)
    library(stringr)
})

cat("\n===============================================================\n")
cat("ATAC ILARIA PIPELINE — ENHANCER-ONLY, COLUMN-SCALED DOMINANCE\n")
cat("===============================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts")) {
    stop("[ENH-COL] ERROR: `counts` (peak × sample matrix) not found.")
}
if (!exists("anno_df")) {
    stop("[ENH-COL] ERROR: `anno_df` (ChIPseeker annotation) not found.")
}
if (!exists("meta_sj")) {
    stop("[ENH-COL] ERROR: `meta_sj` (Sample + genotype) not found.")
}

cat("[0] counts dim (peaks × samples): ",
    paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols): ",
    paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 1 — Load & clean Ilaria panel (if not already loaded)
# ---------------------------------------------------------------------
if (!exists("panel_long") || !exists("panel_genes") || !exists("ct_levels")) {
    
    cat("\n[1] Loading curated Ilaria panel (since objects not found)...\n")
    
    panel_path <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/clean_ilarias_700_genes.csv"
    cat("    • panel_path = ", panel_path, "\n", sep = "")
    
    df_raw <- readr::read_csv(panel_path, show_col_types = FALSE)
    
    df_updated <- df_raw %>%
        dplyr::mutate(
            dplyr::across(
                .cols = dplyr::everything(),
                .fns  = ~ {
                    x <- as.character(.)
                    x <- stringr::str_trim(x)
                    dplyr::na_if(x, "")
                }
            )
        )
    
    panel_long <- df_updated %>%
        tidyr::pivot_longer(
            cols      = dplyr::everything(),
            names_to  = "cell_type",
            values_to = "gene"
        ) %>%
        dplyr::filter(!is.na(gene), gene != "")
    
    panel_genes <- unique(panel_long$gene)
    ct_levels   <- colnames(df_raw)
    
    cat("[1] Panel loaded:\n")
    cat("    • unique marker genes : ", length(panel_genes), "\n", sep = "")
    cat("    • cell_type levels    : ", paste(ct_levels, collapse = " → "), "\n", sep = "")
}

# ---------------------------------------------------------------------
# 2 — Identify enhancer (non-promoter) peaks & build gene matrix
# ---------------------------------------------------------------------
cat("\n[2] Identifying NON-PROMOTER peaks (enhancer-like) and aggregating to genes...\n")

enh_annot_summary <- anno_df %>%
    dplyr::count(annotation, sort = TRUE)
cat("[2] annotation (top 10):\n")
print(utils::head(enh_annot_summary, 10))

# "Enhancers" here = any annotation NOT containing "Promoter"
enh_anno_df <- anno_df %>%
    dplyr::filter(!stringr::str_detect(annotation, "Promoter"))

cat("[2] enh_anno_df rows (NON-Promoter): ", nrow(enh_anno_df), "\n", sep = "")

if (nrow(enh_anno_df) == 0L) {
    stop("[2] ERROR: No non-promoter rows in anno_df$annotation.")
}

enh_gene_map <- enh_anno_df %>%
    dplyr::select(peak_id, SYMBOL) %>%
    dplyr::filter(!is.na(SYMBOL), SYMBOL != "") %>%
    dplyr::distinct()

cat("[2] enh_gene_map rows (non-promoter peaks with SYMBOL): ",
    nrow(enh_gene_map), "\n", sep = "")
cat("[2] unique SYMBOL in enhancers: ",
    length(unique(enh_gene_map$SYMBOL)), "\n", sep = "")

enh_peaks_in_counts <- rownames(counts)
enh_common_peaks    <- intersect(enh_peaks_in_counts, enh_gene_map$peak_id)
cat("[2] non-promoter peaks overlapping counts rownames: ",
    length(enh_common_peaks), "\n", sep = "")

if (length(enh_common_peaks) == 0L) {
    stop("[2] ERROR: No overlap between non-promoter peak_ids and rownames(counts).")
}

enh_counts_df <- counts %>%
    as.data.frame()
enh_counts_df$peak_id <- rownames(enh_counts_df)

enh_counts_joined <- enh_gene_map %>%
    dplyr::filter(peak_id %in% enh_common_peaks) %>%
    dplyr::left_join(
        enh_counts_df,
        by = "peak_id",
        relationship = "many-to-many"
    )

cat("[2] rows after non-promoter join (enhancer peak × sample): ",
    nrow(enh_counts_joined), "\n", sep = "")

enh_counts_gene_summarised <- enh_counts_joined %>%
    dplyr::select(-peak_id) %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::summarise(
        dplyr::across(.cols = dplyr::where(is.numeric), .fns = sum),
        .groups = "drop"
    )

cat("[2] enhancer gene-level rows (SYMBOL): ",
    nrow(enh_counts_gene_summarised), "\n", sep = "")

enh_counts_all_gene <- enh_counts_gene_summarised %>%
    as.data.frame()
rownames(enh_counts_all_gene) <- enh_counts_all_gene$SYMBOL
enh_counts_all_gene$SYMBOL    <- NULL
enh_counts_all_gene <- as.matrix(enh_counts_all_gene)

cat("[2] enh_counts_all_gene dim (genes × samples): ",
    paste(dim(enh_counts_all_gene), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 3 — Subset enhancer matrix to Ilaria genes & gene-level z-score
# ---------------------------------------------------------------------
cat("\n[3] Subsetting enhancer matrix to Ilaria genes and z-scoring...\n")

enh_genes_in_atac <- intersect(rownames(enh_counts_all_gene), panel_genes)
cat("[3] genes in (enhancers ∩ Ilaria): ",
    length(enh_genes_in_atac), "\n", sep = "")

if (length(enh_genes_in_atac) == 0L) {
    stop("[3] ERROR: No Ilaria genes among enhancer-only genes.")
}

enh_atac_mat <- enh_counts_all_gene[enh_genes_in_atac, , drop = FALSE]
cat("[3] enh_atac_mat dim (Ilaria genes × samples): ",
    paste(dim(enh_atac_mat), collapse = " × "), "\n", sep = "")

enh_atac_z_gene <- t(scale(t(enh_atac_mat)))
enh_atac_z_gene[is.na(enh_atac_z_gene)] <- 0

cat("[3] Example enhancer gene z-scores (5 genes × 5 samples):\n")
print(round(enh_atac_z_gene[1:5, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 4 — Expand to gene×cell-type rows
# ---------------------------------------------------------------------
cat("\n[4] Expanding enhancer matrix to gene×cell-type rows...\n")

enh_panel_expanded <- panel_long %>%
    dplyr::filter(gene %in% enh_genes_in_atac) %>%
    dplyr::mutate(enh_row_id = paste(gene, cell_type, sep = "|"))

cat("[4] enh_panel_expanded rows: ",
    nrow(enh_panel_expanded), "\n", sep = "")
cat("[4] unique enh_row_id       : ",
    length(unique(enh_panel_expanded$enh_row_id)), "\n", sep = "")

enh_atac_expanded <- enh_panel_expanded %>%
    dplyr::select(enh_row_id, gene, cell_type) %>%
    dplyr::left_join(
        enh_atac_z_gene %>%
            as.data.frame() %>%
            tibble::rownames_to_column("gene"),
        by = "gene",
        relationship = "many-to-many"
    )

cat("[4] enh_atac_expanded rows after join: ",
    nrow(enh_atac_expanded), "\n", sep = "")

enh_mat_expanded <- enh_atac_expanded %>%
    dplyr::select(-gene, -cell_type) %>%
    tibble::column_to_rownames("enh_row_id") %>%
    as.matrix()

cat("[4] enh_mat_expanded dim (gene×ct rows × samples): ",
    paste(dim(enh_mat_expanded), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 5 — Raw enhancer module matrix: enh_avg_z_by_ct_ATAC_raw
# ---------------------------------------------------------------------
cat("\n[5] Computing raw enhancer module matrix (enh_avg_z_by_ct_ATAC_raw)...\n")

enh_ct_for_row <- enh_panel_expanded$cell_type
names(enh_ct_for_row) <- enh_panel_expanded$enh_row_id
enh_ct_for_row <- enh_ct_for_row[rownames(enh_mat_expanded)]

cat("[5] Alignment check — first 5 rows:\n")
print(
    head(
        cbind(
            enh_ct_for_row = enh_ct_for_row[1:5],
            rowname        = names(enh_ct_for_row)[1:5]
        )
    )
)

enh_avg_z_by_ct_ATAC_raw <- do.call(
    rbind,
    lapply(ct_levels, function(ct) {
        idx <- which(enh_ct_for_row == ct)
        if (length(idx) == 0L) {
            cat("[5] WARNING: no enhancer markers for cell_type ", ct,
                "; filling with NA.\n", sep = "")
            return(rep(NA_real_, ncol(enh_mat_expanded)))
        } else {
            return(colMeans(enh_mat_expanded[idx, , drop = FALSE], na.rm = TRUE))
        }
    })
)
rownames(enh_avg_z_by_ct_ATAC_raw) <- ct_levels

cat("[5] enh_avg_z_by_ct_ATAC_raw dim (7 × samples): ",
    paste(dim(enh_avg_z_by_ct_ATAC_raw), collapse = " × "), "\n", sep = "")
cat("[5] Example RAW enhancer module scores (first 5 samples):\n")
print(round(enh_avg_z_by_ct_ATAC_raw[, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 6 — Column-wise scaling across modules (CRUCIAL)
# ---------------------------------------------------------------------
cat("\n[6] Column-wise scaling across the 7 lineages (enhancer-only)...\n")
cat("    This enforces per-sample mean ~ 0 and sd ~ 1 across modules,\n")
cat("    preventing 'all-red' columns.\n\n")

enh_avg_z_by_ct_ATAC <- scale(enh_avg_z_by_ct_ATAC_raw,
                              center = TRUE, scale = TRUE)

col_means_mod_enh <- apply(enh_avg_z_by_ct_ATAC, 2, mean)
col_sds_mod_enh   <- apply(enh_avg_z_by_ct_ATAC, 2, sd)

cat("[6] Per-sample mean(z) across 7 lineages (after scaling):\n")
print(summary(col_means_mod_enh))
cat("[6] Per-sample sd(z) across 7 lineages (after scaling):\n")
print(summary(col_sds_mod_enh))

all_pos_enh <- apply(enh_avg_z_by_ct_ATAC, 2, function(v) all(v > 0))
cat("[6] Samples with ALL enhancer module scores > 0 (should be 0): ",
    sum(all_pos_enh), "\n", sep = "")

cat("[6] Example SCALED enhancer module scores (first 5 samples):\n")
print(round(enh_avg_z_by_ct_ATAC[, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 7 — Dominant lineage + margins (enhancer-only, scaled)
# ---------------------------------------------------------------------
cat("\n[7] Computing dominant lineage & margins (enhancer-only, scaled)...\n")

enh_top_idx    <- apply(enh_avg_z_by_ct_ATAC, 2, which.max)
enh_second_idx <- apply(enh_avg_z_by_ct_ATAC, 2, function(v) order(v, decreasing = TRUE)[2])

enh_dominant_tbl_ATAC <- tibble::tibble(
    sample       = colnames(enh_avg_z_by_ct_ATAC),
    top_ct       = ct_levels[enh_top_idx],
    top_score    = enh_avg_z_by_ct_ATAC[cbind(enh_top_idx, seq_along(enh_top_idx))],
    second_ct    = ct_levels[enh_second_idx],
    second_score = enh_avg_z_by_ct_ATAC[cbind(enh_second_idx, seq_along(enh_second_idx))]
) %>%
    dplyr::mutate(
        margin = top_score - second_score
    ) %>%
    dplyr::left_join(
        meta_sj %>% dplyr::select(Sample, genotype),
        by = c("sample" = "Sample")
    )

cat("[7] First 10 enhancer dominance calls:\n")
print(utils::head(enh_dominant_tbl_ATAC, 10))

cat("\n[7] Frequency of enhancer-based top_ct assignments:\n")
print(sort(table(enh_dominant_tbl_ATAC$top_ct), decreasing = TRUE))

cat("\n[7] Margin summary (enhancer-only, scaled):\n")
print(summary(enh_dominant_tbl_ATAC$margin))

# ---------------------------------------------------------------------
# 8 — Order samples: top_ct → margin → top_score
# ---------------------------------------------------------------------
cat("\n[8] Ordering samples (top_ct → margin → top_score) [enhancers]...\n")

enh_col_order <- order(
    factor(enh_dominant_tbl_ATAC$top_ct, levels = ct_levels),
    -enh_dominant_tbl_ATAC$margin,
    -enh_dominant_tbl_ATAC$top_score
)

enh_avg_z_by_ct_ord  <- enh_avg_z_by_ct_ATAC[, enh_col_order, drop = FALSE]
enh_dominant_tbl_ord <- enh_dominant_tbl_ATAC[enh_col_order, ]

cat("[8] enh_avg_z_by_ct_ord dim: ",
    paste(dim(enh_avg_z_by_ct_ord), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 9 — Build annotations for pheatmap
# ---------------------------------------------------------------------
cat("\n[9] Building enh_ann_col_ATAC for pheatmap...\n")

enh_margin_bins <- cut(
    enh_dominant_tbl_ord$margin,
    breaks = quantile(enh_dominant_tbl_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

enh_ann_col_ATAC <- data.frame(
    top_ct   = factor(enh_dominant_tbl_ord$top_ct, levels = ct_levels),
    margin   = enh_margin_bins,
    genotype = enh_dominant_tbl_ord$genotype,
    row.names = enh_dominant_tbl_ord$sample,
    stringsAsFactors = FALSE
)

cat("[9] enh_ann_col_ATAC head:\n")
print(utils::head(enh_ann_col_ATAC, 10))

# Reuse palettes from main pipeline, or define if missing
if (!exists("cell_type_colors")) {
    cell_type_colors <- c(
        HSCMPP        = "#fb8072",
        GMP           = "#bebada",
        pDC           = "#ffd92f",
        EarlyLymphoid = "#f781bf",
        ProB          = "#ff33ff",
        PreB          = "#00e5c0",
        B             = "#00bfff"
    )
}
if (!exists("margin_colors")) {
    margin_colors <- c(
        "Q1 (lowest)" = "#c7e9c0",
        "Q2"          = "#a1d99b",
        "Q3"          = "#74c476",
        "Q4 (highest)"= "#238b45"
    )
}
if (!exists("genotype_colors")) {
    genotype_colors <- c(
        TT = "#f65e0dff",
        TC = "#0c2e18ff",
        CC = "#d7a419ff"
    )
}

# ---------------------------------------------------------------------
# 10 — Final enhancer-only dominance heatmap
# ---------------------------------------------------------------------
cat("\n[10] Drawing enhancer-only ATAC dominance heatmap (column-scaled)...\n")

enh_z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)

pheatmap::pheatmap(
    enh_avg_z_by_ct_ord,
    color            = enh_z_col_fun,
    cluster_rows     = FALSE,
    cluster_cols     = FALSE,
    show_rownames    = TRUE,
    show_colnames    = FALSE,
    annotation_col   = enh_ann_col_ATAC,
    annotation_colors = list(
        top_ct   = cell_type_colors,
        margin   = margin_colors,
        genotype = genotype_colors
    ),
    border_color = NA,
    main = "ATAC module activity (ENHANCER PEAKS ONLY; column-scaled dominance)"
)

cat("\n[ENH-COL] DONE — enhancer-only modules are now internally\n")
cat("           standardized per sample; no column should be uniformly red.\n")
cat("===============================================================\n\n")
```

## 15 Savics

```{r}
# =====================================================================
# ATAC — Savics S3 PEAK-BASED dominance map WITH LIFTOVER (hg19 → hg38)
#        and overlap to SJ156 peaks (no sample should be "red for all")
# =====================================================================
# Requires in the environment:
#   - counts   : matrix [peaks × samples], rownames = peak_id ("peak_1", ...)
#   - anno_df  : data.frame with at least:
#                seqnames, start, end, peak_id (hg38 coordinates)
#   - meta_sj  : data.frame with columns Sample, genotype
#   - Savics_S3.xlsx : hg19 peak markers with chr, start, stop, Defining_Progenitor
#   - hg19ToHg38.over.chain.gz : UCSC chain file path (already in this wd)
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(readxl)
    library(tibble)
    library(pheatmap)
    library(stringr)
    library(GenomicRanges)
    library(rtracklayer)
    library(GenomeInfoDb)
    library(R.utils)
})

cat("\n===============================================================\n")
cat("ATAC SAVICS PIPELINE — LIFTOVER + OVERLAP + COLUMN-SCALED MODULES\n")
cat("===============================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts")) {
    stop("[0] ERROR: `counts` (peak × sample matrix) not found.")
}
if (!exists("meta_sj")) {
    stop("[0] ERROR: `meta_sj` (Sample + genotype) not found.")
}
if (!exists("anno_df")) {
    stop("[0] ERROR: `anno_df` (peak annotation with coordinates) not found.")
}

cat("[0] counts dim (peaks × samples): ",
    paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols): ",
    paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 0b — Chain file (hg19 → hg38) — gunzip once, then import .chain
# ---------------------------------------------------------------------
chain_gz  <- "hg19ToHg38.over.chain.gz"
chain_txt <- "hg19ToHg38.over.chain"

if (!file.exists(chain_gz)) {
    stop("[0b] ERROR: Chain .gz not found at: ",
         normalizePath(chain_gz, mustWork = FALSE))
}

if (!file.exists(chain_txt)) {
    cat("[0b] Unzipping chain file: ", chain_gz, " → ", chain_txt, "\n", sep = "")
    R.utils::gunzip(chain_gz, destname = chain_txt,
                    overwrite = TRUE, remove = FALSE)
}

first_line <- readLines(chain_txt, n = 1, warn = FALSE)
if (!startsWith(first_line, "chain ")) {
    stop("[0b] ERROR: Unzipped file does not start with 'chain'. Header:\n  ",
         first_line)
}

hg19_to_hg38_chain <- rtracklayer::import.chain(chain_txt)
cat("[0b] Loaded chain file: ", chain_txt, "\n", sep = "")

# quick tiny sanity test (optional, but nice)
test_hg19   <- GenomicRanges::GRanges("chr1", IRanges::IRanges(10000, 10050))
lifted_test <- rtracklayer::liftOver(test_hg19, hg19_to_hg38_chain)
cat("[0b] Test liftover returned ",
    lengths(lifted_test), " hg38 ranges for chr1:10000-10050\n", sep = "")

# ---------------------------------------------------------------------
# 1 — Load Savics S3 hg19 peaks
# ---------------------------------------------------------------------
savics_path <- "Savics_S3.xlsx"

cat("\n[1] Loading Savics peak markers (hg19) from:\n    ", savics_path, "\n", sep = "")
savics_raw <- readxl::read_xlsx(savics_path)

cat("[1] savics_raw dim (rows × cols): ",
    paste(dim(savics_raw), collapse = " × "), "\n", sep = "")
cat("[1] Columns:\n")
print(colnames(savics_raw))

savics_hg19_df <- savics_raw %>%
    as.data.frame() %>%
    dplyr::mutate(
        chr                 = as.character(chr),
        start               = as.integer(start),
        stop                = as.integer(stop),
        Defining_Progenitor = stringr::str_trim(as.character(Defining_Progenitor))
    ) %>%
    dplyr::distinct(chr, start, stop, Defining_Progenitor, .keep_all = TRUE)

cat("\n[1] After cleaning (hg19 coord space):\n")
cat("    • rows (peak × Defining_Progenitor string): ",
    nrow(savics_hg19_df), "\n", sep = "")
cat("    • unique coord triplets (chr,start,stop)  : ",
    nrow(dplyr::distinct(savics_hg19_df, chr, start, stop)), "\n", sep = "")

cat("\n[1] Example hg19 Savics rows:\n")
print(utils::head(savics_hg19_df, 10))

# how many progenitors per row?
savics_hg19_df <- savics_hg19_df %>%
    dplyr::mutate(
        n_progenitors = lengths(
            stringr::str_split(Defining_Progenitor, pattern = "\\s*,\\s*")
        )
    )

cat("\n[1] Distribution of n_progenitors per row (Savics table):\n")
print(
    savics_hg19_df %>%
        dplyr::count(n_progenitors, name = "n_rows") %>%
        dplyr::arrange(n_progenitors)
)

# ---------------------------------------------------------------------
# 1c — Build GRanges for Savics hg19 peaks & liftover to hg38
# ---------------------------------------------------------------------
cat("\n[1c] Building GRanges (hg19) and running liftOver → hg38...\n")

savics_gr_hg19 <- GenomicRanges::GRanges(
    seqnames = savics_hg19_df$chr,
    ranges   = IRanges::IRanges(start = savics_hg19_df$start,
                                end   = savics_hg19_df$stop)
)

savics_gr_hg38_list <- rtracklayer::liftOver(savics_gr_hg19, hg19_to_hg38_chain)
orig_idx             <- rep(seq_along(savics_gr_hg19), lengths(savics_gr_hg38_list))
savics_gr_hg38       <- unlist(savics_gr_hg38_list)

cat("[1c] LiftOver result:\n")
cat("    • original hg19 peaks      : ", length(savics_gr_hg19), "\n", sep = "")
cat("    • hg38 ranges after LO     : ", length(savics_gr_hg38), "\n", sep = "")

mapped_mask <- lengths(savics_gr_hg38_list) > 0
n_mapped    <- sum(mapped_mask)
n_unmapped  <- sum(!mapped_mask)

cat("    • hg19 peaks with >=1 hg38 : ", n_mapped, "\n", sep = "")
cat("    • hg19 peaks with 0 hg38   : ", n_unmapped, "\n", sep = "")

if (n_mapped == 0L) {
    stop("[1c] ERROR: liftover produced no hg38 mappings. Check chain/assembly.")
}

savics_hg38_df <- savics_hg19_df[orig_idx, , drop = FALSE] %>%
    dplyr::mutate(
        chr_hg38   = as.character(GenomeInfoDb::seqnames(savics_gr_hg38)),
        start_hg38 = as.integer(GenomicRanges::start(savics_gr_hg38)),
        stop_hg38  = as.integer(GenomicRanges::end(savics_gr_hg38))
    )

cat("\n[1c] savics_hg38_df dim (post-liftover, one row per hg38 interval): ",
    paste(dim(savics_hg38_df), collapse = " × "), "\n", sep = "")
cat("[1c] Example hg38 Savics rows:\n")
print(utils::head(savics_hg38_df, 10))

# ---------------------------------------------------------------------
# 2 — Build SJ156 peak GRanges (hg38) & find overlaps
# ---------------------------------------------------------------------
cat("\n[2] Building SJ156 peak GRanges (hg38) from anno_df and finding overlaps...\n")

sj156_gr <- GenomicRanges::GRanges(
    seqnames = as.character(anno_df$seqnames),
    ranges   = IRanges::IRanges(start = as.integer(anno_df$start),
                                end   = as.integer(anno_df$end)),
    peak_id  = anno_df$peak_id
)

savics_gr_hg38_clean <- GenomicRanges::GRanges(
    seqnames = savics_hg38_df$chr_hg38,
    ranges   = IRanges::IRanges(start = savics_hg38_df$start_hg38,
                                end   = savics_hg38_df$stop_hg38)
)

hits <- GenomicRanges::findOverlaps(
    query  = savics_gr_hg38_clean,
    subject = sj156_gr,
    ignore.strand = TRUE
)

cat("[2] Overlaps (Savics hg38 vs SJ156 peaks):\n")
cat("    • number of overlaps (pairs Savics×SJ156) : ", length(hits), "\n", sep = "")

if (length(hits) == 0L) {
    stop("[2] ERROR: No overlaps between lifted Savics peaks and SJ156 peaks.\n       Check assemblies or coordinate consistency.")
}

savics_overlap_df <- tibble::tibble(
    savics_idx = S4Vectors::queryHits(hits),
    sj156_idx  = S4Vectors::subjectHits(hits)
) %>%
    dplyr::mutate(
        Defining_Progenitor = savics_hg38_df$Defining_Progenitor[savics_idx],
        peak_id             = as.character(S4Vectors::mcols(sj156_gr)$peak_id[sj156_idx])
    ) %>%
    dplyr::select(peak_id, Defining_Progenitor) %>%
    dplyr::distinct()

cat("\n[2] savics_overlap_df dim (SJ156 peak_id × progenitor pairs): ",
    paste(dim(savics_overlap_df), collapse = " × "), "\n", sep = "")
cat("[2] Example overlap-derived mappings:\n")
print(utils::head(savics_overlap_df, 10))

savics_ct_levels <- c("HSC", "MPP", "LMPP", "CLP", "PreProB", "ProB", "CD19CD20")
cat("\n[2] Progenitor levels (developmental order):\n")
print(savics_ct_levels)

# ---------------------------------------------------------------------
# 3 — Restrict to peaks that exist in counts & prepare long format
# ---------------------------------------------------------------------
cat("\n[3] Restricting mappings to peak_id present in counts...\n")

peaks_in_counts <- intersect(savics_overlap_df$peak_id, rownames(counts))

cat("[3] Peak overlap with counts:\n")
cat("    • unique mapped SJ156 peak_id (from overlaps) : ",
    length(unique(savics_overlap_df$peak_id)), "\n", sep = "")
cat("    • peaks_in_counts (overlap ∩ counts rownames) : ",
    length(peaks_in_counts), "\n", sep = "")

if (length(peaks_in_counts) == 0L) {
    stop("[3] ERROR: No overlapping peak_id found in counts; check peak_id consistency.")
}

savics_long_use <- savics_overlap_df %>%
    dplyr::filter(peak_id %in% peaks_in_counts)

cat("[3] savics_long_use dim (post-counts restriction): ",
    paste(dim(savics_long_use), collapse = " × "), "\n", sep = "")
cat("[3] Example savics_long_use rows:\n")
print(utils::head(savics_long_use, 10))

# ---------------------------------------------------------------------
# 4 — Subset counts to Savics peaks & per-peak z-scores
# ---------------------------------------------------------------------
cat("\n[4] Subsetting counts to Savics-covered peaks and z-scoring each peak...\n")

savics_counts_mat <- counts[peaks_in_counts, , drop = FALSE]

cat("[4] savics_counts_mat dim (Savics peaks × samples): ",
    paste(dim(savics_counts_mat), collapse = " × "), "\n", sep = "")

savics_z_peak <- t(scale(t(savics_counts_mat)))
savics_z_peak[is.na(savics_z_peak)] <- 0

cat("[4] Example peak z-scores (5 peaks × 5 samples):\n")
print(round(savics_z_peak[1:5, 1:5, drop = FALSE], 3))

col_means_z <- apply(savics_z_peak, 2, mean)
col_sds_z   <- apply(savics_z_peak, 2, sd)

cat("[4] Per-sample mean(z) across Savics peaks:\n")
print(summary(col_means_z))
cat("[4] Per-sample sd(z) across Savics peaks:\n")
print(summary(col_sds_z))

# ---------------------------------------------------------------------
# 5 — Expand to peak×progenitor rows (shared peaks duplicated)
# ---------------------------------------------------------------------
cat("\n[5] Building peak×progenitor matrix (shared peaks contribute to all modules)...\n")

savics_expanded <- savics_long_use %>%
    dplyr::mutate(
        row_id = paste(peak_id, Defining_Progenitor, sep = "|")
    ) %>%
    dplyr::left_join(
        savics_z_peak %>%
            as.data.frame() %>%
            tibble::rownames_to_column("peak_id"),
        by = "peak_id"
    )

cat("[5] savics_expanded rows (peak×progenitor): ",
    nrow(savics_expanded), "\n", sep = "")

savics_mat_expanded <- savics_expanded %>%
    dplyr::select(-peak_id, -Defining_Progenitor) %>%
    tibble::column_to_rownames("row_id") %>%
    as.matrix()

cat("[5] savics_mat_expanded dim (peak×ct rows × samples): ",
    paste(dim(savics_mat_expanded), collapse = " × "), "\n", sep = "")

savics_ct_for_row <- savics_expanded$Defining_Progenitor
names(savics_ct_for_row) <- rownames(savics_mat_expanded)

cat("[5] Alignment check — first 5 rows:\n")
print(
    head(
        cbind(
            savics_ct_for_row = savics_ct_for_row[1:5],
            rowname           = names(savics_ct_for_row)[1:5]
        )
    )
)

# ---------------------------------------------------------------------
# 6 — Raw Savics module matrix: savics_avg_z_by_ct_ATAC_raw
# ---------------------------------------------------------------------
cat("\n[6] Computing raw Savics module activity (savics_avg_z_by_ct_ATAC_raw)...\n")

savics_avg_z_by_ct_ATAC_raw <- do.call(
    rbind,
    lapply(savics_ct_levels, function(ct) {
        idx <- which(savics_ct_for_row == ct)
        if (length(idx) == 0L) {
            cat("[6] WARNING: no Savics peaks for progenitor ", ct,
                "; filling with NA.\n", sep = "")
            return(rep(NA_real_, ncol(savics_mat_expanded)))
        } else {
            return(colMeans(savics_mat_expanded[idx, , drop = FALSE], na.rm = TRUE))
        }
    })
)
rownames(savics_avg_z_by_ct_ATAC_raw) <- savics_ct_levels

cat("[6] savics_avg_z_by_ct_ATAC_raw dim (7 × samples): ",
    paste(dim(savics_avg_z_by_ct_ATAC_raw), collapse = " × "), "\n", sep = "")
cat("[6] Example raw Savics module scores (first 5 samples):\n")
print(round(savics_avg_z_by_ct_ATAC_raw[, 1:5, drop = FALSE], 3))

cat("\n[6] Range of raw module scores:\n")
print(summary(as.vector(savics_avg_z_by_ct_ATAC_raw)))

# ---------------------------------------------------------------------
# 7 — Column-wise scaling (per-sample z across progenitors)
# ---------------------------------------------------------------------
cat("\n[7] Column-wise scaling: z-score Savics modules WITHIN each sample...\n")
cat("    (Per-sample mean ~ 0 and sd ~ 1 across HSC→CD19CD20,\n")
cat("     so no column should be uniformly red.)\n\n")

savics_avg_z_by_ct_ATAC <- scale(savics_avg_z_by_ct_ATAC_raw,
                                 center = TRUE, scale = TRUE)

col_means_mod <- apply(savics_avg_z_by_ct_ATAC, 2, mean)
col_sds_mod   <- apply(savics_avg_z_by_ct_ATAC, 2, sd)

cat("[7] Per-sample mean(z) across 7 progenitors (after scaling):\n")
print(summary(col_means_mod))
cat("[7] Per-sample sd(z) across 7 progenitors (after scaling):\n")
print(summary(col_sds_mod))

all_pos <- apply(savics_avg_z_by_ct_ATAC, 2, function(v) all(v > 0))
cat("[7] Samples with ALL Savics module scores > 0 (should be 0): ",
    sum(all_pos), "\n", sep = "")

cat("[7] Example scaled Savics module scores (first 5 samples):\n")
print(round(savics_avg_z_by_ct_ATAC[, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 8 — Dominant progenitor + margins (Tian-style)
# ---------------------------------------------------------------------
cat("\n[8] Computing dominant progenitor and Tian-style margins (Savics)...\n")

savics_top_idx    <- apply(savics_avg_z_by_ct_ATAC, 2, which.max)
savics_second_idx <- apply(savics_avg_z_by_ct_ATAC, 2, function(v) order(v, decreasing = TRUE)[2])

savics_dominant_tbl <- tibble::tibble(
    sample       = colnames(savics_avg_z_by_ct_ATAC),
    top_ct       = savics_ct_levels[savics_top_idx],
    top_score    = savics_avg_z_by_ct_ATAC[cbind(savics_top_idx, seq_along(savics_top_idx))],
    second_ct    = savics_ct_levels[savics_second_idx],
    second_score = savics_avg_z_by_ct_ATAC[cbind(savics_second_idx, seq_along(savics_second_idx))]
) %>%
    dplyr::mutate(
        margin = top_score - second_score
    ) %>%
    dplyr::left_join(
        meta_sj %>% dplyr::select(Sample, genotype),
        by = c("sample" = "Sample")
    )

cat("[8] First 10 Savics dominance calls:\n")
print(utils::head(savics_dominant_tbl, 10))

cat("\n[8] Frequency of Savics top_ct assignments:\n")
print(sort(table(savics_dominant_tbl$top_ct), decreasing = TRUE))

cat("\n[8] Margin summary (larger = more confident):\n")
print(summary(savics_dominant_tbl$margin))

# ---------------------------------------------------------------------
# 9 — Order samples: top_ct → margin → top_score
# ---------------------------------------------------------------------
cat("\n[9] Ordering samples by (top_ct → margin → top_score) [Savics]...\n")

savics_col_order <- order(
    factor(savics_dominant_tbl$top_ct, levels = savics_ct_levels),
    -savics_dominant_tbl$margin,
    -savics_dominant_tbl$top_score
)

savics_avg_z_by_ct_ord  <- savics_avg_z_by_ct_ATAC[, savics_col_order, drop = FALSE]
savics_dominant_tbl_ord <- savics_dominant_tbl[savics_col_order, ]

cat("[9] savics_avg_z_by_ct_ord dim: ",
    paste(dim(savics_avg_z_by_ct_ord), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 10 — Build annotations for pheatmap (heatmap step optional)
# ---------------------------------------------------------------------
cat("\n[10] Building savics_ann_col for pheatmap (heatmap optional)...\n")

savics_margin_bins <- cut(
    savics_dominant_tbl_ord$margin,
    breaks = quantile(savics_dominant_tbl_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

savics_ann_col <- data.frame(
    top_ct   = factor(savics_dominant_tbl_ord$top_ct, levels = savics_ct_levels),
    margin   = savics_margin_bins,
    genotype = savics_dominant_tbl_ord$genotype,
    row.names = savics_dominant_tbl_ord$sample,
    stringsAsFactors = FALSE
)

cat("[10] savics_ann_col head:\n")
print(utils::head(savics_ann_col, 10))

savics_cell_type_colors <- c(
    HSC        = "#fb8072",
    MPP        = "#bebada",
    LMPP       = "#ffd92f",
    CLP        = "#f781bf",
    PreProB    = "#ff33ff",
    ProB       = "#00e5c0",
    CD19CD20   = "#00bfff"
)

if (!exists("margin_colors")) {
    margin_colors <- c(
        "Q1 (lowest)" = "#c7e9c0",
        "Q2"          = "#a1d99b",
        "Q3"          = "#74c476",
        "Q4 (highest)"= "#238b45"
    )
}
if (!exists("genotype_colors")) {
    genotype_colors <- c(
        TT = "#f65e0dff",
        TC = "#0c2e18ff",
        CC = "#d7a419ff"
    )
}

# Optional heatmap (still commented)
# savics_z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)
# pheatmap::pheatmap(
#     savics_avg_z_by_ct_ord,
#     color            = savics_z_col_fun,
#     cluster_rows     = FALSE,
#     cluster_cols     = FALSE,
#     show_rownames    = TRUE,
#     show_colnames    = FALSE,
#     annotation_col   = savics_ann_col,
#     annotation_colors = list(
#         top_ct   = savics_cell_type_colors,
#         margin   = margin_colors,
#         genotype = genotype_colors
#     ),
#     border_color = NA,
#     main = "ATAC module activity (Savics peak markers; liftOver + overlap; column-scaled)"
# )

cat("\n[SAVICS] DONE — Savics hg19 markers have been lifted to hg38,\n")
cat("         overlapped with SJ156 peaks, turned into progenitor\n")
cat("         modules on your counts, column-scaled, and scored with\n")
cat("         Tian-style margins.\n")
cat("===============================================================\n\n")




savics_z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)
pheatmap::pheatmap(
    savics_avg_z_by_ct_ord,
    color            = savics_z_col_fun,
    cluster_rows     = FALSE,
    cluster_cols     = FALSE,
    show_rownames    = TRUE,
    show_colnames    = FALSE,
    annotation_col   = savics_ann_col,
    annotation_colors = list(
        top_ct   = savics_cell_type_colors,
        margin   = margin_colors,
        genotype = genotype_colors
    ),
    border_color = NA,
    main = "ATAC module activity (Savics peak markers; liftOver + overlap; column-scaled)"
)
```


#### Promoter only savic
```{r}
# =====================================================================
# ATAC — Savics S3 PROMOTER-ONLY dominance map WITH LIFTOVER (hg19 → hg38)
#        and overlap to SJ156 promoter peaks
#        (no sample should be "red for all progenitors")
# =====================================================================
# Requires in the environment:
#   - counts   : matrix [peaks × samples], rownames = peak_id ("peak_1", ...)
#   - anno_df  : data.frame with at least:
#                seqnames, start, end, peak_id, annotation (hg38 coordinates)
#   - meta_sj  : data.frame with columns Sample, genotype
#   - Savics_S3.xlsx : hg19 peak markers with chr, start, stop, Defining_Progenitor
#   - hg19ToHg38.over.chain.gz : UCSC chain file path (already in this wd)
#   - Colors & palettes already defined elsewhere:
#       savics_z_col_fun, savics_cell_type_colors, margin_colors, genotype_colors
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(readxl)
    library(tibble)
    library(pheatmap)
    library(stringr)
    library(GenomicRanges)
    library(rtracklayer)
    library(GenomeInfoDb)
    library(R.utils)
})

cat("\n===============================================================\n")
cat("ATAC SAVICS PIPELINE — PROMOTER-ONLY (LIFTOVER + OVERLAP + MODULES)\n")
cat("===============================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts")) {
    stop("[0] ERROR: `counts` (peak × sample matrix) not found.")
}
if (!exists("meta_sj")) {
    stop("[0] ERROR: `meta_sj` (Sample + genotype) not found.")
}
if (!exists("anno_df")) {
    stop("[0] ERROR: `anno_df` (peak annotation with coordinates) not found.")
}
if (!"annotation" %in% colnames(anno_df)) {
    stop("[0] ERROR: `anno_df` must contain an `annotation` column (Promoter vs others).")
}

cat("[0] counts dim (peaks × samples): ",
    paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols): ",
    paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 0a — Restrict anno_df to PROMOTER peaks only
# ---------------------------------------------------------------------
cat("\n[0a] Subsetting anno_df to promoter-only peaks (using `annotation`)...\n")

anno_prom <- anno_df %>%
    dplyr::filter(
        !is.na(annotation),
        grepl("Promoter", annotation, ignore.case = TRUE)
    )

cat("[0a] anno_prom dim (promoter peaks × cols): ",
    paste(dim(anno_prom), collapse = " × "), "\n", sep = "")
if (nrow(anno_prom) == 0L) {
    stop("[0a] ERROR: No promoter peaks found in anno_df$annotation.")
}

# ---------------------------------------------------------------------
# 0b — Chain file (hg19 → hg38) — gunzip once, then import .chain
# ---------------------------------------------------------------------
chain_gz  <- "hg19ToHg38.over.chain.gz"
chain_txt <- "hg19ToHg38.over.chain"

if (!file.exists(chain_gz)) {
    stop("[0b] ERROR: Chain .gz not found at: ",
         normalizePath(chain_gz, mustWork = FALSE))
}

if (!file.exists(chain_txt)) {
    cat("[0b] Unzipping chain file: ", chain_gz, " → ", chain_txt, "\n", sep = "")
    R.utils::gunzip(chain_gz, destname = chain_txt,
                    overwrite = TRUE, remove = FALSE)
}

first_line <- readLines(chain_txt, n = 1, warn = FALSE)
if (!startsWith(first_line, "chain ")) {
    stop("[0b] ERROR: Unzipped file does not start with 'chain'. Header:\n  ",
         first_line)
}

hg19_to_hg38_chain <- rtracklayer::import.chain(chain_txt)
cat("[0b] Loaded chain file: ", chain_txt, "\n", sep = "")

# quick tiny sanity test
test_hg19   <- GenomicRanges::GRanges("chr1", IRanges::IRanges(10000, 10050))
lifted_test <- rtracklayer::liftOver(test_hg19, hg19_to_hg38_chain)
cat("[0b] Test liftover returned ",
    lengths(lifted_test), " hg38 ranges for chr1:10000-10050\n", sep = "")

# ---------------------------------------------------------------------
# 1 — Load Savics S3 hg19 peaks
# ---------------------------------------------------------------------
savics_path <- "Savics_S3.xlsx"

cat("\n[1] Loading Savics peak markers (hg19) from:\n    ", savics_path, "\n", sep = "")
savics_raw <- readxl::read_xlsx(savics_path)

cat("[1] savics_raw dim (rows × cols): ",
    paste(dim(savics_raw), collapse = " × "), "\n", sep = "")
cat("[1] Columns:\n")
print(colnames(savics_raw))

savics_hg19_df <- savics_raw %>%
    as.data.frame() %>%
    dplyr::mutate(
        chr                 = as.character(chr),
        start               = as.integer(start),
        stop                = as.integer(stop),
        Defining_Progenitor = stringr::str_trim(as.character(Defining_Progenitor))
    ) %>%
    dplyr::distinct(chr, start, stop, Defining_Progenitor, .keep_all = TRUE)

cat("\n[1] After cleaning (hg19 coord space):\n")
cat("    • rows (peak × Defining_Progenitor string): ",
    nrow(savics_hg19_df), "\n", sep = "")
cat("    • unique coord triplets (chr,start,stop)  : ",
    nrow(dplyr::distinct(savics_hg19_df, chr, start, stop)), "\n", sep = "")

cat("\n[1] Example hg19 Savics rows:\n")
print(utils::head(savics_hg19_df, 10))

# how many progenitors per row?
savics_hg19_df <- savics_hg19_df %>%
    dplyr::mutate(
        n_progenitors = lengths(
            stringr::str_split(Defining_Progenitor, pattern = "\\s*,\\s*")
        )
    )

cat("\n[1] Distribution of n_progenitors per row (Savics table):\n")
print(
    savics_hg19_df %>%
        dplyr::count(n_progenitors, name = "n_rows") %>%
        dplyr::arrange(n_progenitors)
)

# ---------------------------------------------------------------------
# 1c — Build GRanges for Savics hg19 peaks & liftover to hg38
# ---------------------------------------------------------------------
cat("\n[1c] Building GRanges (hg19) and running liftOver → hg38...\n")

savics_gr_hg19 <- GenomicRanges::GRanges(
    seqnames = savics_hg19_df$chr,
    ranges   = IRanges::IRanges(start = savics_hg19_df$start,
                                end   = savics_hg19_df$stop)
)

savics_gr_hg38_list <- rtracklayer::liftOver(savics_gr_hg19, hg19_to_hg38_chain)
orig_idx             <- rep(seq_along(savics_gr_hg19), lengths(savics_gr_hg38_list))
savics_gr_hg38       <- unlist(savics_gr_hg38_list)

cat("[1c] LiftOver result:\n")
cat("    • original hg19 peaks      : ", length(savics_gr_hg19), "\n", sep = "")
cat("    • hg38 ranges after LO     : ", length(savics_gr_hg38), "\n", sep = "")

mapped_mask <- lengths(savics_gr_hg38_list) > 0
n_mapped    <- sum(mapped_mask)
n_unmapped  <- sum(!mapped_mask)

cat("    • hg19 peaks with >=1 hg38 : ", n_mapped, "\n", sep = "")
cat("    • hg19 peaks with 0 hg38   : ", n_unmapped, "\n", sep = "")

if (n_mapped == 0L) {
    stop("[1c] ERROR: liftover produced no hg38 mappings. Check chain/assembly.")
}

savics_hg38_df <- savics_hg19_df[orig_idx, , drop = FALSE] %>%
    dplyr::mutate(
        chr_hg38   = as.character(GenomeInfoDb::seqnames(savics_gr_hg38)),
        start_hg38 = as.integer(GenomicRanges::start(savics_gr_hg38)),
        stop_hg38  = as.integer(GenomicRanges::end(savics_gr_hg38))
    )

cat("\n[1c] savics_hg38_df dim (post-liftover, one row per hg38 interval): ",
    paste(dim(savics_hg38_df), collapse = " × "), "\n", sep = "")
cat("[1c] Example hg38 Savics rows:\n")
print(utils::head(savics_hg38_df, 10))

# ---------------------------------------------------------------------
# 2 — Build SJ156 PROMOTER peak GRanges (hg38) & find overlaps
# ---------------------------------------------------------------------
cat("\n[2] Building SJ156 PROMOTER GRanges (hg38) from anno_prom and finding overlaps...\n")

sj156_prom_gr <- GenomicRanges::GRanges(
    seqnames = as.character(anno_prom$seqnames),
    ranges   = IRanges::IRanges(start = as.integer(anno_prom$start),
                                end   = as.integer(anno_prom$end)),
    peak_id  = anno_prom$peak_id
)

savics_gr_hg38_clean <- GenomicRanges::GRanges(
    seqnames = savics_hg38_df$chr_hg38,
    ranges   = IRanges::IRanges(start = savics_hg38_df$start_hg38,
                                end   = savics_hg38_df$stop_hg38)
)

hits_prom <- GenomicRanges::findOverlaps(
    query  = savics_gr_hg38_clean,
    subject = sj156_prom_gr,
    ignore.strand = TRUE
)

cat("[2] Overlaps (Savics hg38 vs SJ156 PROMOTER peaks):\n")
cat("    • number of overlaps (pairs Savics×SJ156_prom) : ",
    length(hits_prom), "\n", sep = "")

if (length(hits_prom) == 0L) {
    stop("[2] ERROR: No overlaps between lifted Savics peaks and SJ156 PROMOTER peaks.\n       Check assemblies or promoter definition.")
}

savics_prom_overlap_df <- tibble::tibble(
    savics_idx = S4Vectors::queryHits(hits_prom),
    sj156_idx  = S4Vectors::subjectHits(hits_prom)
) %>%
    dplyr::mutate(
        Defining_Progenitor = savics_hg38_df$Defining_Progenitor[savics_idx],
        peak_id             = as.character(S4Vectors::mcols(sj156_prom_gr)$peak_id[sj156_idx])
    ) %>%
    dplyr::select(peak_id, Defining_Progenitor) %>%
    dplyr::distinct()

cat("\n[2] savics_prom_overlap_df dim (PROMOTER peak_id × progenitor pairs): ",
    paste(dim(savics_prom_overlap_df), collapse = " × "), "\n", sep = "")
cat("[2] Example promoter overlap-derived mappings:\n")
print(utils::head(savics_prom_overlap_df, 10))

savics_ct_levels <- c("HSC", "MPP", "LMPP", "CLP", "PreProB", "ProB", "CD19CD20")
cat("\n[2] Progenitor levels (developmental order):\n")
print(savics_ct_levels)

# ---------------------------------------------------------------------
# 3 — Restrict to promoter peaks that exist in counts & prepare long format
# ---------------------------------------------------------------------
cat("\n[3] Restricting PROMOTER mappings to peak_id present in counts...\n")

peaks_in_counts_prom <- intersect(savics_prom_overlap_df$peak_id, rownames(counts))

cat("[3] PROMOTER peak overlap with counts:\n")
cat("    • unique mapped SJ156 PROMOTER peak_id (from overlaps) : ",
    length(unique(savics_prom_overlap_df$peak_id)), "\n", sep = "")
cat("    • peaks_in_counts_prom (overlap ∩ counts rownames)     : ",
    length(peaks_in_counts_prom), "\n", sep = "")

if (length(peaks_in_counts_prom) == 0L) {
    stop("[3] ERROR: No overlapping PROMOTER peak_id found in counts; check peak_id consistency.")
}

savics_long_use_prom <- savics_prom_overlap_df %>%
    dplyr::filter(peak_id %in% peaks_in_counts_prom)

cat("[3] savics_long_use_prom dim (post-counts restriction): ",
    paste(dim(savics_long_use_prom), collapse = " × "), "\n", sep = "")
cat("[3] Example savics_long_use_prom rows:\n")
print(utils::head(savics_long_use_prom, 10))

# ---------------------------------------------------------------------
# 4 — Subset counts to Savics PROMOTER peaks & per-peak z-scores
# ---------------------------------------------------------------------
cat("\n[4] Subsetting counts to Savics PROMOTER peaks and z-scoring each peak...\n")

savics_counts_mat_prom <- counts[peaks_in_counts_prom, , drop = FALSE]

cat("[4] savics_counts_mat_prom dim (Savics PROMOTER peaks × samples): ",
    paste(dim(savics_counts_mat_prom), collapse = " × "), "\n", sep = "")

savics_z_peak_prom <- t(scale(t(savics_counts_mat_prom)))
savics_z_peak_prom[is.na(savics_z_peak_prom)] <- 0

cat("[4] Example PROMOTER peak z-scores (5 peaks × 5 samples):\n")
print(round(savics_z_peak_prom[1:5, 1:5, drop = FALSE], 3))

col_means_z_prom <- apply(savics_z_peak_prom, 2, mean)
col_sds_z_prom   <- apply(savics_z_peak_prom, 2, sd)

cat("[4] Per-sample mean(z) across Savics PROMOTER peaks:\n")
print(summary(col_means_z_prom))
cat("[4] Per-sample sd(z) across Savics PROMOTER peaks:\n")
print(summary(col_sds_z_prom))

# ---------------------------------------------------------------------
# 5 — Expand to peak×progenitor rows (PROMOTER; shared peaks duplicated)
# ---------------------------------------------------------------------
cat("\n[5] Building PROMOTER peak×progenitor matrix (shared peaks contribute to all modules)...\n")

savics_expanded_prom <- savics_long_use_prom %>%
    dplyr::mutate(
        row_id = paste(peak_id, Defining_Progenitor, sep = "|")
    ) %>%
    dplyr::left_join(
        savics_z_peak_prom %>%
            as.data.frame() %>%
            tibble::rownames_to_column("peak_id"),
        by = "peak_id"
    )

cat("[5] savics_expanded_prom rows (PROMOTER peak×progenitor): ",
    nrow(savics_expanded_prom), "\n", sep = "")

savics_mat_expanded_prom <- savics_expanded_prom %>%
    dplyr::select(-peak_id, -Defining_Progenitor) %>%
    tibble::column_to_rownames("row_id") %>%
    as.matrix()

cat("[5] savics_mat_expanded_prom dim (PROMOTER peak×ct rows × samples): ",
    paste(dim(savics_mat_expanded_prom), collapse = " × "), "\n", sep = "")

savics_ct_for_row_prom <- savics_expanded_prom$Defining_Progenitor
names(savics_ct_for_row_prom) <- rownames(savics_mat_expanded_prom)

cat("[5] Alignment check — first 5 rows (PROMOTER):\n")
print(
    head(
        cbind(
            savics_ct_for_row_prom = savics_ct_for_row_prom[1:5],
            rowname                = names(savics_ct_for_row_prom)[1:5]
        )
    )
)

# ---------------------------------------------------------------------
# 6 — Raw Savics PROMOTER module matrix: savics_avg_z_by_ct_ATAC_prom_raw
# ---------------------------------------------------------------------
cat("\n[6] Computing raw Savics PROMOTER module activity (savics_avg_z_by_ct_ATAC_prom_raw)...\n")

savics_avg_z_by_ct_ATAC_prom_raw <- do.call(
    rbind,
    lapply(savics_ct_levels, function(ct) {
        idx <- which(savics_ct_for_row_prom == ct)
        if (length(idx) == 0L) {
            cat("[6] WARNING: no Savics PROMOTER peaks for progenitor ", ct,
                "; filling with NA.\n", sep = "")
            return(rep(NA_real_, ncol(savics_mat_expanded_prom)))
        } else {
            return(colMeans(savics_mat_expanded_prom[idx, , drop = FALSE], na.rm = TRUE))
        }
    })
)
rownames(savics_avg_z_by_ct_ATAC_prom_raw) <- savics_ct_levels

cat("[6] savics_avg_z_by_ct_ATAC_prom_raw dim (7 × samples): ",
    paste(dim(savics_avg_z_by_ct_ATAC_prom_raw), collapse = " × "), "\n", sep = "")
cat("[6] Example raw Savics PROMOTER module scores (first 5 samples):\n")
print(round(savics_avg_z_by_ct_ATAC_prom_raw[, 1:5, drop = FALSE], 3))

cat("\n[6] Range of raw PROMOTER module scores:\n")
print(summary(as.vector(savics_avg_z_by_ct_ATAC_prom_raw)))

# ---------------------------------------------------------------------
# 7 — Column-wise scaling (per-sample z across progenitors; PROMOTER)
# ---------------------------------------------------------------------
cat("\n[7] Column-wise scaling: z-score Savics PROMOTER modules WITHIN each sample...\n")
cat("    (Per-sample mean ~ 0 and sd ~ 1 across HSC→CD19CD20,\n")
cat("     so no column should be uniformly red.)\n\n")

savics_avg_z_by_ct_ATAC_prom <- scale(savics_avg_z_by_ct_ATAC_prom_raw,
                                      center = TRUE, scale = TRUE)

col_means_mod_prom <- apply(savics_avg_z_by_ct_ATAC_prom, 2, mean)
col_sds_mod_prom   <- apply(savics_avg_z_by_ct_ATAC_prom, 2, sd)

cat("[7] Per-sample mean(z) across 7 progenitors (PROMOTER, after scaling):\n")
print(summary(col_means_mod_prom))
cat("[7] Per-sample sd(z) across 7 progenitors (PROMOTER, after scaling):\n")
print(summary(col_sds_mod_prom))

all_pos_prom <- apply(savics_avg_z_by_ct_ATAC_prom, 2, function(v) all(v > 0))
cat("[7] Samples with ALL Savics PROMOTER module scores > 0 (should be 0): ",
    sum(all_pos_prom), "\n", sep = "")

cat("[7] Example scaled Savics PROMOTER module scores (first 5 samples):\n")
print(round(savics_avg_z_by_ct_ATAC_prom[, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 8 — Dominant progenitor + margins (Tian-style; PROMOTER)
# ---------------------------------------------------------------------
cat("\n[8] Computing dominant progenitor and Tian-style margins (Savics PROMOTER)...\n")

savics_top_idx_prom    <- apply(savics_avg_z_by_ct_ATAC_prom, 2, which.max)
savics_second_idx_prom <- apply(savics_avg_z_by_ct_ATAC_prom, 2, function(v) order(v, decreasing = TRUE)[2])

savics_dominant_tbl_prom <- tibble::tibble(
    sample       = colnames(savics_avg_z_by_ct_ATAC_prom),
    top_ct       = savics_ct_levels[savics_top_idx_prom],
    top_score    = savics_avg_z_by_ct_ATAC_prom[cbind(savics_top_idx_prom, seq_along(savics_top_idx_prom))],
    second_ct    = savics_ct_levels[savics_second_idx_prom],
    second_score = savics_avg_z_by_ct_ATAC_prom[cbind(savics_second_idx_prom, seq_along(savics_second_idx_prom))]
) %>%
    dplyr::mutate(
        margin = top_score - second_score
    ) %>%
    dplyr::left_join(
        meta_sj %>% dplyr::select(Sample, genotype),
        by = c("sample" = "Sample")
    )

cat("[8] First 10 Savics PROMOTER dominance calls:\n")
print(utils::head(savics_dominant_tbl_prom, 10))

cat("\n[8] Frequency of Savics PROMOTER top_ct assignments:\n")
print(sort(table(savics_dominant_tbl_prom$top_ct), decreasing = TRUE))

cat("\n[8] PROMOTER margin summary (larger = more confident):\n")
print(summary(savics_dominant_tbl_prom$margin))

# ---------------------------------------------------------------------
# 9 — Order samples: top_ct → margin → top_score (PROMOTER)
# ---------------------------------------------------------------------
cat("\n[9] Ordering samples by (top_ct → margin → top_score) [Savics PROMOTER]...\n")

savics_col_order_prom <- order(
    factor(savics_dominant_tbl_prom$top_ct, levels = savics_ct_levels),
    -savics_dominant_tbl_prom$margin,
    -savics_dominant_tbl_prom$top_score
)

savics_avg_z_by_ct_prom_ord  <- savics_avg_z_by_ct_ATAC_prom[, savics_col_order_prom, drop = FALSE]
savics_dominant_tbl_prom_ord <- savics_dominant_tbl_prom[savics_col_order_prom, ]

cat("[9] savics_avg_z_by_ct_prom_ord dim: ",
    paste(dim(savics_avg_z_by_ct_prom_ord), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 10 — Build annotations for pheatmap (PROMOTER; heatmap step optional)
# ---------------------------------------------------------------------
cat("\n[10] Building savics_ann_col_prom for pheatmap (PROMOTER; heatmap optional)...\n")

savics_margin_bins_prom <- cut(
    savics_dominant_tbl_prom_ord$margin,
    breaks = quantile(savics_dominant_tbl_prom_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

savics_ann_col_prom <- data.frame(
    top_ct   = factor(savics_dominant_tbl_prom_ord$top_ct, levels = savics_ct_levels),
    margin   = savics_margin_bins_prom,
    genotype = savics_dominant_tbl_prom_ord$genotype,
    row.names = savics_dominant_tbl_prom_ord$sample,
    stringsAsFactors = FALSE
)

cat("[10] savics_ann_col_prom head:\n")
print(utils::head(savics_ann_col_prom, 10))

# ---------------------------------------------------------------------
# 11 — Optional PROMOTER-only heatmap
#      (assumes savics_z_col_fun, savics_cell_type_colors, margin_colors,
#       genotype_colors are already defined in the environment)
# ---------------------------------------------------------------------
# If you want the heatmap, uncomment this block:
# pheatmap::pheatmap(
#     savics_avg_z_by_ct_prom_ord,
#     color            = savics_z_col_fun,
#     cluster_rows     = FALSE,
#     cluster_cols     = FALSE,
#     show_rownames    = TRUE,
#     show_colnames    = FALSE,
#     annotation_col   = savics_ann_col_prom,
#     annotation_colors = list(
#         top_ct   = savics_cell_type_colors,
#         margin   = margin_colors,
#         genotype = genotype_colors
#     ),
#     border_color = NA,
#     main = "ATAC module activity (Savics PROMOTER markers; liftOver + overlap; column-scaled)"
# )

cat("\n[SAVICS PROMOTER] DONE — Savics hg19 markers have been lifted to hg38,\n")
cat("         overlapped with SJ156 PROMOTER peaks, turned into progenitor\n")
cat("         modules on your counts, column-scaled, and scored with\n")
cat("         Tian-style margins (PROMOTER-only).\n")
cat("===============================================================\n\n")



pheatmap::pheatmap(
    savics_avg_z_by_ct_prom_ord,
    color            = savics_z_col_fun,
    cluster_rows     = FALSE,
    cluster_cols     = FALSE,
    show_rownames    = TRUE,
    show_colnames    = FALSE,
    annotation_col   = savics_ann_col_prom,
    annotation_colors = list(
        top_ct   = savics_cell_type_colors,
        margin   = margin_colors,
        genotype = genotype_colors
    ),
    border_color = NA,
    main = "ATAC module activity (Savics PROMOTER markers; liftOver + overlap; column-scaled)"
)
```

### Enhancer only Savic

```{r}

# =====================================================================
# ATAC — Savics S3 ENHANCER-ONLY dominance map
#        Savics peaks ∩ SJ156 *enhancer-like* peaks (non-promoter/TSS)
# =====================================================================
# Assumes these already exist from previous chunks:
#   - counts, anno_df, meta_sj
#   - savics_hg38_df (hg38-lifted Savics S3 peaks)
#   - savics_ct_levels, colors, savics_z_col_fun, etc.
# =====================================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tidyr)
    library(tibble)
    library(GenomicRanges)
    library(pheatmap)
    library(stringr)
})

cat("\n=================================================================\n")
cat("ATAC SAVICS PIPELINE — ENHANCER-LIKE ONLY (OVERLAP + COLUMN-SCALED MODULES)\n")
cat("=================================================================\n\n")

# ---------------------------------------------------------------------
# 0 — Sanity checks
# ---------------------------------------------------------------------
if (!exists("counts")) {
    stop("[0] ERROR: `counts` (peak × sample matrix) not found.")
}
if (!exists("meta_sj")) {
    stop("[0] ERROR: `meta_sj` (Sample + genotype) not found.")
}
if (!exists("anno_df")) {
    stop("[0] ERROR: `anno_df` (peak annotation with coordinates) not found.")
}
if (!"annotation" %in% colnames(anno_df)) {
    stop("[0] ERROR: `anno_df` must contain an `annotation` column.")
}
if (!exists("savics_hg38_df")) {
    stop("[0] ERROR: `savics_hg38_df` not found. Run the global Savics liftover chunk first.")
}
if (!exists("savics_ct_levels")) {
    savics_ct_levels <- c("HSC", "MPP", "LMPP", "CLP", "PreProB", "ProB", "CD19CD20")
}

cat("[0] counts dim (peaks × samples): ",
    paste(dim(counts), collapse = " × "), "\n", sep = "")
cat("[0] anno_df dim (rows × cols): ",
    paste(dim(anno_df), collapse = " × "), "\n", sep = "")

# ---------------------------------------------------------------------
# 0a — Define enhancer-like peaks from anno_df
#       (HOMER rarely uses literal 'Enhancer' labels)
#       Here: enhancer-like = NOT promoter/TSS
# ---------------------------------------------------------------------
cat("\n[0a] Exploring `anno_df$annotation` classes...\n")
ann_vals <- sort(unique(anno_df$annotation))
print(ann_vals)

cat("\n[0a] Defining ENHANCER-LIKE as non-promoter / non-TSS peaks...\n")

anno_enh <- anno_df %>%
    dplyr::filter(
        !is.na(annotation),
        !grepl("Promoter", annotation, ignore.case = TRUE),
        !grepl("TSS",      annotation, ignore.case = TRUE)
    )

cat("[0a] anno_enh dim (enhancer-like peaks × cols): ",
    paste(dim(anno_enh), collapse = " × "), "\n", sep = "")
if (nrow(anno_enh) == 0L) {
    stop("[0a] ERROR: No enhancer-like peaks after excluding Promoter/TSS.\n",
         "      Refine the filter in 0a to match your annotation categories.")
}

# ---------------------------------------------------------------------
# 1 — Build SJ156 ENHANCER-LIKE GRanges (hg38) & find overlaps
# ---------------------------------------------------------------------
cat("\n[1] Building SJ156 ENHANCER-LIKE GRanges (hg38) and finding overlaps with Savics...\n")

sj156_enh_gr <- GenomicRanges::GRanges(
    seqnames = as.character(anno_enh$seqnames),
    ranges   = IRanges::IRanges(start = as.integer(anno_enh$start),
                                end   = as.integer(anno_enh$end)),
    peak_id  = anno_enh$peak_id
)

savics_gr_hg38_clean <- GenomicRanges::GRanges(
    seqnames = savics_hg38_df$chr_hg38,
    ranges   = IRanges::IRanges(start = savics_hg38_df$start_hg38,
                                end   = savics_hg38_df$stop_hg38)
)

hits_enh <- GenomicRanges::findOverlaps(
    query  = savics_gr_hg38_clean,
    subject = sj156_enh_gr,
    ignore.strand = TRUE
)

cat("[1] Overlaps (Savics hg38 vs SJ156 ENHANCER-LIKE peaks):\n")
cat("    • number of overlaps (pairs Savics×SJ156_enh_like) : ",
    length(hits_enh), "\n", sep = "")

if (length(hits_enh) == 0L) {
    stop("[1] ERROR: No overlaps between lifted Savics peaks and SJ156 ENHANCER-LIKE peaks.\n",
         "       Check assemblies or enhancer definition in 0a.")
}

savics_enh_overlap_df <- tibble::tibble(
    savics_idx = S4Vectors::queryHits(hits_enh),
    sj156_idx  = S4Vectors::subjectHits(hits_enh)
) %>%
    dplyr::mutate(
        Defining_Progenitor = savics_hg38_df$Defining_Progenitor[savics_idx],
        peak_id             = as.character(S4Vectors::mcols(sj156_enh_gr)$peak_id[sj156_idx])
    ) %>%
    dplyr::select(peak_id, Defining_Progenitor) %>%
    dplyr::distinct()

cat("\n[1] savics_enh_overlap_df dim (ENHANCER-LIKE peak_id × progenitor pairs): ",
    paste(dim(savics_enh_overlap_df), collapse = " × "), "\n", sep = "")
cat("[1] Example enhancer-like overlap-derived mappings:\n")
print(utils::head(savics_enh_overlap_df, 10))

# ---------------------------------------------------------------------
# 2 — Restrict to ENHANCER-LIKE peaks present in counts
# ---------------------------------------------------------------------
cat("\n[2] Restricting ENHANCER-LIKE mappings to peak_id present in counts...\n")

peaks_in_counts_enh <- intersect(savics_enh_overlap_df$peak_id, rownames(counts))

cat("[2] ENHANCER-LIKE peak overlap with counts:\n")
cat("    • unique mapped SJ156 ENHANCER-LIKE peak_id : ",
    length(unique(savics_enh_overlap_df$peak_id)), "\n", sep = "")
cat("    • peaks_in_counts_enh (overlap ∩ counts rownames) : ",
    length(peaks_in_counts_enh), "\n", sep = "")

if (length(peaks_in_counts_enh) == 0L) {
    stop("[2] ERROR: No overlapping ENHANCER-LIKE peak_id found in counts.")
}

savics_long_use_enh <- savics_enh_overlap_df %>%
    dplyr::filter(peak_id %in% peaks_in_counts_enh)

cat("[2] savics_long_use_enh dim (post-counts restriction): ",
    paste(dim(savics_long_use_enh), collapse = " × "), "\n", sep = "")
cat("[2] Example savics_long_use_enh rows:\n")
print(utils::head(savics_long_use_enh, 10))

# ---------------------------------------------------------------------
# 3 — Subset counts to ENHANCER-LIKE Savics peaks & z-score
# ---------------------------------------------------------------------
cat("\n[3] Subsetting counts to Savics ENHANCER-LIKE peaks and z-scoring...\n")

savics_counts_mat_enh <- counts[peaks_in_counts_enh, , drop = FALSE]

cat("[3] savics_counts_mat_enh dim (Savics ENHANCER-LIKE peaks × samples): ",
    paste(dim(savics_counts_mat_enh), collapse = " × "), "\n", sep = "")

savics_z_peak_enh <- t(scale(t(savics_counts_mat_enh)))
savics_z_peak_enh[is.na(savics_z_peak_enh)] <- 0

cat("[3] Example ENHANCER-LIKE peak z-scores (5 peaks × 5 samples):\n")
print(round(savics_z_peak_enh[1:5, 1:5, drop = FALSE], 3))

# ---------------------------------------------------------------------
# 4 — Expand to peak×progenitor rows and compute modules (as before)
# ---------------------------------------------------------------------
cat("\n[4] Building ENHANCER-LIKE peak×progenitor matrix and module averages...\n")

savics_expanded_enh <- savics_long_use_enh %>%
    dplyr::mutate(
        row_id = paste(peak_id, Defining_Progenitor, sep = "|")
    ) %>%
    dplyr::left_join(
        savics_z_peak_enh %>%
            as.data.frame() %>%
            tibble::rownames_to_column("peak_id"),
        by = "peak_id"
    )

cat("[4] savics_expanded_enh rows (ENHANCER-LIKE peak×progenitor): ",
    nrow(savics_expanded_enh), "\n", sep = "")

savics_mat_expanded_enh <- savics_expanded_enh %>%
    dplyr::select(-peak_id, -Defining_Progenitor) %>%
    tibble::column_to_rownames("row_id") %>%
    as.matrix()

cat("[4] savics_mat_expanded_enh dim (ENHANCER-LIKE peak×ct rows × samples): ",
    paste(dim(savics_mat_expanded_enh), collapse = " × "), "\n", sep = "")

savics_ct_for_row_enh <- savics_expanded_enh$Defining_Progenitor
names(savics_ct_for_row_enh) <- rownames(savics_mat_expanded_enh)

# Raw module means
savics_avg_z_by_ct_ATAC_enh_raw <- do.call(
    rbind,
    lapply(savics_ct_levels, function(ct) {
        idx <- which(savics_ct_for_row_enh == ct)
        if (length(idx) == 0L) {
            cat("[4] WARNING: no ENHANCER-LIKE Savics peaks for progenitor ", ct,
                "; filling with NA.\n", sep = "")
            return(rep(NA_real_, ncol(savics_mat_expanded_enh)))
        } else {
            return(colMeans(savics_mat_expanded_enh[idx, , drop = FALSE], na.rm = TRUE))
        }
    })
)
rownames(savics_avg_z_by_ct_ATAC_enh_raw) <- savics_ct_levels

cat("[4] savics_avg_z_by_ct_ATAC_enh_raw dim (7 × samples): ",
    paste(dim(savics_avg_z_by_ct_ATAC_enh_raw), collapse = " × "), "\n", sep = "")

# Column-wise scaling (within-sample)
savics_avg_z_by_ct_ATAC_enh <- scale(savics_avg_z_by_ct_ATAC_enh_raw,
                                     center = TRUE, scale = TRUE)



# ---------------------------------------------------------------------
# 5 — Dominant progenitor, ordering, annotations and ENHANCER-LIKE heatmap
# ---------------------------------------------------------------------
cat("\n[5] Dominant progenitor, margins, ordering and ENHANCER-LIKE heatmap...\n")

savics_top_idx_enh    <- apply(savics_avg_z_by_ct_ATAC_enh, 2, which.max)
savics_second_idx_enh <- apply(savics_avg_z_by_ct_ATAC_enh, 2, function(v) order(v, decreasing = TRUE)[2])

savics_dominant_tbl_enh <- tibble::tibble(
    sample       = colnames(savics_avg_z_by_ct_ATAC_enh),
    top_ct       = savics_ct_levels[savics_top_idx_enh],
    top_score    = savics_avg_z_by_ct_ATAC_enh[cbind(savics_top_idx_enh, seq_along(savics_top_idx_enh))],
    second_ct    = savics_ct_levels[savics_second_idx_enh],
    second_score = savics_avg_z_by_ct_ATAC_enh[cbind(savics_second_idx_enh, seq_along(savics_second_idx_enh))]
) %>%
    dplyr::mutate(
        margin = top_score - second_score
    ) %>%
    dplyr::left_join(
        meta_sj %>% dplyr::select(Sample, genotype),
        by = c("sample" = "Sample")
    )

cat("[5] Margin summary (ENHANCER-LIKE):\n")
print(summary(savics_dominant_tbl_enh$margin))

savics_col_order_enh <- order(
    factor(savics_dominant_tbl_enh$top_ct, levels = savics_ct_levels),
    -savics_dominant_tbl_enh$margin,
    -savics_dominant_tbl_enh$top_score
)

savics_avg_z_by_ct_enh_ord  <- savics_avg_z_by_ct_ATAC_enh[, savics_col_order_enh, drop = FALSE]
savics_dominant_tbl_enh_ord <- savics_dominant_tbl_enh[savics_col_order_enh, ]

# Quartile bins for margins
savics_margin_bins_enh <- cut(
    savics_dominant_tbl_enh_ord$margin,
    breaks = quantile(savics_dominant_tbl_enh_ord$margin, probs = seq(0, 1, 0.25), na.rm = TRUE),
    include.lowest = TRUE,
    labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)

savics_ann_col_enh <- data.frame(
    top_ct   = savics_dominant_tbl_enh_ord$top_ct,
    margin   = savics_margin_bins_enh,
    genotype = savics_dominant_tbl_enh_ord$genotype,
    row.names = savics_dominant_tbl_enh_ord$sample,
    stringsAsFactors = FALSE
)

# Make sure annotation rows are in the same order as heatmap columns
savics_ann_col_enh <- savics_ann_col_enh[colnames(savics_avg_z_by_ct_enh_ord), , drop = FALSE]

# Convert to factors explicitly (drop unused levels)
savics_ann_col_enh$top_ct   <- factor(savics_ann_col_enh$top_ct,   levels = savics_ct_levels)
savics_ann_col_enh$margin   <- factor(savics_ann_col_enh$margin,
                                      levels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)"))
savics_ann_col_enh$genotype <- factor(savics_ann_col_enh$genotype)

cat("[5] savics_ann_col_enh head:\n")
print(utils::head(savics_ann_col_enh))

# ---------------------------------------------------------------------
# Colors (reuse if already defined)
# ---------------------------------------------------------------------
if (!exists("savics_cell_type_colors")) {
    savics_cell_type_colors <- c(
        HSC        = "#fb8072",
        MPP        = "#bebada",
        LMPP       = "#ffd92f",
        CLP        = "#f781bf",
        PreProB    = "#ff33ff",
        ProB       = "#00e5c0",
        CD19CD20   = "#00bfff"
    )
}
if (!exists("margin_colors")) {
    margin_colors <- c(
        "Q1 (lowest)" = "#c7e9c0",
        "Q2"          = "#a1d99b",
        "Q3"          = "#74c476",
        "Q4 (highest)"= "#238b45"
    )
}
if (!exists("genotype_colors")) {
    genotype_colors <- c(
        TT = "#f65e0dff",
        TC = "#0c2e18ff",
        CC = "#d7a419ff"
    )
}
if (!exists("savics_z_col_fun")) {
    savics_z_col_fun <- colorRampPalette(c("blue", "white", "red"))(201)
}

# ---------------------------------------------------------------------
# ENHANCER-LIKE Savics heatmap
# ---------------------------------------------------------------------
pheatmap::pheatmap(
    savics_avg_z_by_ct_enh_ord,
    color             = savics_z_col_fun,
    cluster_rows      = FALSE,
    cluster_cols      = FALSE,
    show_rownames     = TRUE,
    show_colnames     = FALSE,
    annotation_col    = savics_ann_col_enh,
    annotation_colors = list(
        top_ct   = savics_cell_type_colors,
        margin   = margin_colors,
        genotype = genotype_colors
    ),
    border_color      = NA,
    main              = "ATAC module activity (Savics ENHANCER-LIKE markers; column-scaled)"
)

cat("\n[SAVICS ENHANCER-LIKE] DONE.\n\n")

```

#### Saving SAVICS for SJ19

```{r}
# ============================================================
# A — Save global Savics objects for reuse (ATAC + RNA-seq)
#     Run AFTER section 1c (when savics_hg38_df exists)
# ============================================================

suppressPackageStartupMessages({
    library(GenomicRanges)
    library(tibble)
})

# Directory where you want to keep shared Savics objects
savics_shared_dir <- "savics_shared_objects"  # <-- change path if you prefer
if (!dir.exists(savics_shared_dir)) {
    dir.create(savics_shared_dir, recursive = TRUE, showWarnings = FALSE)
}

# Ensure savics_ct_levels exists (in case not yet defined above)
if (!exists("savics_ct_levels")) {
    savics_ct_levels <- c("HSC", "MPP", "LMPP", "CLP", "PreProB", "ProB", "CD19CD20")
}

# GRanges with hg38 coordinates + progenitor label
savics_gr_hg38_global <- GenomicRanges::GRanges(
    seqnames = savics_hg38_df$chr_hg38,
    ranges   = IRanges::IRanges(
        start = savics_hg38_df$start_hg38,
        end   = savics_hg38_df$stop_hg38
    ),
    Defining_Progenitor = savics_hg38_df$Defining_Progenitor
)

# Save as RDS
saveRDS(
    savics_hg38_df,
    file = file.path(savics_shared_dir, "savics_hg38_df.rds")
)

saveRDS(
    savics_ct_levels,
    file = file.path(savics_shared_dir, "savics_ct_levels.rds")
)

saveRDS(
    savics_gr_hg38_global,
    file = file.path(savics_shared_dir, "savics_gr_hg38_global.rds")
)

cat("\n[SAVICS-SAVE] Saved global Savics objects:\n",
    "  - savics_hg38_df        → ", file.path(savics_shared_dir, "savics_hg38_df.rds"), "\n",
    "  - savics_ct_levels      → ", file.path(savics_shared_dir, "savics_ct_levels.rds"), "\n",
    "  - savics_gr_hg38_global → ", file.path(savics_shared_dir, "savics_gr_hg38_global.rds"), "\n\n", sep = "")

```

### Counting TC
```{r}
# ============================================================
# ATAC rs7090445 — TC allele imbalance stratified by cell state
#   (NA cell states EXCLUDED + FIXED depth-weighted T fraction)
# ============================================================
# Requires:
#   - ct_only           : Sample, C, T, ct_state (TT / TC / CC)
#   - dominant_tbl_ATAC : sample, top_ct (Ilaria dominance)
#
# Notes:
#   - Analysis restricted to TC samples only
#   - Samples without a dominant cell state are EXCLUDED
#   - Per-sample null expectation: Tfrac = 0.5
#   - Depth-weighted allele fraction per cell state is computed as:
#         depth_weighted_Tfrac = sum(T) / sum(T + C)
# ============================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tibble)
})

cat("\n============================================================\n")
cat("ATAC rs7090445 — TC ALLELE IMBALANCE BY CELL STATE (CLEAN + WEIGHTED FIX)\n")
cat("============================================================\n\n")

# ------------------------------------------------------------
# 0 — Sanity checks
# ------------------------------------------------------------
cat("[CHECK] Required columns in ct_only:\n")
req_ct <- c("Sample","C","T","ct_state")
cat("  • present? ", paste(req_ct %in% colnames(ct_only), collapse = ", "), "\n", sep = "")
stopifnot(all(req_ct %in% colnames(ct_only)))

cat("[CHECK] Required columns in dominant_tbl_ATAC:\n")
req_dom <- c("sample","top_ct")
cat("  • present? ", paste(req_dom %in% colnames(dominant_tbl_ATAC), collapse = ", "), "\n\n", sep = "")
stopifnot(all(req_dom %in% colnames(dominant_tbl_ATAC)))

# ------------------------------------------------------------
# 1 — Restrict to TC and join dominant cell state
# ------------------------------------------------------------
cat("[STEP 1] Subsetting ct_only to TC and joining dominant cell state...\n")

tc_df_all <- ct_only %>%
    dplyr::filter(ct_state == "TC") %>%
    dplyr::left_join(
        dominant_tbl_ATAC %>%
            dplyr::select(sample, top_ct),
        by = c("Sample" = "sample")
    ) %>%
    dplyr::mutate(
        total_reads = T + C,
        Tfrac       = dplyr::if_else(total_reads > 0, T / total_reads, NA_real_)
    )

cat("[CHECK] Total TC samples (before excluding NA top_ct): ", nrow(tc_df_all), "\n", sep = "")
cat("[CHECK] TC samples with missing top_ct: ", sum(is.na(tc_df_all$top_ct)), "\n", sep = "")

if (sum(is.na(tc_df_all$top_ct)) > 0) {
    cat("[INFO] TC samples excluded due to missing cell-state assignment (not in dominant_tbl_ATAC):\n")
    print(tc_df_all %>% dplyr::filter(is.na(top_ct)) %>% dplyr::pull(Sample))
}
cat("\n")

# ------------------------------------------------------------
# 1.1 — EXCLUDE samples without dominant cell state
# ------------------------------------------------------------
tc_df <- tc_df_all %>%
    dplyr::filter(!is.na(top_ct))

cat("[CHECK] TC samples retained AFTER exclusion: ", nrow(tc_df), "\n", sep = "")
cat("[CHECK] Cell-state distribution (TC only; valid states):\n")
print(sort(table(tc_df$top_ct), decreasing = TRUE))
cat("\n")

cat("[QC] Total reads (T+C) per TC sample — summary:\n")
print(summary(tc_df$total_reads))
cat("\n")

cat("[QC] Per-sample Tfrac summary in TC (null ~0.5 if no imbalance):\n")
print(summary(tc_df$Tfrac))
cat("\n")

# ------------------------------------------------------------
# 2 — Per–cell-type summaries (FIXED weighted fraction)
# ------------------------------------------------------------
cat("[STEP 2] Computing per–cell-type summaries (TC only; valid states)...\n")
cat("         depth_weighted_Tfrac = sum(T) / sum(T + C)\n\n")

tc_summary_ct <- tc_df %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        n_samples            = dplyr::n(),
        sum_T                = sum(T, na.rm = TRUE),
        sum_C                = sum(C, na.rm = TRUE),
        sum_total_reads      = sum(total_reads, na.rm = TRUE),
        mean_total_reads     = mean(total_reads, na.rm = TRUE),
        median_total_reads   = median(total_reads, na.rm = TRUE),
        mean_Tfrac           = mean(Tfrac, na.rm = TRUE),
        median_Tfrac         = median(Tfrac, na.rm = TRUE),
        depth_weighted_Tfrac = dplyr::if_else(sum_total_reads > 0, sum_T / sum_total_reads, NA_real_),
        .groups = "drop"
    ) %>%
    dplyr::arrange(dplyr::desc(depth_weighted_Tfrac))

cat("[RESULT] Per–cell-type allele balance summary (TC only; CLEAN):\n")
print(tc_summary_ct)
cat("\n")

cat("[RESULT] Same summary as MARKDOWN (easy to paste to client):\n")
if (requireNamespace("knitr", quietly = TRUE)) {
    cat(knitr::kable(tc_summary_ct, format = "markdown", digits = 4))
    cat("\n\n")
} else {
    cat("  (knitr not available; printing tibble above instead.)\n\n")
}

# ------------------------------------------------------------
# 3 — Cell-type–specific statistical tests + read-count context
# ------------------------------------------------------------
cat("[STEP 3] Cell-type–specific tests + read-count context...\n")
cat("         • Wilcoxon on per-sample Tfrac: H0 median(Tfrac)=0.5 (n>=5 only)\n")
cat("         • Binomial on aggregated reads: H0 p(T)=0.5 (informative but read-level)\n\n")

tc_tests_ct <- tc_df %>%
    dplyr::group_by(top_ct) %>%
    dplyr::summarise(
        n_samples            = dplyr::n(),
        sum_T                = sum(T, na.rm = TRUE),
        sum_C                = sum(C, na.rm = TRUE),
        sum_total_reads      = sum(T + C, na.rm = TRUE),
        depth_weighted_Tfrac = dplyr::if_else(sum_total_reads > 0, sum_T / sum_total_reads, NA_real_),
        wilcox_p             = if (dplyr::n() >= 5)
            stats::wilcox.test(Tfrac, mu = 0.5, exact = FALSE)$p.value
        else
            NA_real_,
        binom_p              = if (sum_total_reads > 0)
            stats::binom.test(x = sum_T, n = sum_total_reads, p = 0.5, alternative = "two.sided")$p.value
        else
            NA_real_,
        .groups = "drop"
    ) %>%
    dplyr::arrange(dplyr::desc(depth_weighted_Tfrac))

cat("[STATS] Tests per cell state (TC only; CLEAN):\n")
print(tc_tests_ct)
cat("\n")

cat("[STATS] Same test table as MARKDOWN (easy to paste to client):\n")
if (requireNamespace("knitr", quietly = TRUE)) {
    cat(knitr::kable(tc_tests_ct, format = "markdown", digits = 6))
    cat("\n\n")
} else {
    cat("  (knitr not available; printing tibble above instead.)\n\n")
}

cat("============================================================\n")
cat("[DONE] NA cell states excluded; depth-weighted Tfrac fixed; tests include read counts.\n")
cat("============================================================\n\n")

```



## What is the overlap of samples called proB cells between Ilarias and Savics? How consistent is the sample being called a 'ProB' accross all of them. prepro and

CLP from Savics overlapping with early lymphoid from Ilarias
