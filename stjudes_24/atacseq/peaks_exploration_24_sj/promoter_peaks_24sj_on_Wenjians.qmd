```{r}
# === Load libraries ===
suppressPackageStartupMessages({
    library(readr)      # fast reading of large text files
    library(dplyr)      # data wrangling
    library(tibble)     # tidy rownames/columns handling
    library(stringr)
    library(purrr)# clean up sample names
})



```
# Stacked bar plot
```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Load the data
df <- read.csv("24_sj_snp_summary_merged.csv")

# Keep only relevant base columns (C and T)
df_filtered <- df %>%
    select(Sample, C, T)

# Infer genotype based on presence of C and T
df_filtered <- df_filtered %>%
    mutate(Genotype = case_when(
        C > 0 & T > 0 ~ "TC",
        C > 0 & T == 0 ~ "CC",
        T > 0 & C == 0 ~ "TT",
        TRUE ~ "NA"
    ))

# Reshape for plotting
df_long <- df_filtered %>%
    pivot_longer(cols = c(C, T), names_to = "Base", values_to = "Count")

# Order genotype factor
df_long$Genotype <- factor(df_long$Genotype, levels = c("TT", "TC", "CC"))

# Order samples by genotype
df_long$Sample <- factor(df_long$Sample, levels = df_long %>%
                             distinct(Sample, Genotype) %>%
                             arrange(Genotype) %>%
                             pull(Sample))

# Plot
ggplot(df_long, aes(x = Sample, y = Count, fill = Base)) +
    geom_bar(stat = "identity") +
    theme_minimal() +
    labs(title = "Base Composition per Sample (C and T only)",
         x = "Sample",
         y = "Read Count",
         fill = "Base") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    scale_y_continuous(breaks = scales::pretty_breaks(n = 10))


```

## Loading

```{r}
# === Define path to promoter counts file ===
counts_file <- "promoter_counts_all.txt"

# === Load counts ===
promoter_counts <- read_tsv(counts_file, comment = "#")

# === Inspect ===
dim(promoter_counts)     # number of promoters × number of columns
colnames(promoter_counts)[1:10]  # first few column names
head(promoter_counts)    # first few rows

# === Clean sample names (remove long BAM paths) ===
promoter_counts <- promoter_counts %>%
    rename_with(~str_replace(.x, ".*/", ""), starts_with("/")) %>%  # strip directory paths
    rename_with(~str_replace(.x, ".mLb.*bam$", ""), everything())   # strip BAM suffix

# === Quick summary of counts ===
summary(as.matrix(promoter_counts[,-c(1:6)]))  # exclude annotation columns
```



```{r}
# === Add genotype suffix to promoter_counts column names ===
suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(readr)
})

# === Add genotype suffix to promoter_counts column names (manual assignment) ===
suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(readr)
  library(purrr)
})

# Define genotype groups manually (based on number after "ATAC_")
tt_samples <- c(10,12,17,18,1,20,23,3,5,24)
tc_samples <- c(11,16,21,22,2,4,6,8)
cc_samples <- c(13,14,7,9)
drop_samples <- c(15,19)

# Function: assign genotype based on sample number
assign_genotype <- function(sample_id) {
  num <- as.integer(str_extract(sample_id, "(?<=ATAC_)\\d+"))
  if (num %in% tt_samples) return("TT")
  if (num %in% tc_samples) return("TC")
  if (num %in% cc_samples) return("CC")
  if (num %in% drop_samples) return(NA_character_)
  return(NA_character_)
}

# Original promoter_counts has first 6 annotation cols + sample cols
cols_to_update <- colnames(promoter_counts)[-(1:6)]

# Assign genotypes; drop unwanted
geno_map <- tibble(Sample = cols_to_update) %>%
  mutate(Genotype = map_chr(Sample, assign_genotype)) %>%
  filter(!is.na(Genotype))   # drop 15 and 19

# Update promoter_counts to keep only these samples, add suffix
new_names <- paste0(geno_map$Sample, "_", geno_map$Genotype)
colnames(promoter_counts) <- c(colnames(promoter_counts)[1:6], new_names)

# Also drop the sample columns that were NA (15, 19)
promoter_counts <- promoter_counts[, c(colnames(promoter_counts)[1:6], new_names)]

# Inspect
colnames(promoter_counts)

```
## Loading list of genes
```{r}
wenjians_sig_proB_list <- read.csv("significance_genes_Wenjians_for_peaks_24_sj.csv")
```

### Heatmap
## Collapse duplicates 

Grouped by gene name and summed counts across all promoters.

Pros: one row per gene, clean heatmap, interpretable.

Cons: you lose promoter-level resolution; different promoters with opposite patterns would be averaged out.
```{r}
suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(readr)
  library(pheatmap)
  library(tibble)
  library(scales)
})

# --- Load Wenjian’s significant genes list ---
wenjians_sig_proB_list <- read.csv("significance_genes_Wenjians_for_peaks_24_sj.csv")

# --- Collapse duplicates: sum counts per gene ---
count_mat <- promoter_counts %>%
  mutate(label_gene = str_extract(Geneid, "^[^|]+")) %>%
  group_by(label_gene) %>%
  summarise(across(starts_with("ATAC_"), sum), .groups = "drop") %>%
  column_to_rownames("label_gene")

# --- Keep only Wenjian’s genes (intersection with promoter_counts) ---
genes_to_keep <- intersect(wenjians_sig_proB_list$label_gene, rownames(count_mat))
count_mat <- count_mat[genes_to_keep, ]

# --- Ensure Wenjian’s ordering: "down" first, then "up" ---
wenjian_order <- wenjians_sig_proB_list %>%
  filter(label_gene %in% genes_to_keep) %>%
  arrange(factor(sig, levels = c("down", "up")), label_gene)

count_mat <- count_mat[wenjian_order$label_gene, ]

# --- Z-score transform across samples (per gene) ---
z_counts <- t(scale(t(as.matrix(count_mat))))
z_counts[z_counts > 3] <- 3   # cap values
z_counts[z_counts < -3] <- -3

# --- Column annotations: genotype from column names ---
col_anno <- data.frame(
  Genotype = str_extract(colnames(z_counts), "TT|TC|CC")
)
rownames(col_anno) <- colnames(z_counts)

# --- Row annotations: up vs down from Wenjian’s list ---
row_anno <- data.frame(
  Regulation = wenjian_order$sig
)
rownames(row_anno) <- wenjian_order$label_gene

# --- Colors for annotations ---
anno_colors <- list(
  Genotype = c(TT = "yellow", TC = "darkgreen", CC = "purple"),
  Regulation = c(down = "darkblue", up = "darkorange")
)

# --- Order columns by genotype: TT → TC → CC ---
tt_cols <- grep("TT", colnames(z_counts), value = TRUE)
tc_cols <- grep("TC", colnames(z_counts), value = TRUE)
cc_cols <- grep("CC", colnames(z_counts), value = TRUE)
z_counts <- z_counts[, c(tt_cols, tc_cols, cc_cols)]
col_anno <- col_anno[c(tt_cols, tc_cols, cc_cols), , drop = FALSE]

# --- Heatmap ---
pheatmap(
  z_counts,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_rownames = TRUE,
  show_colnames = TRUE,
  annotation_col = col_anno,
  annotation_row = row_anno,
  annotation_colors = anno_colors,
  color = colorRampPalette(c("navy", "white", "firebrick3"))(100),
  breaks = seq(-3, 3, length.out = 101),
  fontsize_row = 6,
  fontsize_col = 7,
  main = "Promoter Accessibility (Wenjian’s significant genes)"
)

```

## Option 2

### Make rownames unique by appending gene_id, that way each promoter is unique, and you still keep the readable gene symbol

```{r}
suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(readr)
  library(pheatmap)
  library(tibble)
})

# --- Load Wenjian’s significant genes list (columns: sig, label_gene) ---
wenjians_sig_proB_list <- read.csv("significance_genes_Wenjians_for_peaks_24_sj.csv") %>%
  distinct(label_gene, sig)

# ---------- PROMOTER-LEVEL MATRIX (Option A) ----------
# STRICT gene matching: extract the gene symbol from Geneid and semi_join
subset_counts <- promoter_counts %>%
  mutate(label_gene = str_extract(Geneid, "^[^|]+")) %>%          # e.g., "TP53" from "TP53|ENSG..."
  semi_join(wenjians_sig_proB_list, by = "label_gene")            # keep only exact gene symbols in Wenjian’s list

# Row names = gene_name|gene_id with "_" (unique per promoter/gene pair)
# -> TP53_ENSG00000141510
count_mat <- subset_counts %>%
  mutate(promoter_id = str_replace(Geneid, "\\|", "_")) %>%
  select(promoter_id, starts_with("ATAC_")) %>%
  column_to_rownames("promoter_id")

# --- Z-score transform across samples (per promoter) and cap [-3, 3] ---
z_counts <- t(scale(t(as.matrix(count_mat))))
z_counts[is.na(z_counts)] <- 0          # if a promoter is constant, scale() returns NA; set to 0
z_counts[z_counts >  3] <-  3
z_counts[z_counts < -3] <- -3

# --- Column annotations: genotype from column names; order TT → TC → CC ---
col_anno <- data.frame(Genotype = str_extract(colnames(z_counts), "TT|TC|CC"))
rownames(col_anno) <- colnames(z_counts)

tt_cols <- grep("TT", colnames(z_counts), value = TRUE)
tc_cols <- grep("TC", colnames(z_counts), value = TRUE)
cc_cols <- grep("CC", colnames(z_counts), value = TRUE)
z_counts <- z_counts[, c(tt_cols, tc_cols, cc_cols)]
col_anno <- col_anno[c(tt_cols, tc_cols, cc_cols), , drop = FALSE]

# --- Row annotations: every promoter inherits its gene’s up/down label ---
row_df <- subset_counts %>%
  transmute(
    promoter_id = str_replace(Geneid, "\\|", "_"),
    label_gene,
  ) %>%
  left_join(wenjians_sig_proB_list, by = "label_gene")  # add 'sig' as Regulation

# Make sure row order exists in matrix (guards against any mismatch)
row_df <- row_df %>% filter(promoter_id %in% rownames(z_counts))

row_anno <- data.frame(Regulation = row_df$sig)
rownames(row_anno) <- row_df$promoter_id

# --- Force row ordering: all "down" first, then "up" (stable within gene/promoter) ---
ordered_rows <- row_df %>%
  arrange(factor(sig, levels = c("down", "up")), label_gene, promoter_id) %>%
  pull(promoter_id)

z_counts <- z_counts[ordered_rows, , drop = FALSE]
row_anno <- row_anno[ordered_rows, , drop = FALSE]

# --- Annotation colors ---
anno_colors <- list(
  Genotype   = c(TT = "yellow", TC = "darkgreen", CC = "purple"),
  Regulation = c(down = "darkblue", up = "darkorange")
)

# --- Heatmap (no clustering; z-score range [-3, 3]) ---
pheatmap(
  z_counts,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_rownames = FALSE,         # too many promoters → hide labels (toggle to TRUE if you want them)
  show_colnames = TRUE,
  annotation_col = col_anno,
  annotation_row = row_anno,
  annotation_colors = anno_colors,
  color  = colorRampPalette(c("navy", "white", "firebrick3"))(100),
  breaks = seq(-3, 3, length.out = 101),
  fontsize_row = 6,
  fontsize_col = 7,
  main = "Promoter-level Accessibility (Wenjian’s significant genes; Option A)"
)

```

## DAA

### Loading GTF

```{r}
# Load GTF annotation
gtf <- rtracklayer::import("/Users/cojulian/Desktop/Tzu_projects/Matt/reference_genomces/Homo_sapiens.GRCh38.113.gtf.gz")
gtf_df <- as.data.frame(gtf)

# Create transcript-to-gene mapping
tx2gene_df <- gtf_df %>%
  dplyr::select(transcript_id, gene_id, gene_name) %>%
  dplyr::distinct(transcript_id, gene_id, gene_name) %>%
  drop_na()

```


```{r}
suppressPackageStartupMessages({
    library(DESeq2)
    library(dplyr)
    library(ggplot2)
    library(ggrepel)
    library(stringr)
    library(tibble)
    library(scales)
})

# --- Step 1: Build raw matrix from promoter_counts ---
raw_counts <- promoter_counts %>%
    select(-Chr, -Start, -End, -Strand, -Length) %>%
    column_to_rownames("Geneid")

# --- Step 2: Extract gene_id from rownames ---
raw_counts_df <- raw_counts %>%
    rownames_to_column("Geneid") %>%
    mutate(gene_id = str_extract(Geneid, "(?<=\\|)ENSG[0-9]+"))

# --- Step 3: Build gene→biotype map from GTF ---
gene_map <- gtf_df %>%
    select(gene_id, gene_name, gene_biotype) %>%
    distinct()

# --- Step 4: Filter only protein-coding genes ---
coding_counts_df <- raw_counts_df %>%
    left_join(gene_map, by = "gene_id") %>%
    filter(gene_biotype == "protein_coding") %>%
    select(-gene_biotype)

# --- Step 5: Restore matrix form ---
coding_counts <- coding_counts_df %>%
    column_to_rownames("Geneid") %>%
    select(-gene_id, -gene_name)   # keep only counts

# --- Step 6: Build sample metadata (coldata) ---
sample_ids <- colnames(coding_counts)
genotypes <- str_extract(sample_ids, "TT|TC|CC")
coldata <- data.frame(
    row.names = sample_ids,
    Genotype  = factor(genotypes, levels = c("TT","TC","CC"))
)

# --- Step 7: Create DESeq2 dataset ---
dds <- DESeqDataSetFromMatrix(
    countData = coding_counts,
    colData   = coldata,
    design    = ~ Genotype
)

# --- Step 8: Run DESeq2 ---
dds <- DESeq(dds)

# --- Step 9: Extract results: TT vs CC ---
res_df <- results(dds, contrast = c("Genotype","TT","CC")) %>%
    as.data.frame() %>%
    rownames_to_column("ensembl_id") %>%
    mutate(
        neglog10P = -log10(pvalue),
        sig = case_when(
            pvalue < 0.05 & log2FoldChange >  0.2 ~ "up",
            pvalue < 0.05 & log2FoldChange < -0.2 ~ "down",
            TRUE ~ "ns"
        )
    )

# --- Step 10: Volcano plot prep ---
x_max <- max(abs(res_df$log2FoldChange), na.rm = TRUE)
y_max <- max(res_df$neglog10P, na.rm = TRUE)

# Highlight ARID5B
highlight_gene <- "ENSG00000150347"   # ARID5B Ensembl ID
highlight_data <- res_df %>% filter(str_detect(ensembl_id, highlight_gene))

# Plot title

# Plot title
title_txt <- "24 Sj Volcano plot (Promoter accessibility, coding only): TT vs CC [pval 0.05;LogFC abs(0.2)]"

# --- Volcano plot ---
ggplot(res_df, aes(x = log2FoldChange, y = neglog10P)) +
    geom_point(aes(fill = sig, size = sig, alpha = sig), shape = 21, colour = "black") +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", colour = "grey50") +
    geom_vline(xintercept = c(-0.2, 0.2), linetype = "dashed", colour = "grey50") +
    geom_point(data = highlight_data, aes(x = log2FoldChange, y = neglog10P),
               color = "red", fill = "red", shape = 21, size = 3) +
    geom_label_repel(
        data = highlight_data,
        aes(label = "ARID5B"),
        color = "black", fill = "white",
        fontface = "bold", size = 5,
        box.padding = 0.5, point.padding = 0.3,
        segment.color = "red", segment.size = 0.7,
        label.size = 0.4, label.r = unit(0.15, "lines"),
        max.overlaps = Inf
    ) +
    scale_fill_manual(values = c(up = "#D55E00", down = "#0072B2", ns = "grey80")) +
    scale_size_manual(values = c(up = 2.5, down = 2.5, ns = 1.0), guide = "none") +
    scale_alpha_manual(values = c(up = 0.9, down = 0.9, ns = 0.5), guide = "none") +
    coord_cartesian(xlim = c(-x_max, x_max), ylim = c(0, y_max)) +
    theme_minimal(base_size = 15) +
    theme(
        plot.title   = element_text(size = 18, face = "bold", hjust = 0.5),
        axis.title   = element_text(size = 15, face = "bold"),
        axis.text    = element_text(size = 13),
        legend.title = element_text(size = 14, face = "bold"),
        legend.text  = element_text(size = 12),
        panel.grid.minor = element_blank()
    ) +
    labs(title = title_txt,
         x = "log2 Fold Change (TT / CC)",
         y = "-log10(p-value)")


```




