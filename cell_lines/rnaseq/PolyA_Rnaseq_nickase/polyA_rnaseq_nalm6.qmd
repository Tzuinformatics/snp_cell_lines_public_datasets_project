```{r}
# Load required libraries
suppressMessages(library(tidyverse))

# Define base directory
base_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/cell_lines/rnaseq/PolyA_Rnaseq_nickase/polyA_sf_files"

# Get full paths and sample names
sample_dirs  <- list.dirs(base_dir, recursive = FALSE, full.names = TRUE)
sample_names <- basename(sample_dirs)

# Construct metadata
sample_metadata <- tibble(
    sample = sample_names,
    path   = file.path(sample_dirs, "quant.sf")
) %>%
    mutate(
        cell_line = "NALM6",
        genotype  = case_when(
            str_detect(sample, "TT") ~ "TT",
            str_detect(sample, "TC") ~ "TC",
            str_detect(sample, "CC") ~ "CC",
            TRUE ~ NA_character_
        ),
        clone = str_extract(sample, "Clone[0-9]+") %>%
            str_remove("Clone") %>%
            as.integer(),
        replicate = str_extract(sample, "REP[0-9]+") %>%
            str_remove("REP") %>%
            as.integer(),
        batch = case_when(
            str_detect(sample, "REP1") ~ "Batch1",
            str_detect(sample, "REP2") ~ "Batch2",
            TRUE ~ "Unknown"
        ),
        sample_id_full = paste(cell_line, genotype,
                               paste0("C", clone),
                               paste0("R", replicate),
                               sep = "_")
    )

# Assign rownames
rownames(sample_metadata) <- sample_metadata$sample_id_full

# Preview
print(sample_metadata)

```


```{r}
suppressMessages(library(rtracklayer))

# Import GTF
gtf <- import("/Users/cojulian/Desktop/Tzu_projects/Matt/reference_genomces/Homo_sapiens.GRCh38.113.gtf.gz")
gtf_df <- as.data.frame(gtf)

# Build transcript-to-gene mapping
tx2gene_df <- gtf_df %>%
  select(transcript_id, gene_id, gene_name) %>%
  distinct(transcript_id, gene_id, gene_name) %>%
  drop_na()

```

## ðŸ”¹ Chunk 2. Align metadata for downstream analysis

```{r}
# Prepare colData for SummarizedExperiment / DESeq2
human_coldata <- sample_metadata %>%
  mutate(files = path) %>%
  dplyr::select(sample_id_full, files, everything()) %>%
  dplyr::rename(Sample = sample_id_full)

rownames(human_coldata) <- human_coldata$Sample

```


```{r}
# Initialize from first file
tmp <- read.delim(human_coldata$files[1]) %>%
  inner_join(tx2gene_df, by = c("Name" = "transcript_id")) %>%
  group_by(gene_id) %>%
  summarise(NumReads = as.integer(sum(NumReads)))

# Matrix dimensions
num.row <- nrow(tmp)
num.col <- nrow(human_coldata)

# Empty count matrix
sf.df <- data.frame(matrix(0, nrow = num.row, ncol = num.col))
colnames(sf.df) <- human_coldata$Sample
rownames(sf.df) <- tmp$gene_id

# Fill matrix
for (i in seq_along(human_coldata$files)) {
  cat("Reading:", human_coldata$files[i], "\n")
  
  sf.df[, i] <- read.delim(human_coldata$files[i]) %>%
    inner_join(tx2gene_df, by = c("Name" = "transcript_id")) %>%
    group_by(gene_id) %>%
    summarise(NumReads = as.integer(sum(NumReads))) %>%
    pull(NumReads)
}

```

```{r}
# Convert to matrix for downstream use (DESeq2, edgeR, etc.)
Salmon.matrix <- as.matrix(sf.df)

# Confirm sample IDs match
all(colnames(Salmon.matrix) %in% rownames(human_coldata))  # Should return TRUE
```
# CPM Filtering

CPM (counts per million) rescales raw counts by each libraryâ€™s total reads, i.e., CPM = (raw_count / library_size) Ã— 10^6, which directly adjusts for sequencing depth. edgeRâ€™s filterByExpr() uses CPM thresholds that are adaptive to library sizes and your design (via group=), keeping genes that are sufficiently expressed in enough samples within groups to be testable in differential analysis. This approach is superior to a fixed raw-count cutoff because it avoids depth bias, reduces multiple-testing burden by removing uninformative, near-zero genes, and respects replication structure (e.g., TT/TC/CC triplicates). In short, CPM-aware filtering is principled, depth-aware, and aligned with best practice for RNA-seq DE pipelines.


```{r}
# ==============================================
# ðŸ”¹ CPM-aware filtering with edgeR::filterByExpr
# ==============================================

suppressMessages(library(edgeR))

# Build DGEList from Salmon.matrix
y <- DGEList(counts = Salmon.matrix)

# Define grouping (by genotype)
grp <- factor(
  human_coldata$genotype[match(colnames(Salmon.matrix), human_coldata$Sample)],
  levels = c("TT","TC","CC")
)

# Apply filterByExpr (CPM-aware, respects design and library size)
keep <- filterByExpr(y, group = grp)

cat("\n[filterByExpr summary]\n")
cat("Genes before filtering :", nrow(Salmon.matrix), "\n")
cat("Genes kept (CPM-aware) :", sum(keep), "\n")
cat("Percent retained        :", round(100 * sum(keep) / nrow(Salmon.matrix), 2), "%\n")

# Filter raw counts accordingly
sf.df.data <- Salmon.matrix[keep, ]

# âœ… Inspect result
cat("\nFinal CPM-filtered matrix dimensions:\n")
print(dim(sf.df.data))

cat("\nPreview filtered matrix:\n")
print(head(sf.df.data[, 1:5]))

```


```{r}
# ==============================================
# Per-sample distributions (pre vs CPM-filtered)
# ==============================================
suppressMessages(library(tidyverse))

# Long-form pre-filter (raw)
pre_long <- as.data.frame(Salmon.matrix) %>%
  tibble::rownames_to_column("gene_id") %>%
  pivot_longer(-gene_id, names_to = "Sample", values_to = "counts") %>%
  mutate(stage = "Unfiltered")

# Long-form post-filter (same raw counts, CPM-filtered gene set)
post_long <- as.data.frame(sf.df.data) %>%
  tibble::rownames_to_column("gene_id") %>%
  pivot_longer(-gene_id, names_to = "Sample", values_to = "counts") %>%
  mutate(stage = "CPM-filtered")

per_sample <- bind_rows(pre_long, post_long) %>%
  mutate(log_counts = log2(counts + 1)) %>%
  left_join(human_coldata %>% dplyr::select(Sample, genotype), by = "Sample")

ggplot(per_sample, aes(x = Sample, y = log_counts, fill = stage)) +
  geom_violin(scale = "width", trim = TRUE, alpha = 0.8) +
  facet_grid(. ~ genotype, scales = "free_x", space = "free_x") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(
    title = "Per-sample distributions (pre vs CPM-aware post-filter)",
    x = "Sample", y = "log2(counts + 1)", fill = "Stage"
  )

# ==============================================
# Post-filter logCPM (edgeR) per sample
# ==============================================
suppressMessages(library(edgeR))
suppressMessages(library(tidyverse))

# Compute logCPM on the CPM-filtered raw-count matrix
logcpm <- cpm(DGEList(counts = sf.df.data), log = TRUE, prior.count = 1)

logcpm_long <- as.data.frame(logcpm) %>%
  tibble::rownames_to_column("gene_id") %>%
  pivot_longer(-gene_id, names_to = "Sample", values_to = "logCPM") %>%
  left_join(human_coldata %>% dplyr::select(Sample, genotype), by = "Sample")

ggplot(logcpm_long, aes(x = Sample, y = logCPM)) +
  geom_boxplot(outlier.size = 0.3) +
  facet_grid(. ~ genotype, scales = "free_x", space = "free_x") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(
    title = "Post-filter logCPM distributions per sample",
    x = "Sample", y = "logCPM"
  )


```


# Getting FPKM
```{r}
# ==============================================
# ðŸ”¹ Compute FPKM and plot ARID5B expression
# ==============================================

suppressMessages(library(DESeq2))
suppressMessages(library(rtracklayer))
suppressMessages(library(GenomicRanges))
suppressMessages(library(ggplot2))
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))

# 1. Build DESeq2 object from filtered counts
dds <- DESeqDataSetFromMatrix(
  countData = round(sf.df.data),     # counts must be integers
  colData   = human_coldata,
  design    = ~ genotype
)
dds <- DESeq(dds)

# 2. Load GTF and compute exon union lengths
exons <- gtf[gtf$type == "exon"]

# Length per gene_id
exons_by_gene <- split(exons, exons$gene_id)
exonic_union  <- GenomicRanges::reduce(exons_by_gene)
gene_len_bp   <- vapply(exonic_union, function(gr) sum(width(gr)), integer(1))

# Attach basepairs to dds
rowData(dds)$basepairs <- gene_len_bp[rownames(dds)]

# 3. Compute FPKM
fpkm_mat <- fpkm(dds, robust = TRUE)
fpkm_df <- as.data.frame(fpkm_mat) %>%
  tibble::rownames_to_column("gene_id") %>%
  mutate(across(-gene_id, ~ round(.x, 3)))

# Preview
head(fpkm_df, 10)

# 4. Extract ARID5B (ENSG00000150347) expression
arid5b_expr <- fpkm_df %>%
  filter(gene_id == "ENSG00000150347") %>%
  pivot_longer(-gene_id, names_to = "Sample", values_to = "FPKM") %>%
  left_join(human_coldata, by = "Sample")   # no rownames_to_column needed

# 5. Plot expression across genotypes
ggplot(arid5b_expr, aes(x = genotype, y = FPKM, color = genotype)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.3) +
  geom_jitter(width = 0.15, size = 3) +
  labs(title = "ARID5B Expression (FPKM)",
       x = "Genotype", y = "FPKM (log scale)") +
  scale_y_log10() +
  theme_minimal()

```

# ðŸ”¹ PCA for NALM6
## PCA Before correction
```{r}
# ===============================================================
# PCA BEFORE batch correction (raw CPM-filtered counts)
# ===============================================================
suppressMessages({
  library(tidyverse)
  library(tidybulk)
  library(ggrepel)
})

# --- 1. Restrict to NALM6 samples
nalm6_coldata <- human_coldata %>%
  filter(cell_line == "NALM6")

# --- 2. Subset expression matrix
nalm6_expr <- sf.df.data[, nalm6_coldata$Sample, drop = FALSE] %>%
  as.data.frame() %>%
  tibble::rownames_to_column("gene_id")

# --- 3. Long / tidy format for tidybulk
nalm6_expr_tidy <- nalm6_expr %>%
  pivot_longer(-gene_id, names_to = "Sample", values_to = "abundance") %>%
  rename(gene = gene_id) %>%
  left_join(nalm6_coldata, by = "Sample")

# --- 4. PCA using tidybulk (no batch correction)
pca_raw <- nalm6_expr_tidy %>%
  tidybulk(.sample = Sample, .transcript = gene, .abundance = abundance) %>%
  keep_abundant() %>%
  scale_abundance() %>%
  reduce_dimensions(method = "PCA", .dims = 8)

# --- 5. Plot: genotype colour, batch fill, clone shape
pca_raw %>%
  pivot_sample() %>%
  ggplot(aes(x = PC1, y = PC2,
             color = genotype,
             shape = as.factor(clone),
             fill = batch,
             label = Sample)) +
  geom_point(size = 3, alpha = 0.9) +
  ggrepel::geom_text_repel(max.overlaps = 6, size = 3, show.legend = FALSE) +
  theme_minimal() +
  labs(
    title = "PCA before batch correction (raw CPM-filtered counts)",
    subtitle = "Colored by genotype, shaped by clone, filled by batch",
    x = "PC1", y = "PC2"
  )

```

## PCA after correction
```{r}
# ===============================================================
# PCA AFTER batch correction using ComBat-seq (sva >= 3.36.0)
# Reference: Zhang Y. et al., NAR Genomics & Bioinformatics 2020
# ===============================================================
suppressMessages({
  library(sva)        # For ComBat_seq
  library(tidyverse)
  library(tidybulk)
  library(ggrepel)
})

# --- 1. Prepare inputs for ComBat-seq
# Counts must be raw integers; matrix rows = genes, columns = samples
nalm6_counts <- sf.df.data[, nalm6_coldata$Sample, drop = FALSE]
nalm6_batches <- nalm6_coldata$batch

# Optionally preserve biological grouping (genotype) during adjustment
nalm6_groups <- nalm6_coldata$genotype

# --- 2. Run ComBat-seq
# (ComBat_seq expects a matrix, not a data frame)
combat_corrected <- ComBat_seq(
  as.matrix(nalm6_counts),
  batch = nalm6_batches,
  group = nalm6_groups
)

# --- 3. Convert corrected counts to tidy format
combat_tidy <- as.data.frame(combat_corrected) %>%
  tibble::rownames_to_column("gene_id") %>%
  pivot_longer(-gene_id, names_to = "Sample", values_to = "abundance") %>%
  rename(gene = gene_id) %>%
  left_join(nalm6_coldata, by = "Sample")

# --- 4. PCA on ComBat-seq adjusted counts
pca_combat <- combat_tidy %>%
  tidybulk(.sample = Sample, .transcript = gene, .abundance = abundance) %>%
  keep_abundant() %>%
  scale_abundance() %>%
  reduce_dimensions(method = "PCA", .dims = 8)

# --- 5. Plot comparison
pca_combat %>%
  pivot_sample() %>%
  ggplot(aes(x = PC1, y = PC2,
             color = genotype,
             shape = as.factor(clone),
             fill = batch,
             label = Sample)) +
  geom_point(size = 3, alpha = 0.9) +
  ggrepel::geom_text_repel(max.overlaps = 6, size = 3, show.legend = FALSE) +
  theme_minimal() +
  labs(
    title = "PCA after batch correction (ComBat-seq)",
    subtitle = "Batch effects adjusted; genotype structure preserved",
    x = "PC1", y = "PC2"
  )

```


# âœ… Updated QC Suite (SummarizedExperiment + plots)

```{r}
# ============================================================
# âœ… Updated QC Suite â€” NALM6 (18 samples, with batches)
# ============================================================

suppressMessages({
  library(SummarizedExperiment)
  library(tidyverse)
  library(reshape2)
  library(scales)
})

# ------------------------------------------------------------
# 1. Build SummarizedExperiment with filtered counts
# ------------------------------------------------------------
# Ensure colData matches the column order of sf.df.data
sf.df.se <- SummarizedExperiment(
  assays  = list(counts = as.matrix(sf.df.data)),
  colData = human_coldata[colnames(sf.df.data), ]
)

# Add descriptive sample names including clone, replicate, and batch
sf.df.se$detailed_name <- paste(
  sf.df.se$cell_line,
  sf.df.se$genotype,
  paste0("C", sf.df.se$clone),
  paste0("R", sf.df.se$replicate),
  sf.df.se$batch,
  sep = "_"
)

# ------------------------------------------------------------
# 2. Library size (raw counts per sample)
# ------------------------------------------------------------
library_sizes <- colSums(assay(sf.df.se))

ggplot(
  data.frame(
    Sample      = sf.df.se$detailed_name,
    Genotype    = sf.df.se$genotype,
    Batch       = sf.df.se$batch,
    LibrarySize = library_sizes
  ),
  aes(x = Sample, y = LibrarySize, fill = Batch)
) +
  geom_bar(stat = "identity", color = "black", width = 0.75) +
  scale_fill_manual(values = c("Batch1" = "#fdae61", "Batch2" = "#2b83ba")) +
  scale_y_continuous(labels = scales::comma) +
  theme_minimal(base_size = 13) +
  theme(
    axis.text.x  = element_text(angle = 90, hjust = 1, size = 10),
    plot.title   = element_text(size = 15, face = "bold"),
    legend.position = "top"
  ) +
  labs(
    title = "Library Size Distribution (18 NALM6 samples)",
    subtitle = "Colored by sequencing batch",
    x = "Sample (cell_line_genotype_clone_replicate_batch)",
    y = "Library Size (Raw Counts)",
    fill = "Batch"
  )

# ------------------------------------------------------------
# 3. Log2 expression distributions per sample
# ------------------------------------------------------------
# Log-transform counts (+1 to avoid log(0))
log_counts <- log2(assay(sf.df.se) + 1)

# Reshape into long format
log_counts_long <- reshape2::melt(log_counts)
colnames(log_counts_long) <- c("Gene", "Sample", "LogExpression")

# Annotate samples with detailed labels
log_counts_long <- log_counts_long %>%
  mutate(
    Group = sf.df.se$detailed_name[match(Sample, colnames(log_counts))],
    Genotype = sf.df.se$genotype[match(Sample, colnames(log_counts))],
    Batch = sf.df.se$batch[match(Sample, colnames(log_counts))]
  )

# Density plot by sample
ggplot(log_counts_long, aes(x = LogExpression, color = Genotype, linetype = Batch)) +
  geom_density(size = 1, alpha = 0.8) +
  theme_minimal(base_size = 13) +
  scale_color_manual(values = c("TT" = "#D55E00", "TC" = "#009E73", "CC" = "#0072B2")) +
  scale_linetype_manual(values = c("Batch1" = "solid", "Batch2" = "dashed")) +
  labs(
    title = "Log2 Gene Expression Distributions (18 NALM6 samples)",
    subtitle = "Color = Genotype, Linetype = Batch",
    x = "Log2(Counts + 1)",
    y = "Density",
    color = "Genotype",
    linetype = "Batch"
  ) +
  theme(
    axis.title  = element_text(size = 13),
    plot.title  = element_text(size = 15, face = "bold"),
    legend.text = element_text(size = 10)
  )

```
## Checking ARID5B expression pre Combat

```{r}
# ============================================================
# ARID5B (ENSG00000150347) Expression BEFORE ComBat-seq correction
# ============================================================

suppressMessages({
    library(edgeR)
    library(tidyverse)
    library(scales)
})

# --- 1. Compute CPM (Counts Per Million) from pre-correction counts ---
y <- DGEList(counts = sf.df.data)
cpm_matrix <- cpm(y, log = FALSE)

# --- 2. Extract ARID5B CPM values ---
arid5b_cpm <- as.data.frame(cpm_matrix["ENSG00000150347", , drop = FALSE]) %>%
    rownames_to_column("gene_id") %>%
    pivot_longer(-gene_id, names_to = "Sample", values_to = "CPM") %>%
    left_join(human_coldata, by = c("Sample" = "Sample"))

# --- 3. Order and relabel samples ---
arid5b_cpm <- arid5b_cpm %>%
    mutate(
        genotype = factor(genotype, levels = c("TT", "TC", "CC")),
        batch = factor(batch, levels = c("Batch1", "Batch2")),
        clone = as.factor(clone),
        replicate = as.factor(replicate),
        sample_label = paste0(genotype, "_C", clone, "_R", replicate),
        batch_linetype = ifelse(batch == "Batch2", "dashed", "solid")
    ) %>%
    arrange(genotype, clone, replicate)

# --- 4. Define color palette ---
genotype_colors <- c("TT" = "#E41A1C", "TC" = "#377EB8", "CC" = "#4DAF4A")

# --- 5. Build barplot ---
pre_comb_arid_plot <- ggplot(arid5b_cpm, aes(x = sample_label, y = CPM,
                                             fill = genotype, linetype = batch_linetype)) +
    geom_col(width = 0.7, color = "black", size = 0.5,
             position = position_dodge(width = 0.8)) +
    scale_fill_manual(values = genotype_colors) +
    scale_linetype_identity(guide = guide_legend(title = "Batch")) +
    theme_minimal(base_size = 14) +
    theme(
        axis.text.x  = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 11),
        axis.title   = element_text(face = "bold"),
        plot.title   = element_text(face = "bold", size = 16),
        plot.subtitle= element_text(size = 13),
        legend.position = "top",
        legend.title = element_text(face = "bold"),
        panel.grid.major.x = element_blank()
    ) +
    labs(
        title    = "ARID5B Expression (CPM-normalized counts)",
        subtitle = "Preâ€“ComBat-seq | Color = Genotype, dashed outline = Batch2",
        x = "Sample (Genotype_Clone_Replicate)",
        y = "CPM (Counts per Million)",
        fill = "Genotype"
    )

```

###Checking ARID5B postcomb
```{r}
# ============================================================
# ARID5B (ENSG00000150347) Expression AFTER ComBat-seq correction
# ============================================================

suppressMessages({
    library(edgeR)
    library(tidyverse)
    library(scales)
})

# --- 1. Compute CPM from batch-corrected counts ---
y_combat <- DGEList(counts = combat_corrected)
cpm_combat <- cpm(y_combat, log = FALSE)

# --- 2. Extract ARID5B CPM values ---
arid5b_cpm_combat <- as.data.frame(cpm_combat["ENSG00000150347", , drop = FALSE]) %>%
    rownames_to_column("gene_id") %>%
    pivot_longer(-gene_id, names_to = "Sample", values_to = "CPM") %>%
    left_join(human_coldata, by = c("Sample" = "Sample"))

# --- 3. Reorder and relabel ---
arid5b_cpm_combat <- arid5b_cpm_combat %>%
    mutate(
        genotype  = factor(genotype, levels = c("TT", "TC", "CC")),
        batch     = factor(batch, levels = c("Batch1", "Batch2")),
        clone     = as.factor(clone),
        replicate = as.factor(replicate),
        sample_label = paste0(genotype, "_C", clone, "_R", replicate),
        batch_linetype = ifelse(batch == "Batch2", "dashed", "solid")
    ) %>%
    arrange(genotype, clone, replicate)

# --- 4. Barplot ---
post_comb_arid_plot <- ggplot(arid5b_cpm_combat, aes(x = sample_label, y = CPM,
                                                     fill = genotype, linetype = batch_linetype)) +
    geom_col(width = 0.7, color = "black", size = 0.5,
             position = position_dodge(width = 0.8)) +
    scale_fill_manual(values = genotype_colors) +
    scale_linetype_identity(guide = guide_legend(title = "Batch")) +
    theme_minimal(base_size = 14) +
    theme(
        axis.text.x  = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 11),
        axis.title   = element_text(face = "bold"),
        plot.title   = element_text(face = "bold", size = 16),
        plot.subtitle= element_text(size = 13),
        legend.position = "top",
        legend.title = element_text(face = "bold"),
        panel.grid.major.x = element_blank()
    ) +
    labs(
        title    = "ARID5B Expression (CPM-normalized, after ComBat-seq correction)",
        subtitle = "Postâ€“ComBat-seq | Color = Genotype, dashed outline = Batch2",
        x = "Sample (Genotype_Clone_Replicate)",
        y = "CPM (Counts per Million)",
        fill = "Genotype"
    )

```

### Cowplot both

```{r}
# ============================================================
# ARID5B (ENSG00000150347) â€” FPKM before vs after ComBat-seq
# Same y-axis in both panels (uses global max across both)
# ============================================================

suppressMessages({
    library(tidyverse)
    library(GenomicRanges)
    library(cowplot)
})

# -----------------------------
# 0) Gene lengths (kb) per gene
# -----------------------------
if (exists("gtf")) {
    exons_gr <- gtf[gtf$type == "exon"]
} else {
    stopifnot(exists("gtf_df"))
    exons_gr <- makeGRangesFromDataFrame(
        gtf_df %>% filter(type == "exon"),
        seqnames.field = "seqnames",
        start.field    = "start",
        end.field      = "end",
        strand.field   = "strand",
        keep.extra.columns = TRUE
    )
}
exons_by_gene <- split(exons_gr, exons_gr$gene_id)
exonic_union  <- reduce(exons_by_gene)
gene_len_bp   <- vapply(exonic_union, function(gr) sum(width(gr)), numeric(1))
gene_len_kb   <- gene_len_bp / 1000
rm(exons_gr, exons_by_gene, exonic_union, gene_len_bp)

genes_with_len <- intersect(rownames(sf.df.data), names(gene_len_kb))
if (!"ENSG00000150347" %in% genes_with_len)
    stop("ARID5B (ENSG00000150347) not found among genes with lengths; check GTF IDs/row names.")

# --------------------------------------
# 1) Helper: counts -> FPKM (per sample)
# --------------------------------------
counts_to_fpkm <- function(counts_mat, length_kb_vec) {
    length_kb_vec <- length_kb_vec[rownames(counts_mat)]
    rpk <- sweep(counts_mat, 1, length_kb_vec, "/")
    lib_million <- colSums(counts_mat) / 1e6
    fpkm <- sweep(rpk, 2, lib_million, "/")
    return(fpkm)
}

# --------------------------------------
# 2) Pre- and post-ComBat count matrices
# --------------------------------------
counts_pre  <- sf.df.data[genes_with_len, , drop = FALSE]
counts_post <- combat_corrected[genes_with_len, colnames(counts_pre), drop = FALSE]

# --------------------------------------
# 3) Compute FPKM matrices
# --------------------------------------
fpkm_pre  <- counts_to_fpkm(counts_pre,  gene_len_kb)
fpkm_post <- counts_to_fpkm(counts_post, gene_len_kb)

# --------------------------------------
# 4) Extract ARID5B row and tidy for plotting
# --------------------------------------
prep_arid_df <- function(fpkm_mat, coldata) {
    as.data.frame(fpkm_mat["ENSG00000150347", , drop = FALSE]) %>%
        rownames_to_column("gene_id") %>%
        pivot_longer(-gene_id, names_to = "Sample", values_to = "FPKM") %>%
        left_join(coldata, by = c("Sample" = "Sample")) %>%
        mutate(
            genotype      = factor(genotype, levels = c("TT", "TC", "CC")),
            batch         = factor(batch, levels = c("Batch1", "Batch2")),
            clone         = as.factor(clone),
            replicate     = as.factor(replicate),
            sample_label  = paste0(genotype, "_C", clone, "_R", replicate),
            batch_linetype = ifelse(batch == "Batch2", "dashed", "solid")
        ) %>%
        arrange(genotype, clone, replicate)
}

arid5b_pre  <- prep_arid_df(fpkm_pre,  human_coldata)
arid5b_post <- prep_arid_df(fpkm_post, human_coldata)

# Ensure identical x order across panels
sample_order <- arid5b_pre$sample_label
arid5b_pre$sample_label  <- factor(arid5b_pre$sample_label,  levels = sample_order)
arid5b_post$sample_label <- factor(arid5b_post$sample_label, levels = sample_order)

# --------------------------------------
# 5) Global y-limit shared by both plots
# --------------------------------------
y_max <- max(c(arid5b_pre$FPKM, arid5b_post$FPKM), na.rm = TRUE)

genotype_colors <- c("TT" = "#E41A1C", "TC" = "#377EB8", "CC" = "#4DAF4A")

pre_comb_arid_fpkm_plot <- ggplot(arid5b_pre, aes(x = sample_label, y = FPKM,
                                                  fill = genotype, linetype = batch_linetype)) +
    geom_col(width = 0.7, color = "black", size = 0.5,
             position = position_dodge(width = 0.8)) +
    scale_fill_manual(values = genotype_colors) +
    scale_linetype_identity(guide = guide_legend(title = "Batch")) +
    scale_y_continuous(limits = c(0, y_max)) +
    theme_minimal(base_size = 14) +
    theme(
        axis.text.x   = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 11),
        axis.title    = element_text(face = "bold"),
        plot.title    = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 13),
        legend.position = "top",
        legend.title = element_text(face = "bold"),
        panel.grid.major.x = element_blank()
    ) +
    labs(
        title    = "ARID5B Expression (FPKM)",
        subtitle = "Preâ€“ComBat-seq | Fill = Genotype, dashed outline = Batch2",
        x = "Sample (Genotype_Clone_Replicate)",
        y = "FPKM",
        fill = "Genotype"
    )

post_comb_arid_fpkm_plot <- ggplot(arid5b_post, aes(x = sample_label, y = FPKM,
                                                    fill = genotype, linetype = batch_linetype)) +
    geom_col(width = 0.7, color = "black", size = 0.5,
             position = position_dodge(width = 0.8)) +
    scale_fill_manual(values = genotype_colors) +
    scale_linetype_identity(guide = guide_legend(title = "Batch")) +
    scale_y_continuous(limits = c(0, y_max)) +
    theme_minimal(base_size = 14) +
    theme(
        axis.text.x   = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 11),
        axis.title    = element_text(face = "bold"),
        plot.title    = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 13),
        legend.position = "top",
        legend.title = element_text(face = "bold"),
        panel.grid.major.x = element_blank()
    ) +
    labs(
        title    = "ARID5B Expression (FPKM)",
        subtitle = "Postâ€“ComBat-seq | Fill = Genotype, dashed outline = Batch2",
        x = "Sample (Genotype_Clone_Replicate)",
        y = "FPKM",
        fill = "Genotype"
    )

# --------------------------------------
# 6) Stack with cowplot
# --------------------------------------
combined_arid5b_fpkm <- plot_grid(
    pre_comb_arid_fpkm_plot,
    post_comb_arid_fpkm_plot,
    ncol = 1,
    labels = c("A", "B"),
    label_size = 18,
    label_fontface = "bold",
    align = "v",
    rel_heights = c(1, 1)
)

print(combined_arid5b_fpkm)
# ggsave("ARID5B_FPKM_Pre_vs_Post_ComBat_sameY.pdf", combined_arid5b_fpkm,
#        width = 10, height = 10, units = "in")

```


# # Doing DE, only one comparison

```{r}
# ==============================================
# DESeq2 Analysis: NALM6 TT vs CC
# ==============================================
suppressMessages(library(DESeq2))
suppressMessages(library(dplyr))
suppressMessages(library(tibble))

# 1. Filter metadata to only NALM6 TT and CC clones
meta_data <- sample_metadata %>%
  dplyr::filter(cell_line == "NALM6", genotype %in% c("TT", "CC")) %>%
  dplyr::mutate(genotype = factor(genotype, levels = c("CC", "TT")))  # CC = reference

# 2. Subset count matrix
filtered_bulk_matrix <- sf.df.data[, meta_data$sample_id_full]

# 3. Build DESeq2 object
dds <- DESeqDataSetFromMatrix(
  countData = as.matrix(filtered_bulk_matrix),
  colData   = meta_data,
  design    = ~ genotype
)

# 4. Run DESeq2
dds <- DESeq(dds)

# 5. Extract results: TT vs CC
res <- results(dds, contrast = c("genotype", "TT", "CC"), alpha = 0.05)

# 6. Tidy results
de_results_tt_vs_cc <- as.data.frame(res) %>%
  tibble::rownames_to_column("gene_id") %>%
  left_join(
    tx2gene_df %>%
      select(gene_id, gene_name) %>%
      distinct(gene_id, .keep_all = TRUE),
    by = "gene_id"
  ) %>%
  mutate(FoldChange = 2^log2FoldChange) %>%
  mutate(significance = case_when(
    FoldChange >= 1.5 & padj <= 0.05 ~ "up",
    FoldChange <= (1 / 1.5) & padj <= 0.05 ~ "down",
    TRUE ~ "ns"
  ))

# 7. Summarize DE results
cat("\n[DESeq2 TT vs CC summary]\n")
summary(res)

```

```{r}
# ==============================================
# Volcano plot: TT vs CC
# ==============================================
suppressMessages(library(ggplot2))
suppressMessages(library(ggrepel))

volcano_data <- de_results_tt_vs_cc %>%
  mutate(GeneSymbol = ifelse(is.na(gene_name), gene_id, gene_name)) %>%
  distinct(gene_id, .keep_all = TRUE) %>%
  select(GeneSymbol, log2FoldChange, padj, FoldChange, significance) %>%
  mutate(GeneType = significance)

# Plot styling
cols   <- c("up" = "#ffad73", "down" = "#26b3ff", "ns" = "grey80")
sizes  <- c("up" = 2.5, "down" = 2.5, "ns" = 1.2)
alphas <- c("up" = 1, "down" = 1, "ns" = 0.6)

ggplot(volcano_data, aes(
  x = log2(FoldChange),
  y = -log10(padj),
  fill = GeneType,
  size = GeneType,
  alpha = GeneType
)) +
  geom_point(shape = 21, colour = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  geom_vline(xintercept = c(log2(1 / 1.5), log2(1.5)), linetype = "dashed") +
  scale_fill_manual(values = cols) +
  scale_size_manual(values = sizes) +
  scale_alpha_manual(values = alphas) +
  ggrepel::geom_text_repel(
    data = filter(volcano_data, GeneType != "ns"),
    aes(label = GeneSymbol),
    size = 4,
    color = "darkblue",
    max.overlaps = 10,
    min.segment.length = Inf
  ) +
  labs(
    title = "Volcano Plot: NALM6 TT vs CC (padj â‰¤ 0.05, FC â‰¥ 1.5)",
    x = "log2(Fold Change)",
    y = "-log10(Adjusted P-value)"
  ) +
  theme_minimal(base_family = "Arial") +
  theme(
    panel.background = element_rect(fill = "white"),
    plot.background = element_rect(fill = "white"),
    legend.position = "bottom",
    plot.title = element_text(size = 18, face = "bold"),
    axis.title = element_text(size = 15),
    axis.text = element_text(size = 12)
  )

```

## Venn diagram of polyA and ribo0
```{r}
# ==============================================
# Venn diagrams: PolyA vs Ribo-0 DEG comparison
# ==============================================
suppressMessages(library(tidyverse))
suppressMessages(library(ggvenn))
suppressMessages(library(cowplot))

# 1. Load external DEG results (Ribo-0)
external_res <- read_csv(
  "~/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/cell_lines/rnaseq/Gene_expresion_analysis/deg_results_NALM6/DEG_gen_exp_NALM6_TT_vs_CC.csv"
)

# 2. Define UP/DOWN sets from current DESeq2 results (PolyA)
polyA_up <- de_results_tt_vs_cc %>%
  filter(significance == "up") %>%
  pull(gene_id)

polyA_down <- de_results_tt_vs_cc %>%
  filter(significance == "down") %>%
  pull(gene_id)

# 3. Define UP/DOWN sets from external results (Ribo-0)
ribo0_up <- external_res %>%
  filter(significance == "up") %>%
  pull(gene_id)

ribo0_down <- external_res %>%
  filter(significance == "down") %>%
  pull(gene_id)

# 4. Build lists for ggvenn
venn_up_list <- list(PolyA = polyA_up, Ribo0 = ribo0_up)
venn_down_list <- list(PolyA = polyA_down, Ribo0 = ribo0_down)

# 5. Create UP Venn plot
venn_up_plot <- ggvenn(
  venn_up_list,
  fill_color = c("#ffad73", "#26b3ff"),
  stroke_size = 1.5,
  set_name_size = 8,
  text_size = 8
) +
  ggtitle("Upregulated Genes: PolyA vs Ribo-0") +
  theme(
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5)
  )

# 6. Create DOWN Venn plot
venn_down_plot <- ggvenn(
  venn_down_list,
  fill_color = c("#ffad73", "#26b3ff"),
  stroke_size = 1.5,
  set_name_size = 8,
  text_size = 8
) +
  ggtitle("Downregulated Genes: PolyA vs Ribo-0") +
  theme(
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5)
  )

# 7. Combine plots vertically (no parentheses in labels)
combined_plot <- plot_grid(
  venn_up_plot, venn_down_plot,
  label_size = 24,
  label_fontface = "bold",
  ncol = 1,
  align = "v"
)

# 8. Display combined plot
print(combined_plot)

# Find overlapping genes
overlap_up <- intersect(polyA_up, ribo0_up)
overlap_down <- intersect(polyA_down, ribo0_down)

# Create data frame with direction
overlap_df <- tibble(
    gene_id = c(overlap_up, overlap_down),
    direction = c(rep("up", length(overlap_up)), rep("down", length(overlap_down)))
)

# Join with GTF to get gene symbols
overlap_annotated <- overlap_df %>%
    left_join(
        gtf_df %>% select(gene_id, gene_name) %>% distinct(),
        by = "gene_id"
    ) %>%
    select(gene_id, gene_name, direction)
# Save to CSV
write_csv(overlap_annotated, "overlapping_genes_both_RNA_technologies.csv")


```

### PolyA NALM6 for Utah
```{r}
# ==============================================================
# DEG analysis for NALM6 clones (TT, TC, CC) using limma-trend on TPM
# ==============================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(tibble)
  library(limma)
  library(ggplot2)
  library(ggrepel)
})

# ðŸ“‚ 1. Create output folder
nalm6_tpm_out_dir <- "PolyA_TPM_deg_results_NALM6"
if (!dir.exists(nalm6_tpm_out_dir)) dir.create(nalm6_tpm_out_dir)

# ðŸ§® Helper: convert counts â†’ TPM
counts_to_tpm <- function(counts, gene_lengths) {
  rpk <- sweep(counts, 1, gene_lengths, "/")        # reads per kilobase
  tpm <- apply(rpk, 2, function(x) x / sum(x, na.rm = TRUE) * 1e6)
  return(tpm)
}

# ðŸ§¬ 2. Function to run limma-trend DEG on TPM
run_deg_tpm_nalm6 <- function(count_matrix, metadata, ref_genotype, test_genotype, out_prefix) {
  
  # ðŸ“‚ Filter metadata for NALM6 and selected genotypes
  meta_data <- metadata %>%
    filter(cell_line == "NALM6", genotype %in% c(ref_genotype, test_genotype)) %>%
    mutate(genotype = factor(genotype, levels = c(ref_genotype, test_genotype)))
  rownames(meta_data) <- meta_data$sample_id_full
  
  # ðŸ“Š Subset count matrix
  filtered_counts <- count_matrix[, meta_data$sample_id_full, drop = FALSE]
  
  # ðŸ§¬ Gene lengths (kb) from GTF
  gene_lengths <- gtf_df %>%
    filter(type == "exon") %>%
    group_by(gene_id) %>%
    summarise(gene_length_kb = sum(width) / 1000, .groups = "drop")
  
  lengths_vec <- setNames(gene_lengths$gene_length_kb, gene_lengths$gene_id)
  lengths_vec <- lengths_vec[rownames(filtered_counts)]
  
  # ðŸ§® Convert counts â†’ TPM
  tpm_matrix <- counts_to_tpm(filtered_counts, lengths_vec)
  expr_log   <- log2(tpm_matrix + 1)
  
  # ðŸ“ Design
  design <- model.matrix(~ genotype, data = meta_data)
  colnames(design) <- c("Intercept", paste0(test_genotype,"_vs_",ref_genotype))
  
  # ðŸ”¬ limma-trend
  fit <- lmFit(expr_log, design)
  fit <- eBayes(fit, trend = TRUE)
  coef_name <- colnames(design)[2]
  
  tpm_res <- topTable(fit, coef = coef_name, number = Inf) %>%
    rownames_to_column("gene_id") %>%
    left_join(tx2gene_df %>% distinct(gene_id, gene_name), by = "gene_id") %>%
    mutate(
      significance = case_when(
        P.Value <= 0.05 & logFC >=  0.2 ~ "up",
        P.Value <= 0.05 & logFC <= -0.2 ~ "down",
        TRUE ~ "ns"
      )
    ) %>%
    filter(!is.na(P.Value), !is.na(logFC))
  
  # ðŸ’¾ Save results
  write.csv(tpm_res, file = file.path(nalm6_tpm_out_dir, paste0(out_prefix, ".csv")), row.names = FALSE)
  
  # === Volcano plot ===
  x_max <- max(abs(tpm_res$logFC), na.rm = TRUE)
  y_max <- max(-log10(tpm_res$P.Value), na.rm = TRUE)
  
  highlight_gene <- "ENSG00000150347"  # ARID5B
  highlight_data <- tpm_res %>% filter(gene_id == highlight_gene)
  
  volcano_plot <- ggplot(tpm_res, aes(x = logFC, y = -log10(P.Value),
                                      fill = significance, alpha = significance)) +
    geom_point(shape = 21, colour = "black", size = 2) +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", colour = "grey50") +
    geom_vline(xintercept = c(-0.2, 0.2), linetype = "dashed", colour = "grey50") +
    scale_fill_manual(values = c(up = "#D55E00", down = "#0072B2", ns = "grey80")) +
    scale_alpha_manual(values = c(up = 0.9, down = 0.9, ns = 0.5), guide = "none") +
    coord_cartesian(xlim = c(-x_max, x_max), ylim = c(0, y_max)) +
    
    # ðŸ”µ Highlight ARID5B (only if present)
    geom_point(data = highlight_data, aes(x = logFC, y = -log10(P.Value)),
               color = "#1F77B4", fill = "white", shape = 21, size = 3) +
    geom_label_repel(
      data = highlight_data,
      aes(x = logFC, y = -log10(P.Value),
          label = ifelse(!is.na(gene_name), gene_name, gene_id)),
      nudge_x = 2, nudge_y = 2,
      color = "black", fill = "white",
      fontface = "bold", size = 5,
      box.padding = 0.5, point.padding = 0.3,
      segment.color = "#1F77B4", segment.size = 1,
      label.size = 0.4, label.r = unit(0.15, "lines"),
      max.overlaps = Inf
    ) +
    
    theme_minimal(base_size = 14) +
    labs(
      title = paste0("Volcano: NALM6 ", test_genotype, " vs ", ref_genotype, 
                     " (limma-trend, TPM)"),
      x = "log2 Fold Change", y = "-log10(p-value)", fill = "Significance"
    )
  
  # ðŸ’¾ Save volcano plot
  ggsave(
    filename = file.path(nalm6_tpm_out_dir, paste0(out_prefix, "_volcano.pdf")),
    plot = volcano_plot,
    width = 8, height = 6, units = "in"
  )
  
  list(results = tpm_res, plot = volcano_plot)
}

# ðŸš€ 3. Run comparisons
nalm6_tpm_tt_vs_tc <- run_deg_tpm_nalm6(sf.df.data, sample_metadata, "TC", "TT", "TPM_NALM6_TT_vs_TC")
nalm6_tpm_tc_vs_cc <- run_deg_tpm_nalm6(sf.df.data, sample_metadata, "CC", "TC", "TPM_NALM6_TC_vs_CC")
nalm6_tpm_tt_vs_cc <- run_deg_tpm_nalm6(sf.df.data, sample_metadata, "CC", "TT", "TPM_NALM6_TT_vs_CC")

# ðŸ“Š Print volcano plots
nalm6_tpm_tt_vs_tc$plot
nalm6_tpm_tc_vs_cc$plot
nalm6_tpm_tt_vs_cc$plot

```

# DEG analysis for NALM6 (TT, TC, CC) using limma-trend on TPM


```{r}
# ==============================================================
# DEG analysis for NALM6 (TT, TC, CC) using limma-trend on TPM
# Including all clones; excluding non-coding genes only
# Thresholds: p â‰¤ 0.05, |log2FC| â‰¥ 0.5
# ==============================================================

suppressPackageStartupMessages({
    library(dplyr)
    library(tibble)
    library(limma)
    library(ggplot2)
    library(ggrepel)
})

# ðŸ“‚ 1. Create output directory
nalm6_polyA_outdir <- "PolyA_TPM_deg_results_NALM6"
if (!dir.exists(nalm6_polyA_outdir)) dir.create(nalm6_polyA_outdir)

# ðŸ§® Helper: counts â†’ TPM
counts_to_tpm <- function(counts, gene_length_kb) {
    rpk <- sweep(counts, 1, gene_length_kb, "/")  # Reads per kilobase
    tpm <- apply(rpk, 2, function(x) x / sum(x, na.rm = TRUE) * 1e6)
    return(tpm)
}

# ðŸ§¬ 2. Function for limma-trend DEG on TPM
run_deg_tpm_nalm6 <- function(count_matrix, metadata, ref_genotype, test_genotype, out_prefix,
                              p_cutoff = 0.05, fc_cutoff = 0.5) {
    
    # ---- Filter metadata (include all clones, no exclusions) ----
    meta_data <- metadata %>%
        filter(cell_line == "NALM6",
               genotype %in% c(ref_genotype, test_genotype)) %>%
        mutate(genotype = factor(genotype, levels = c(ref_genotype, test_genotype)))
    
    rownames(meta_data) <- meta_data$sample_id_full
    
    # ---- Subset count matrix ----
    filtered_counts <- count_matrix[, meta_data$sample_id_full, drop = FALSE]
    
    # ---- Keep only coding (protein-coding) genes ----
    coding_genes <- gtf_df %>%
        filter(type == "gene", gene_biotype == "protein_coding") %>%
        pull(gene_id) %>% unique()
    
    filtered_counts <- filtered_counts[rownames(filtered_counts) %in% coding_genes, ]
    
    # ---- Compute gene lengths (kb) from exon union ----
    gene_lengths <- gtf_df %>%
        filter(type == "exon") %>%
        group_by(gene_id) %>%
        summarise(gene_length_kb = sum(width) / 1000, .groups = "drop")
    
    lengths_vec <- setNames(gene_lengths$gene_length_kb, gene_lengths$gene_id)
    lengths_vec <- lengths_vec[rownames(filtered_counts)]
    
    # ---- Counts â†’ TPM ----
    tpm_matrix <- counts_to_tpm(filtered_counts, lengths_vec)
    expr_log <- log2(tpm_matrix + 1)
    
    # ---- Design matrix ----
    design <- model.matrix(~ genotype, data = meta_data)
    colnames(design) <- c("Intercept", paste0(test_genotype, "_vs_", ref_genotype))
    
    # ---- Fit limma-trend model ----
    fit <- lmFit(expr_log, design)
    fit <- eBayes(fit, trend = TRUE)
    coef_name <- colnames(design)[2]
    
    # ---- Results ----
    tpm_res <- topTable(fit, coef = coef_name, number = Inf) %>%
        rownames_to_column("gene_id") %>%
        left_join(tx2gene_df %>% distinct(gene_id, gene_name), by = "gene_id") %>%
        mutate(
            significance = case_when(
                P.Value <= p_cutoff & logFC >=  fc_cutoff  ~ "up",
                P.Value <= p_cutoff & logFC <= -fc_cutoff  ~ "down",
                TRUE ~ "ns"
            )
        ) %>%
        filter(!is.na(P.Value), !is.na(logFC))
    
    # ðŸ’¾ Save results
    write.csv(tpm_res, file = file.path(nalm6_polyA_outdir, paste0(out_prefix, ".csv")), row.names = FALSE)
    
    # ---- Volcano plot ----
    x_max <- max(abs(tpm_res$logFC), na.rm = TRUE)
    y_max <- max(-log10(tpm_res$P.Value), na.rm = TRUE)
    
    highlight_gene <- "ENSG00000150347"  # ARID5B
    highlight_data <- tpm_res %>% filter(gene_id == highlight_gene)
    
    volcano_plot <- ggplot(tpm_res, aes(x = logFC, y = -log10(P.Value),
                                        fill = significance, alpha = significance)) +
        geom_point(shape = 21, colour = "black", size = 2) +
        geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed", colour = "grey50") +
        geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed", colour = "grey50") +
        scale_fill_manual(values = c(up = "#D55E00", down = "#0072B2", ns = "grey80")) +
        scale_alpha_manual(values = c(up = 0.9, down = 0.9, ns = 0.5), guide = "none") +
        coord_cartesian(xlim = c(-x_max, x_max), ylim = c(0, y_max)) +
        
        # ðŸ”µ Highlight ARID5B if present
        geom_point(data = highlight_data, aes(x = logFC, y = -log10(P.Value)),
                   color = "#1F77B4", fill = "white", shape = 21, size = 3) +
        geom_label_repel(
            data = highlight_data,
            aes(x = logFC, y = -log10(P.Value),
                label = ifelse(!is.na(gene_name), gene_name, gene_id)),
            nudge_x = 2, nudge_y = 2,
            color = "black", fill = "white",
            fontface = "bold", size = 5,
            box.padding = 0.5, point.padding = 0.3,
            segment.color = "#1F77B4", segment.size = 1,
            label.size = 0.4, label.r = unit(0.15, "lines"),
            max.overlaps = Inf
        ) +
        theme_minimal(base_size = 14) +
        labs(
            title = paste0(
                "PolyA Volcano (coding genes only, thresholds: p â‰¤ ", p_cutoff,
                ", |logâ‚‚FC| â‰¥ ", fc_cutoff, "): NALM6 ", test_genotype, " vs ", ref_genotype
            ),
            x = "logâ‚‚ Fold Change",
            y = expression(-log[10](p~value)),
            fill = "Significance"
        )
    
    # ðŸ’¾ Save plot
    ggsave(
        filename = file.path(nalm6_polyA_outdir, paste0(out_prefix, "_volcano.pdf")),
        plot = volcano_plot,
        width = 8, height = 6, units = "in"
    )
    
    list(results = tpm_res, plot = volcano_plot)
}

# ðŸš€ Run pairwise comparisons (include all clones)
nalm6_polyA_tt_vs_tc <- run_deg_tpm_nalm6(sf.df.data, sample_metadata, "TC", "TT", "PolyA_TPM_NALM6_TT_vs_TC")
nalm6_polyA_tc_vs_cc <- run_deg_tpm_nalm6(sf.df.data, sample_metadata, "CC", "TC", "PolyA_TPM_NALM6_TC_vs_CC")
nalm6_polyA_tt_vs_cc <- run_deg_tpm_nalm6(sf.df.data, sample_metadata, "CC", "TT", "PolyA_TPM_NALM6_TT_vs_CC")

# ðŸ“Š Display volcano plots
nalm6_polyA_tt_vs_tc$plot
nalm6_polyA_tc_vs_cc$plot
nalm6_polyA_tt_vs_cc$plot


```

## Venn diagrams with Wenjians results

```{r}
# ==============================================================
# Venn diagrams + intersected gene export
# NALM6 vs Wenjian (ProB) â€” TPM, p â‰¤ 0.05, |log2FC| â‰¥ 0.5
# ==============================================================
suppressPackageStartupMessages({
    library(dplyr)
    library(readr)
    library(ggvenn)
    library(cowplot)
    library(ggplot2)
    library(purrr)
    library(tibble)
})

# --- Create output directory ----------------------------------
outdir <- "venn_diag_nalm6_wenjians_Oct_15"
if (!dir.exists(outdir)) dir.create(outdir)

# --- Helper: build clean venn plot ----------------------------
make_venn_plot <- function(nalm6_df, wenjian_df, sig_dir, title_text) {
    ggvenn(
        list(
            NALM6  = nalm6_df %>% filter(significance == sig_dir) %>% pull(gene_id),
            Wenjian = wenjian_df %>% filter(significance == sig_dir) %>% pull(gene_id)
        ),
        fill_color   = c("#E69F00", "#56B4E9"),
        stroke_size  = 0.8,
        set_name_size = 4.5
    ) +
        ggtitle(title_text) +
        theme(
            plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
        )
}

# --- Wenjian directory ----------------------------------------
wenjian_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/Only_Coding_ProB_TPM_DEG_results"

# --- Function to load both datasets for a given contrast -------
load_deg_pair <- function(contrast) {
    nalm6_path <- file.path(getwd(), "PolyA_TPM_deg_results_NALM6",
                            paste0("PolyA_TPM_NALM6_", contrast, ".csv"))
    wenjian_path <- file.path(wenjian_dir, paste0("ProB_", contrast, "_results.csv"))
    
    nalm6 <- read_csv(nalm6_path, show_col_types = FALSE) %>%
        filter(significance %in% c("up", "down")) %>%
        transmute(gene_id, gene_name, significance)
    
    wenjian <- read_csv(wenjian_path, show_col_types = FALSE) %>%
        filter(sig %in% c("up", "down")) %>%
        transmute(gene_id = ensembl_id,
                  gene_name = hgnc_symbol,
                  significance = sig)
    
    list(nalm6 = nalm6, wenjian = wenjian)
}

# --- Helper: compute intersections ----------------------------
get_intersections <- function(pair, contrast) {
    up_common <- intersect(
        pair$nalm6 %>% filter(significance == "up") %>% pull(gene_id),
        pair$wenjian %>% filter(significance == "up") %>% pull(gene_id)
    )
    down_common <- intersect(
        pair$nalm6 %>% filter(significance == "down") %>% pull(gene_id),
        pair$wenjian %>% filter(significance == "down") %>% pull(gene_id)
    )
    tibble(
        contrast = contrast,
        intersected_up_genes   = paste(up_common, collapse = "; "),
        intersected_down_genes = paste(down_common, collapse = "; "),
        n_up   = length(up_common),
        n_down = length(down_common)
    )
}

# ==============================================================
# ðŸš€ Run all contrasts (TTvsCC, TCvsCC, TTvsTC)
# ==============================================================
contrasts <- c("TT_vs_CC", "TC_vs_CC", "TT_vs_TC")

# Load all pairs
pairs <- set_names(map(contrasts, load_deg_pair), contrasts)

# --- Build plots and intersection tables ----------------------
plots_list <- list()
intersect_tbl <- map2_dfr(
    pairs, contrasts,
    ~{
        p_up <- make_venn_plot(.x$nalm6, .x$wenjian, "up",
                               paste0("Common UP genes (", .y, ", TPM, p â‰¤ 0.05, |logâ‚‚FC| â‰¥ 0.5)"))
        p_dn <- make_venn_plot(.x$nalm6, .x$wenjian, "down",
                               paste0("Common DOWN genes (", .y, ", TPM, p â‰¤ 0.05, |logâ‚‚FC| â‰¥ 0.5)"))
        
        plots_list[[.y]] <<- plot_grid(p_up, p_dn, ncol = 2, align = "hv", labels = c("A", "B"))
        
        get_intersections(.x, .y)
    }
)

# --- Combine all plots vertically ------------------------------
final_venn <- plot_grid(
    plots_list$TT_vs_CC,
    plots_list$TC_vs_CC,
    plots_list$TT_vs_TC,
    ncol = 1,
    label_fontface = "bold", label_size = 14, align = "v"
)

# --- Save outputs ----------------------------------------------
# Save combined figure
pdf_path <- file.path(outdir, "Combined_Venn_TPM_p0.05_FC0.5.pdf")
ggsave(pdf_path, final_venn, width = 12, height = 18)
message("âœ… Saved combined figure: ", pdf_path)

# Save intersection table
csv_path <- file.path(outdir, "Intersected_Genes_TPM_p0.05_FC0.5.csv")
write_csv(intersect_tbl, csv_path)
message("âœ… Saved intersection table: ", csv_path)

# --- Print preview ---------------------------------------------
print(intersect_tbl)
final_venn

```



```{r}
# ==============================================================
# Venn diagrams per exclusion scenario (TT Clone1 removal)
# Compare NALM6 vs Wenjian-style layout: TTvsCC, TCvsCC, TTvsTC
# TPM | p â‰¤ 0.05 | |log2FC| â‰¥ 0.5
# ==============================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(readr)
  library(ggvenn)
  library(cowplot)
  library(ggplot2)
  library(purrr)
  library(stringr)
})

# --- Output root directory ------------------------------------
outdir_root <- "PolyA_TPM_deg_results_NALM6_exclusion_scenarios"
if (!dir.exists(outdir_root)) dir.create(outdir_root)

# --- Helper for nice Venn plots -------------------------------
make_venn_pair <- function(nalm6_df, contrast, sig_dir, scenario_label) {
  ggvenn(
    list(
      NALM6 = nalm6_df %>% filter(significance == sig_dir) %>% pull(gene_id),
      Wenjian = deg_wenjian_list[[contrast]] %>%
        filter(sig %in% c("up", "down"), sig == sig_dir) %>%
        pull(ensembl_id)
    ),
    fill_color = c("#E69F00", "#56B4E9"),
    stroke_size = 0.8,
    set_name_size = 4.5
  ) +
    ggtitle(paste0(
      "Common ", toupper(sig_dir), " genes (", contrast, ", TPM, p â‰¤ 0.05, |logâ‚‚FC| â‰¥ 0.5)\n",
      scenario_label
    )) +
    theme(plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
}

# --- Wenjian DEG absolute paths (already existing) ------------
wenjian_dir <- "/Users/cojulian/Desktop/Tzu_projects/Matt/Clarissa/snp_cell_lines_public_datasets_project/sj_expression_arid5b_Wenjian/Only_Coding_ProB_TPM_DEG_results"

deg_wenjian_list <- list(
  "TT_vs_CC" = read_csv(file.path(wenjian_dir, "ProB_TT_vs_CC_results.csv"), show_col_types = FALSE),
  "TC_vs_CC" = read_csv(file.path(wenjian_dir, "ProB_TC_vs_CC_results.csv"), show_col_types = FALSE),
  "TT_vs_TC" = read_csv(file.path(wenjian_dir, "ProB_TT_vs_TC_results.csv"), show_col_types = FALSE)
)

# --- Helper: counts â†’ TPM -------------------------------------
counts_to_tpm <- function(counts, gene_length_kb) {
  rpk <- sweep(counts, 1, gene_length_kb, "/")
  apply(rpk, 2, function(x) x / sum(x, na.rm = TRUE) * 1e6)
}

# --- Main DEG runner ------------------------------------------
run_deg_tpm_nalm6 <- function(count_matrix, metadata, ref_genotype, test_genotype,
                              scenario_label, p_cutoff = 0.05, fc_cutoff = 0.5) {

  scenario_dir <- file.path(outdir_root, paste0("scenario_", str_replace_all(scenario_label, " ", "_")))
  if (!dir.exists(scenario_dir)) dir.create(scenario_dir)
  
  meta_data <- metadata %>%
    filter(cell_line == "NALM6", genotype %in% c(ref_genotype, test_genotype)) %>%
    mutate(genotype = factor(genotype, levels = c(ref_genotype, test_genotype)))
  rownames(meta_data) <- meta_data$sample_id_full
  filtered_counts <- count_matrix[, meta_data$sample_id_full, drop = FALSE]
  
  coding_genes <- gtf_df %>% filter(type == "gene", gene_biotype == "protein_coding") %>% pull(gene_id)
  filtered_counts <- filtered_counts[rownames(filtered_counts) %in% coding_genes, ]
  
  gene_lengths <- gtf_df %>% filter(type == "exon") %>%
    group_by(gene_id) %>% summarise(gene_length_kb = sum(width) / 1000, .groups = "drop")
  lengths_vec <- setNames(gene_lengths$gene_length_kb, gene_lengths$gene_id)[rownames(filtered_counts)]
  
  tpm_matrix <- counts_to_tpm(filtered_counts, lengths_vec)
  expr_log <- log2(tpm_matrix + 1)
  
  design <- model.matrix(~ genotype, data = meta_data)
  colnames(design) <- c("Intercept", paste0(test_genotype, "_vs_", ref_genotype))
  
  fit <- eBayes(lmFit(expr_log, design), trend = TRUE)
  coef_name <- colnames(design)[2]
  
  topTable(fit, coef = coef_name, number = Inf) %>%
    rownames_to_column("gene_id") %>%
    left_join(tx2gene_df %>% distinct(gene_id, gene_name), by = "gene_id") %>%
    mutate(
      significance = case_when(
        P.Value <= p_cutoff & logFC >=  fc_cutoff  ~ "up",
        P.Value <= p_cutoff & logFC <= -fc_cutoff  ~ "down",
        TRUE ~ "ns"
      )
    )
}

# ==============================================================
# âš™ï¸ Define scenarios
# ==============================================================
scenarios <- list(
  "Remove TT Clone1 from Batch1" = sample_metadata %>%
    filter(!(genotype == "TT" & clone == 1 & batch == "Batch1")),
  "Remove TT Clone1 from Batch2" = sample_metadata %>%
    filter(!(genotype == "TT" & clone == 1 & batch == "Batch2")),
  "Remove TT Clone1 from Both Batches" = sample_metadata %>%
    filter(!(genotype == "TT" & clone == 1))
)

# ==============================================================
# ðŸš€ Generate Venn diagrams for each scenario
# ==============================================================
venn_dir <- file.path(outdir_root, "venn_figures_by_scenario")
if (!dir.exists(venn_dir)) dir.create(venn_dir)

for (scen_name in names(scenarios)) {
  meta_scen <- scenarios[[scen_name]]
  
  # Run all contrasts
  contrasts <- c("TT_vs_CC", "TC_vs_CC", "TT_vs_TC")
  deg_results <- purrr::map(contrasts, function(cn) {
    parts <- strsplit(cn, "_vs_")[[1]]
    run_deg_tpm_nalm6(sf.df.data, meta_scen, parts[2], parts[1], scen_name)
  })
  names(deg_results) <- contrasts
  
  # Make 6-panel Venn (3 contrasts Ã— up/down)
  venn_plots <- purrr::map(contrasts, function(cn) {
    df <- deg_results[[cn]]
    p_up <- make_venn_pair(df, cn, "up", scen_name)
    p_dn <- make_venn_pair(df, cn, "down", scen_name)
    plot_grid(p_up, p_dn, ncol = 2, align = "hv", labels = c("A", "B"))
  })
  
  final_fig <- plot_grid(plotlist = venn_plots, ncol = 1, align = "v")
  
  pdf_path <- file.path(venn_dir, paste0("Venn_", str_replace_all(scen_name, " ", "_"), ".pdf"))
  ggsave(pdf_path, final_fig, width = 14, height = 18)
  message("âœ… Saved: ", pdf_path)
}

```


